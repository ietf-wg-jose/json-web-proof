{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-07-30T00:42:26.898992+00:00",
  "repo": "ietf-wg-jose/json-web-proof",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "JPT",
      "description": "JSON Proof Token",
      "color": "8BF97D"
    },
    {
      "name": "JPA",
      "description": "JSON Proof Algorithms",
      "color": "0e8a16"
    },
    {
      "name": "JWP",
      "description": "JSON Web Proof",
      "color": "c5def5"
    },
    {
      "name": "PR-ready",
      "description": "Ready for anyone to create a PR",
      "color": "F3FC78"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU5NDgxMTE0ODg=",
      "title": "Alternative format for credential claims",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/2",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JPT"
      ],
      "body": "I would like to propose an alternative format for credential claims from metadata:\r\n\r\n## Payload slot metadata\r\n``` json\r\n{ \"claims\": [\"family_name\", \"given_name\"] }\r\n```\r\n\r\n## Corresponding payload slot\r\n``` json\r\n[\"Waite\", \"David\"]\r\n```\r\n\r\nThe claims payload property is always an array of one or more keys, while the slot would be an array of one or more values.\r\n\r\nA credential-level specification can use this definition for combining claims into a JSON document, including how to combine multiple payload slots into a resulting JSON document for exposure to the application level on the verifier.\r\n\r\nOne motivation here is to have a simplified path-like syntax for the claims names for describing how to compose more complex documents, e.g. a payload slot metadata of:\r\n\r\n``` json\r\n{\"claims\": [\"address.postal_code\", \"address.country\"] }\r\n```",
      "createdAt": "2021-07-19T23:33:58Z",
      "updatedAt": "2021-12-14T19:02:32Z",
      "closedAt": "2021-12-14T19:02:32Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "While this has a very nice simplicity to it, I do believe it will be necessary to support additional header values per-payload such as content type.  One alternative strategy might be for JWP to require the JWK simply uniquely _name/identify_ each payload, and that applications must be able to determine the content type from the name/id by context or some external mechanism. This is similar to how the JWT defines certain claim names and the exact type of value for each (`NumericDate`, `StringOrURI`, etc) and it's opaque to the JWS.\r\n\r\nThis would look something like:\r\n```json\r\n{ \"payloads\": [\"family_name\", \"given_name\", \"E18FF842\", \"http://www.w3.org/2002/12/cal/ical#\"] }\r\n```\r\n\r\nThe path-like syntax would only be relevant to applications that want to re-combine multiple payloads, and given the privacy focus of JWP I'm not sure that is a safe approach to encourage.  Applications will need to understand for any given payload if the result is from a proof (predicate, boolean, etc) and should not rely on always expecting the raw claim values.",
          "createdAt": "2021-08-18T00:28:02Z",
          "updatedAt": "2021-08-18T00:45:58Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Since we seem to have a  primary pattern of data applied to a template [e.g. [MadLibs](https://www.madlibs.com)] there could be a lot of variance and bike shedding to how we describe JWT-style claims. I suggest we try to have a solid initial proposal before going to a wider group, and be willing to encourage multiple sheds if things are too divergent.",
          "createdAt": "2021-09-06T21:57:37Z",
          "updatedAt": "2021-09-06T21:57:37Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Converting between objects and arrays is a very solved problem... its a terrible idea for a JSON based standard to invent a new way of doing this... here is an example using JSON Pointer.\r\n\r\n```ts\r\nimport pointer from 'json-pointer';\r\n\r\nconst objectToMessages = (obj: any) => {\r\n  const dict = pointer.dict(obj);\r\n  const messages = Object.keys(dict).map(key => {\r\n    return `{\"${key}\": \"${dict[key]}\"}`;\r\n  });\r\n  return messages;\r\n};\r\n\r\nconst messagesToObject = (messages: string[]) => {\r\n  const obj = {};\r\n  messages\r\n    .map(m => {\r\n      return JSON.parse(m);\r\n    })\r\n    .forEach(m => {\r\n      const [key] = Object.keys(m);\r\n      const value = m[key];\r\n      pointer.set(obj, key, value);\r\n    });\r\n  return obj;\r\n};\r\n\r\nexport { objectToMessages, messagesToObject };\r\n```\r\n\r\n```js\r\nconst messages = await objectToMessages(credential);\r\nexpect(messages).toEqual([\r\n    '{\"/@context/0\": \"https://www.w3.org/2018/credentials/v1\"}',\r\n    '{\"/@context/1/alsoKnownAs\": \"https://www.w3.org/ns/activitystreams#alsoKnownAs\"}',\r\n    '{\"/id\": \"http://example.edu/credentials/3732\"}',\r\n    '{\"/type/0\": \"VerifiableCredential\"}',\r\n    '{\"/issuer\": \"https://example.edu/issuers/14\"}',\r\n    '{\"/issuanceDate\": \"2010-01-01T19:23:24Z\"}',\r\n    '{\"/credentialSubject/alsoKnownAs\": \"did:example:ebfeb1f712ebc6f1c276e12ec21\"}',\r\n  ]);\r\n```\r\n\r\nThe domain of the \"key\" side should be fixed and use json pointer.\r\n\r\nThe domain of the \"value\" side is the problem.\r\n\r\nI would propose that it be limited to legal JSON primitive \"values\", aka: \r\n\r\nhttps://www.json.org/json-en.html\r\n\r\n\"string\", \"number\", \"boolean\" or \"null\".\r\n\r\nWhen handling a higher order JWP object, you might find that \"isOver21: true\" is constructed from complexity, but a holder when inspecting these credentials should not be forced to see that when observing claims.\r\n\r\n",
          "createdAt": "2021-12-04T18:02:48Z",
          "updatedAt": "2021-12-04T18:02:48Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Since we've currently settled on the simple flat `claims` array in the latest draft, I'm going to close this issue.\r\n\r\nWe can open a new issue if there's a new proposal moving forward from the current draft.",
          "createdAt": "2021-12-14T19:02:32Z",
          "updatedAt": "2021-12-14T19:02:32Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU5NTA5NTAyMzE=",
      "title": "JWP does not separate the signing layer from the claims layer, like JWS and JWT do",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/4",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JPT"
      ],
      "body": "JWS signs a binary payload that it knows nothing about.  JWT specifies a binary payload that is an encoding of JSON claims.  The JWT spec currently specifies signing an array of payloads but *also* specifies sets of claim names for these payloads.\r\n\r\nI'd like us to think about whether we should factor the signing part and the claims part into layered specs, analogous to JWS and JWT.  I realize that we'd still have to declare the list of payloads tied to the key in a way that didn't leak information.  And that if we layer the signing and the claims, we'd likely also have to declare the claims in a way that matched the payloads and that didn't also leak information.\r\n\r\nRestructuring things this way may be more work, but we may end up thanking ourselves because the resulting specs will be more general.",
      "createdAt": "2021-07-22T18:45:27Z",
      "updatedAt": "2021-12-14T19:03:31Z",
      "closedAt": "2021-12-14T19:03:30Z",
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "NONE",
          "body": "I think separating the signing and claims layer would definitely open up more flexibility for JWP to be used in existing proof systems that use aggregated signatures. One way to tackle this would be adding opportunity to describe the claims layer, similar to how JWK can describe the claims, but part of the JWP in a privacy preserving way.\r\n\r\nBBS payloads are a set of hashed messages, and those messages can either be a set of direct claims, or canonical representation of some other data structure. Some examples on potential BBS payloads:\r\n\r\nClaims payload\r\n```js\r\n'{ \"email\":\"janedoe@example.com\"}'\r\n```\r\n\r\nN-Quad payload\r\n```js\r\n'_:c14n0 <http://schema.org/email> \"janedoe@example.com\" .'\r\n```\r\n\r\nJSON Pointer payload\r\n```js\r\n'{ \"/account/email\": \"janedoe@example.com\" }'\r\n```\r\n\r\nURI payload\r\n```js\r\n'https://example.com/person.json#/email'\r\n```\r\n\r\nSome of these payloads (Claims and URI) directly represent the signed data while N-Quads and JSON Pointer are canonical representations of the actual data. It becomes clear that JWP shouldn't include the canonical form of the signed data, as clients would be required to reconstruct it in order to use it, but this may not always be possible.\r\n\r\nI think the JWP could allow some sort of additional indicator that described what the data is that would point to the canonicalization algorithm and include the original payload in the `payloads` field.\r\n\r\nFor example:\r\n\r\n```js\r\n{\r\n  \"protected\": {\r\n    \"typ\": \"JWP\",\r\n    \"alg\": \"BBS-BLS12381\",\r\n    \"crit\": [ \"c14n\" ],\r\n    \"c14n\": \"URDNA2015\" // field name can be different, example only\r\n  },\r\n  \"payloads\": {\r\n    \"@context\": \"https://schema.org\",\r\n    \"email\": \"janedoe@example.com\"\r\n    // JSON object can be any depth\r\n  }\r\n}\r\n```\r\n\r\nThis approach will uniquely describe the final set of claims that will be signed with the specified algorithm.\r\nWhen claims are used, the `c14n` field can be omitted and systems assume the format as currently described in JWP. This approach will also allow selective disclosure with BBS.\r\n",
          "createdAt": "2021-08-24T12:41:46Z",
          "updatedAt": "2021-08-24T12:45:54Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @tmarkovski, I think I follow your line of thinking.\r\n\r\nOne of the design principles of JWP is to strictly separate the static metadata that describes a payload from the actual signed payload values.  The purpose of this is to maximize unlinkability by ensuring that a JWP cannot be constructed improperly such that the location of a payload reveals identifying information.\r\n\r\nThat is the reason for having the payloads field in the JWK for any JWP, it contains the static information relating to that specific payload so that the issuer can only put those values in the same payload slots every time that key is used.\r\n\r\nHow that information is added to the JWK is definitely an area that needs to be developed, what is in the proposal right now using the \"payloads\" field is not scalable and really just an initial starting place.\r\n\r\nFor example, in each of your above snippets the JWK could contain something like this (I'm proposing here \"layout\" to identify the type of payload layout definition used):\r\n```json\r\n{\r\n    \"layout\":\"claims\",\r\n    \"claims\":[\"email\",,,]\r\n}\r\n```\r\n```json\r\n{\r\n    \"layout\":\"n-quads\",\r\n    \"n-quads\":\"_:c14n0 <http://schema.org/email> _:jwp0 .\\r\\n...\"\r\n}\r\n```\r\n```json\r\n{\r\n    \"layout\":\"pointers\",\r\n    \"pointers\":[\"/account/email\",,,]\r\n}\r\n```\r\n```json\r\n{\r\n    \"layout\":\"uris\",\r\n    \"uris\":[\"http://example.com/app_specific_reference\",,,]\r\n}\r\n```\r\n\r\nThe intent here is just to ensure that the application has a single uniform definition of what the payload value in each slot represents.\r\n\r\nAs to reconstruction, I believe that should be up to the application to determine the appropriate usage and the JWP definition should support either modality.  Payload values may be reconstructed into a document (if they're available after selective disclosure) or the application may process each payload in its own individual context (such as when using predicate proofs).",
          "createdAt": "2021-09-01T21:28:41Z",
          "updatedAt": "2021-09-01T21:30:04Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not sure I am reading this correctly, but I think the ideal solution would look something like this:\r\n\r\n```\r\nheader: { alg, kid }\r\npayload: JSON Object (string encoded)\r\nproof: { signature (s) + other proof data related to alg }\r\n```\r\n\r\nthen under `alg`:\r\n\r\nA description of the required members of proof and requirements for payload.\r\n\r\nFor example: `BLS_BBS+JSON_POINTER` or `MERKLE+JWS+JSON_POINTER` \r\n \r\nIn other words.... use `alg` to declare normalization (or any form of \"payload transform\"), and require payload to be an opaque `object`.\r\n\r\nfrom this perspective, a JWT is a JWP, with an implied normalization process of: `base64url(header).base64url(payload)`.\r\n\r\nJWP can then inherit JWS alg's for example: `ES256K`, with the only encoding change being `signature` -> `proof`",
          "createdAt": "2021-09-07T19:26:35Z",
          "updatedAt": "2021-09-07T19:33:30Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there's two things in your comment @OR13, first is your examples are all single-payload, whereas JWP is for natively supporting multiple payloads.\r\n\r\nThere's also an important perspective-change with JWP relating to what I think you're suggesting.  The payloads are intended to be used for single values, not composite structures.  I'm working on a draft update to JWP to help clarify this and we can review it at the next meeting.\r\n\r\nThis is where @dwaite's \"[Mad Libs](https://github.com/json-web-proofs/json-web-proofs/issues/2#issuecomment-913865953)\" analogy applies: a credential document only has the privacy sensitive values stored in the payload slots (such as the expiration timestamp is in slot 2, age value is in slot 5, email is in slot 7, etc).  The JWK that was used to issue/derive/verify for that JWP must contain the \"layout\" for the application to identify what values are in what slots.\r\n\r\nDiscussion and working through any confusion on this is excellent, definitely helping highlight areas to improve, thank you!\r\n",
          "createdAt": "2021-09-08T00:31:37Z",
          "updatedAt": "2021-09-08T00:31:37Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> JWP is for natively supporting multiple payloads.\r\n\r\nThis will cause the verifier to have to understand something of the payloads... at the very least, that each of them is independently valuable.\r\n\r\nAre the payloads really independent?\r\n\r\nwill a verifier need to parse each payload independently?\r\n\r\nconsider a scenario where one payload is encoded with `JCS` but the other is encoded with `JSON.stringify` is this allowed?\r\n\r\nForcing payloads to be assembled into data models at the application layer, will prevent JWP from being capable of representing object data models natively, and will require a per object type translation for each standard object data model....\r\n\r\nFor example:\r\n\r\n- https://w3c.github.io/vc-data-model/#credential-subject\r\n- https://w3c.github.io/webauthn/#clientdatajson-serialization\r\n- https://json-schema.org/understanding-json-schema/about.html\r\n- https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc#fetch-the-openid-connect-metadata-document\r\n\r\nin each case, we start with an object, than transform it to a set of JWP payloads, then transform it back (so it conforms with the normative object definition)... \r\n\r\nIf JWP does not define 1 way of doing this, I expect it will happen many different ways... which will harm interop, but perhaps another spec will define the way to use JWP to objects....\r\n\r\n*moving normalization and aggregation outside of JWP might be strategic....*\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-09-13T18:29:21Z",
          "updatedAt": "2021-09-13T18:30:39Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> moving normalization and aggregation outside of JWP might be strategic....\r\n\r\nAgreed, it clicked for me last week that there can and should be a much clearer separation of concerns.\r\n\r\nThe current JWP draft needs some improvement on this front which I'm working on, reducing it to a simpler core container primitive that can be easily used with external mechanisms.\r\n\r\nI do suspect there may be an eventual need for multiple of those external mechanisms, and they will definitely still require strong privacy considerations in order to preserve the underlying unlinkability.",
          "createdAt": "2021-09-14T22:28:24Z",
          "updatedAt": "2021-09-14T22:28:24Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we do allow for `normalization` and `aggregation` outside of JWP, we can treat the message payloads as 100% opaque JSON, which would be nice... since we don't have to care about how or if they are assembled into objects that conform to existing standards.... but I suspect many folks will still want an answer to the latter, around the same time.\r\n\r\n",
          "createdAt": "2021-09-20T16:01:21Z",
          "updatedAt": "2021-09-20T16:01:21Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm working on a PR to reduce the scope of the JWP draft to just the signing/proving aspects, moving the payload values and any mappings out of scope: https://github.com/json-web-proofs/json-web-proofs/pull/10\r\n\r\nWe unfortunately cannot specify that the payload values are all JSON, it's essential that a proof algorithm has the ability to receive custom or raw values in order to support blinded values and/or numerical operations for range and membership proofs.\r\n\r\nSupporting these does result in a more detailed programmatic API where each payload may have individual options passed into the algorithm, but I believe it's still the simplest abstraction that still supports the larger scope of proof capabilities.\r\n\r\nFor example, a builder pattern of the initial issuance:\r\nPseudocode:\r\n```\r\nsigner = algo.signer(issuer_key, options) // options may include binding details\r\nsigner.setProtected(base64url(protected header))\r\nsigner.addPayload(payload1, options) // options may signal a blinded or numerical value\r\nsigner.addPayload(payload2)\r\nsigner.addPayload(payload3)\r\nsig = signer.sign()\r\n```\r\n",
          "createdAt": "2021-09-20T16:23:07Z",
          "updatedAt": "2021-09-20T16:23:07Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`signer.addPayload(payload1, options) ` \r\n\r\ndoesn't this just get converted to \r\n\r\n`encoded proof : [ ...,  payload1WithAppliedOptions]` \r\n\r\nis JWP a data format or a protocol for constructing data formats?\r\n\r\nalso, might suggest changing the name before its too late.... `Json Web Proof`... implies it's a JSON based cryptographic data format...  You can encode both numbers and binary in JSON, and you can use JWS to sign binary with detached JWS `b64: false` and `crit: ['b64']`... \r\n\r\nSee https://datatracker.ietf.org/doc/html/rfc7797, you would probably want something similar if it's `critical` a verifier understands some message payloads be processed according to `options` in a specific way.\r\n\r\n\r\nIf the output is JSON, thats good enough reason to keep the name as is... and also to define the inputs in ways that are familiar to JSON developers.",
          "createdAt": "2021-09-20T17:07:40Z",
          "updatedAt": "2021-09-20T17:13:10Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> `signer.addPayload(payload1, options) `\r\n> \r\n> doesn't this just get converted to\r\n> \r\n> `encoded proof : [ ..., payload1WithAppliedOptions]`\r\n\r\nCorrect, it just has to be the algorithm that applies the options.\r\n\r\n> is JWP a data format or a protocol for constructing data formats?\r\n\r\nIt's just a data format.  Though it does create expectations for supporting protocols to convey various options.\r\n\r\n> also, might suggest changing the name before its too late.... `Json Web Proof`... implies it's a JSON based cryptographic data format... You can encode both numbers and binary in JSON, and you can use JWS to sign binary with detached JWS `b64: false` and `crit: ['b64']`...\r\n> \r\n> See https://datatracker.ietf.org/doc/html/rfc7797, you would probably want something similar if it's `critical` a verifier understands some message payloads be processed according to `options` in a specific way.\r\n\r\nIt's currently as much JSON as JWS is, and I agree we could use JSON encoding for the numbers/binary.  It'll be one of the topics I expect ongoing discussion on, as using JSON would require the algorithm implementations also parse/decode the JSON so that they can work with the raw values cryptographically.\r\n\r\nMy current preference is that they are always just opaque base64url encoded values as far as JWP is concerned, and any extra signals about their contents or algorithmic handling is out of scope.  That said, my expectation is we would also work on a companion spec that focuses on those details, very similar to the JWS/JWT relationship as suggested by @selfissued in this issue. \r\n",
          "createdAt": "2021-09-20T18:21:02Z",
          "updatedAt": "2021-09-20T18:21:02Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tend to agree that small, well defined building blocks, layered correctly is a much better approach than a monolithic spec that defines everything.\r\n\r\nI don't see a way around parsing... given the potential complexity of header values.\r\n\r\nDoes this refinement of your original example align with your thinking?\r\n\r\n```\r\nsigner = algo.signer(issuer_key, options) // options may include binding details\r\nsigner.setProtected(base64url(JSON.stringify( header ))) // may refer to signing key and blinding details\r\nsigner.addPayload(base64url(JSON.stringify({payload: payload1, options})) // options may signal a blinded or numerical value\r\nsigner.addPayload((base64url(JSON.stringify({payload: payload2))\r\nsigner.addPayload((base64url(JSON.stringify({payload: payload3))\r\nsig = signer.sign()\r\n```",
          "createdAt": "2021-09-21T14:07:25Z",
          "updatedAt": "2021-09-21T14:07:25Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Your refinement is I believe in the right ballpark, it still supports the primary goal in the new PR of minimizing the scope to only what the algorithm requires in order to sign/prove.\r\n\r\nDefinitely something to discuss at today's work item call.",
          "createdAt": "2021-09-21T17:19:36Z",
          "updatedAt": "2021-09-21T17:19:36Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There have now been 2 concrete attempts at JWP, and I think both are roughly consistent.... I am struggling to see how to make this issue actionable... I suggest closing it.",
          "createdAt": "2021-12-04T17:48:09Z",
          "updatedAt": "2021-12-04T17:48:29Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed on closing it, I believe we've achieved clear separation between the core/simpler JWP and the JPT draft that introduces claims syntax.",
          "createdAt": "2021-12-14T19:03:30Z",
          "updatedAt": "2021-12-14T19:03:30Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU5NTA5NTQ4MjM=",
      "title": "Content type syntax for claims in payloads not fully general",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/5",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JPT"
      ],
      "body": "The example content type syntax for claims in payloads does not allow different content type values to apply to different claims in the same payload.  The current example syntax in the spec is:\r\n`   \"payloads\":[\r\n      {\"claims\":[\"family_name\", \"given_name\"]},\r\n      {\"claims\":[\"email\"]},\r\n      {\"claims\":[\"birthdate\"]},\r\n      {\"claims\":[\"age\"], \"cty\":\"hashchain-commitment\"},\r\n      {\"claims\":[\"profile_pic\"], \"cty\":\"image/png\"}\r\n   ]\r\n`\r\nI don't see a way to, for instance have have a `profile_pic_png` claim with content type `image/png` and a `profile_pic_jpg` claim with content type `image/jpeg` in the same payload.",
      "createdAt": "2021-07-22T18:52:06Z",
      "updatedAt": "2021-12-14T19:04:31Z",
      "closedAt": "2021-12-14T19:04:31Z",
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you be looking for something like:\r\n\r\n``` json\r\n[\r\n  { \"claims\": [\"profile_pic\"], \"cty\": \"image/png\" },\r\n  { \"claims\": [\"profile_pic\"], \"cty\": \"image/jpeg\" }\r\n]\r\n```\r\n\r\nor\r\n\r\n``` json\r\n[\r\n  { \"claims\": [\"profile_pic_png\"], \"cty\": \"image/png\" },\r\n  { \"claims\": [\"profile_pic_jpg\"], \"cty\": \"image/jpeg\" }\r\n]\r\n```\r\n",
          "createdAt": "2021-07-22T19:19:39Z",
          "updatedAt": "2021-07-22T19:19:39Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this as it's outdated now w/ the latest draft using a simple flat `claims` array and all payloads being any JSON value.",
          "createdAt": "2021-12-14T19:04:31Z",
          "updatedAt": "2021-12-14T19:04:31Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU5NzMxNTQ3OTY=",
      "title": "COSE definition for proof support",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/7",
      "state": "OPEN",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JWP"
      ],
      "body": "Similar to adapting JWP for JOSE by creating a new top-level type, COSE will also need the same treatment.\r\n\r\nCOSE currently has three major types for Sign, Encrypt, and Mac, each with their own variant for the common use cases of single signer/recipient of Sign1, Encrypt0, and Mac0.\r\n\r\nPlan is to introduce a fourth major type of Proof and Proof1, who's definition is very similar to Sign/Sign1 but instead of a bstr payload it would be:\r\n```cddl\r\nCOSE_Proof1 = [\r\n       Headers,\r\n       payloads : [+ bstr / nil],\r\n       proof : bstr\r\n]\r\n```\r\n",
      "createdAt": "2021-08-18T00:11:59Z",
      "updatedAt": "2024-03-07T08:55:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposing to add to draft, include note that it may become own spect.",
          "createdAt": "2021-09-21T18:24:08Z",
          "updatedAt": "2021-09-21T18:24:08Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suggest we explicitly move COSE out of scope for the time being, and come back to it when with have figured out the JSON  side better.",
          "createdAt": "2021-12-04T17:45:28Z",
          "updatedAt": "2021-12-04T17:45:28Z"
        },
        {
          "author": "cyberphone",
          "authorAssociation": "NONE",
          "body": "In case you find that you need to make considerable modifications to JWT, creating a CBOR package from scratch may be an option: https://test.webpki.org/csf-lab/home\r\nCBOR deterministic serialization eliminates dressing headers, claims, etc. in Base64Url.  In diagnostic notation:\r\n\r\n```code\r\n{\r\n  \"Over 18\": true,\r\n  \"US citizen\": false,\r\n  \"SignatureValue\": {\r\n    1: -8,\r\n    4: {\r\n      1: 1,\r\n      -1: 6,\r\n      -2: h'fe49acf5b92b6e923594f2e83368f680ac924be93cf533aecaf802e37757f8c9'\r\n    },\r\n    6: h'3aa724ea90b0056d79c7e993f6f96ce16643d600e90ebf40b434461ac3aa6db6e6934ba61ed5d6cec51618b36b89c94f523d3851b9c9d7548f42fb582b257c0a'\r\n  }\r\n}\r\n```",
          "createdAt": "2022-07-28T18:41:08Z",
          "updatedAt": "2022-07-28T18:41:08Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Assigning to draft 4. We should create an up-to-date proposal and take it to the COSE WG.",
          "createdAt": "2024-02-12T01:02:00Z",
          "updatedAt": "2024-03-07T08:55:53Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "We are chartered to do the CBOR/COSE/CWT version of JWPs in this working group.  I believe that spreading the work between working groups would only create unnecessary divergence in the representations.",
          "createdAt": "2024-02-12T23:49:12Z",
          "updatedAt": "2024-02-12T23:49:12Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you want SPICE to look at it, we would be happy to help, but I feel it would make alignment more difficult.",
          "createdAt": "2024-02-15T19:08:52Z",
          "updatedAt": "2024-02-15T19:08:52Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU5ODU3MzEwODA=",
      "title": "Proof Value Language",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/8",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer"
      ],
      "labels": [
        "JPA",
        "JWP"
      ],
      "body": "As with JWS's signature value, the format of the proof value is opaque to the application.  The proof algorithm defines the format and any encoding is unique to that algorithm.\r\n\r\nOf note, for proof algorithms that support proofs of knowledge or predicate proofs of the values in individual payload slots, each of those proofs uniquely generated during derivation must also be encoded/stored in the overall proof value.\r\n\r\nThese proof algorithms must also provide a programmable interface to applications such that they can request the generation and validation of a proof for each payload.  These interfaces will be unique to the algorithm and its proofing capabilities and may vary significantly from one algorithm to another depending on the underlying cryptographic primitives.\r\n\r\nSince some proof algorithms will require the predicate statement during derivation, applications must take care to limit or require consent on multiple derivations such that a hostile party cannot simply continue to refine the predicate request in order to gain more knowledge of the hidden value.\r\n\r\nThe format of any predicate requests are inherently algorithm and application/protocol context specific, these formats are out of scope of the JWP specification.",
      "createdAt": "2021-09-01T21:47:33Z",
      "updatedAt": "2023-11-10T15:14:27Z",
      "closedAt": "2023-11-10T15:14:26Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "See discussion thread here: https://github.com/json-web-proofs/json-web-proofs/pull/10#discussion_r716084233 and https://github.com/json-web-proofs/json-web-proofs/pull/10#discussion_r716086161",
          "createdAt": "2021-10-05T19:38:29Z",
          "updatedAt": "2021-10-05T20:03:30Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as this was a todo for initial publication. Currently defining a signature/proof format is out of scope. However, we may provide for commonality when wanting to structure proofs, e.g. an array of binary parts.",
          "createdAt": "2023-11-10T15:14:27Z",
          "updatedAt": "2023-11-10T15:14:27Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU5OTAyNjE4MTc=",
      "title": "Proof Algorithm Interface",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/9",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JPA"
      ],
      "body": "Using this issue to track discussions around the common interface to the proof algorithm for the signing, deriving, and verifying steps.",
      "createdAt": "2021-09-07T19:00:55Z",
      "updatedAt": "2023-11-10T15:15:19Z",
      "closedAt": "2023-11-10T15:15:19Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "See the first pass of this at https://github.com/json-web-proofs/json-web-proofs/blob/main/draft-jmiller-json-proof-algorithms.md\r\n",
          "createdAt": "2021-10-20T23:57:14Z",
          "updatedAt": "2021-10-20T23:57:14Z"
        },
        {
          "author": "brentzundel",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> See the first pass of this at https://github.com/json-web-proofs/json-web-proofs/blob/main/draft-jmiller-json-proof-algorithms.md\r\n\r\nI believe this is the up-to-date link: https://github.com/json-web-proofs/json-web-proofs/blob/main/draft-ietf-jose-json-proof-algorithms.md",
          "createdAt": "2023-07-24T16:38:46Z",
          "updatedAt": "2023-07-24T16:38:46Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as proposed text is in the algorithms document",
          "createdAt": "2023-11-10T15:15:19Z",
          "updatedAt": "2023-11-10T15:15:19Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOFsQObc47x-Eb",
      "title": "Expand terminology section",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/11",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer"
      ],
      "labels": [
        "JWP"
      ],
      "body": "Include the few ZKP terms being introduced.",
      "createdAt": "2021-09-21T17:49:27Z",
      "updatedAt": "2023-11-10T15:23:03Z",
      "closedAt": "2023-11-10T15:23:03Z",
      "comments": [
        {
          "author": "brentzundel",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there a record somewhere of desired additional terms?",
          "createdAt": "2023-07-22T20:14:07Z",
          "updatedAt": "2023-07-22T20:14:07Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for more actionable #89 . If we need more ZKP terminology to e.g. define an algorithm within JPA, we can expand at that time.",
          "createdAt": "2023-11-10T15:23:03Z",
          "updatedAt": "2023-11-10T15:23:03Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOFsQObc48B3YC",
      "title": "Should selective disclosure use 1 or 2 alg types in JPA",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/12",
      "state": "CLOSED",
      "author": "OR13",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "JPA"
      ],
      "body": "Some proof types have 2 representations, a. \"root\" or \"full disclosure\" format... and a \"derived\" or \"selective disclosure format\"...\r\n\r\nBBS+ is an example.\r\n\r\nWhile it is possible to verify both formats, I wonder if there is some developer / user experience benefit to refusing to verify the \"root\" type... \r\n\r\nThis might help discourage sharing every attribute, since no verifier (that cared deeply about user privacy) would accept the root format... this would cause the holder to explicitly derive a subset (potentially not strict) of attributes every time they wanted to present a proof.\r\n\r\nPerhaps such privacy considerations are not appropriate for this layer of debate, but certainly clever registration of algorithms might help user privacy here....\r\n\r\n\r\nFor example:\r\n\r\n`BbsBlsSignature2020` -> registered but prohibited.\r\n`BbsBlsSignatureProof2020` -> registered and required.\r\n\r\n",
      "createdAt": "2021-09-25T15:54:42Z",
      "updatedAt": "2023-11-10T15:08:24Z",
      "closedAt": "2023-11-10T15:08:23Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an excellent privacy consideration, though I would expect it to be in the presentation exchange layer so that it applies unilaterally to both the format and to any selectively disclosable linkable attributes.\r\n\r\nAs per relating to JWPs, the draft needs to have language added such that an algorithm's verification method MUST NOT verify a JWP that has only been signed and not derived/proofed.  That will at least prevent just disclosing the raw issued JWP without having at least run it through the proof generation.",
          "createdAt": "2021-10-05T00:39:03Z",
          "updatedAt": "2021-10-05T00:39:03Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems ready for a PR, we should label issues with \"help wanted\" or \"ready for PR\" and try and get more contributors pushing updates.",
          "createdAt": "2021-12-04T17:44:17Z",
          "updatedAt": "2021-12-04T17:44:17Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is blocked by the use of the `alg` in the header... for example, if the full disclosure header and the selective disclosure header need to be the same... the `alg` needs to be the same.",
          "createdAt": "2022-02-08T19:38:41Z",
          "updatedAt": "2022-02-08T19:38:41Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "The alg value has to be the same during issuance and presentation, it is intended to _only_ represent which cryptographic subsystem is used to operate on the given JWP.\r\n\r\nThere is no indicator in the JWP format itself to signify if it is for issuance or for presentation / selective disclosure.  Only the algorithm itself can make that determination based both on the proof value it is given and which operation is being requested.\r\n\r\nThis enables algorithms to decide how they want to support features like delegation, binding, bearer, etc distinctions.\r\n\r\nIf a use-case requires a hard distinction between issuance/presentation it is easy to implement as a policy by just having a given payload always be non-disclosed during presentation.\r\n\r\nHopefully I understood your statement in the first place :)",
          "createdAt": "2022-02-08T23:15:32Z",
          "updatedAt": "2022-02-08T23:15:32Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@quartzjer yes you got it.\r\n\r\noriginally we had discussed an `alg` for the original \"fully disclosure\" proof and one for the derived \"selective disclosure proof\"...\r\n\r\nThen a verifier can switch on the `alg` and call the right verification code.\r\n\r\nThat won't be possible if the header has to be the same for both.\r\n\r\nThe good news is that we also agreed that transmitting the \"full disclosure proof\" was probably a bad idea from a security perspective.\r\n\r\nBut I think the issue remains, because the holder may want to verify a credential issued to them, before attempting to derive a selective disclosure proof from it.\r\n\r\nIf the principle that the header must be the same for both full and selective proofs is critical, then the header cannot signal the difference in verification algorithm.\r\n\r\nA natural solution would be to put that signature next to or in the proof, since that part is expected to change, but that deviates from the expectations of a JOSE developer.\r\n\r\nWe have the same issue for merkle proofs.\r\n\r\nwhen holding a credential, you need to know which verify algorithm to call, which means you need a unique name for it that is in the credential.\r\n",
          "createdAt": "2022-02-09T14:31:14Z",
          "updatedAt": "2022-02-09T14:31:54Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "The hard reality here is that it's simply not possible to actually secure any type of distinction between the issuance context and the presentation context outside of what the algorithm can do internally.  The holder has no universal means to make verifiable changes that aren't inherent to the algorithm itself.\r\n\r\nSince the header is integrity protected by the signer, any modifications the holder would make outside of that to the JWP serialization are just decorations and formatting.\r\n\r\nEvery instance of a JWP already has a known context by the application based on the protocol or interaction that it was received as part of.  That context is the only one that is relevant for it to choose which verification method to call.  Some algorithms such as a bearer-only single use one may not even be able to disambiguate regardless of the context. Whereas, ALL unlinkable algorithms will only verify correctly given the right context.\r\n\r\nI don't believe having an unsecured context indicator in the serialization alone adds any value, and is even a potential weakness if it can be used to confuse an application.",
          "createdAt": "2022-02-09T21:14:42Z",
          "updatedAt": "2022-02-09T21:14:42Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@quartzjer I agree with everything you said, but the problem remains, you will need to call a different verify algorithm and if you don't have way to choose from the header these are your only options:\r\n\r\n1. get the information from outside the header (prefix on the signature for example)\r\n2. sniff the payload and look for nulls (nulls indicate the need to use the selective disclosure verify algorithm)\r\n3. try both verify algorithms.\r\n\r\n\r\nIs there another option?\r\n\r\nWhich of these options should be recommended?\r\n",
          "createdAt": "2022-02-10T13:31:36Z",
          "updatedAt": "2022-02-10T13:31:36Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "It is the application's responsibility to track the context, if it was received in a signing context, or if it was received in a presentation one.\r\n\r\nAn algorithm may know the difference inherent to the proof (such as if a presentation nonce was used to build the proof), but it isn't required for them to do so.\r\n\r\nSome use-cases may require a security-verifiable distinction and can use selective disclosure as a policy to accomplish that, and some may explicitly *not* want one such as for delegable bearer credentials.\r\n\r\nA JWS without any headers to indicate which key it was signed with is still perfectly valid, it requires the application to make this \"trust decision\" by context.  In the case of JWS you _can_ use a header as part of the trust decision, and in the case of JWP you _can_ use a payload (or lack thereof) as part of the trust decision.\r\n\r\nHeaders with JWP are protected for communicating equally to the holder and verifier.  The only content policy the holder can universally apply to a JWP is selective disclosure.",
          "createdAt": "2022-02-10T16:28:08Z",
          "updatedAt": "2022-02-10T16:28:08Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "NONE",
          "body": "In general I understand the direction of treating the protected header in this manner, however I still dont see how implementers will be able to distinguish between the two possible JWP structures associated to a scheme like BBS (namely a BBS Signature and BBS proof). One orthogonal question I have to this issue,  is how does JWP accomodate any extra information that may be present in a BBS proof that is not in a BBS signature such as the [presentation message](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-spkgen)?",
          "createdAt": "2022-02-11T22:44:48Z",
          "updatedAt": "2022-02-11T22:44:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "NONE",
          "body": "To be clear in the context of a scheme like BBS, the presentation message is somewhat akin to a protected header in the sense that it cannot be tampered with, however the party responsible for its integrity is not the signer of the original signature but instead the prover/holder deriving the proof. Does this mean perhaps JWP should consider two types of protected headers?",
          "createdAt": "2022-02-11T22:46:43Z",
          "updatedAt": "2022-02-11T22:46:43Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "an unprotected header might be a useful feature.\r\n\r\nIf there is no unprotected header, the \"proof\" or \"signature\" should disambiguate the algorithms... there should be no guess or content sniffing... putting a prefix on the proof of signature is just an un protected header with extra steps :)\r\n\r\n\r\n",
          "createdAt": "2022-02-14T14:02:31Z",
          "updatedAt": "2022-02-14T14:02:31Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an excellent thread that has had me really thinking, I'm now thinking along the same lines, that a presented JWP needs an additional header element that is generated by only the holder/prover.\r\n\r\n@tplooker in order to protect this header for BBS, if the verifier provides a nonce (such as part of the presentation protocol), if we create a header like `{\"nonce\":\"abcd....\"}` (along with any other presentation headers) and use that as the input to the createProof(), is that what you'd expect?\r\n\r\nWhile BBS has this capability, not all algorithms may be able to protect this header as easily.  It can't be optionally protected, and adding both a protected and unprotected header doesn't seem ideal at all.\r\n\r\nThis also highlights that there's two types of \"binding\" here: a binding from just the holder to the verifier, and a binding from the issuer to the holder to the verifier.\r\n\r\nA \"bearer\" proof has no binding, any entity that holds it can present it. Useful in some specific use-cases.\r\n\r\nThe holder-verifier only binding is possible with ZKP-based algorithms, where the issued JWP itself is a secret and each presentation is only bound uniquely to the verifier.\r\n\r\nThe issuer-holder-verifier binding is one where the verifier can see that the binding used in the presentation was the same as the one used during issuance.  This is particularly useful when the issuer has a higher assurance in the holding device posture.\r\n\r\nA presentation header can be protected by either type, and I'm not sure if the distinction is important with regard to the header as they both provide integrity and protect from replay.\r\n\r\nSo, yeah, I like the idea of requiring a verification header from the holder.  A \"bearer\" JWP therefore has no presentation form. The verifiable JWP in compact encoding could take the form of `VERIFY_HEADER.ISSUER_HEADER.P1~P2~P3.PROOF`.\r\n\r\nFeedback encouraged :)\r\n",
          "createdAt": "2022-02-16T03:20:39Z",
          "updatedAt": "2022-02-16T03:20:39Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "NONE",
          "body": "> @tplooker in order to protect this header for BBS, if the verifier provides a nonce (such as part of the presentation protocol), if we create a header like {\"nonce\":\"abcd....\"} (along with any other presentation headers) and use that as the input to the createProof(), is that what you'd expect?\r\n\r\nI may be miss understanding and some of the confusion may lie in the implementation that exists today, but recently at the BBS signature working group we have elected to generalise a BBS proof so that instead of it taking just a nonce when you are creating or verifying a proof, it takes a presentation message, which in its self could be a data structure that contains a nonce. So I think to answer your question around how a BBS proof would map conceptually to this proposal the `VERIFY_HEADER` would just be the presentation message?",
          "createdAt": "2022-02-16T03:41:08Z",
          "updatedAt": "2022-02-16T03:41:08Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "NONE",
          "body": "Also as feedback on the approach I think in general having a new header is worth exploring more.",
          "createdAt": "2022-02-16T03:43:34Z",
          "updatedAt": "2022-02-16T03:43:34Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Can someone provide a concise description of what the two different headers would be for and would contain (and would not contain)?",
          "createdAt": "2022-02-16T04:04:27Z",
          "updatedAt": "2022-02-16T04:04:27Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> So I think to answer your question around how a BBS proof would map conceptually to this proposal the VERIFY_HEADER would just be the presentation message?\r\n\r\nYep, that's exactly what I'm thinking, thanks for the confirmation :+1: ",
          "createdAt": "2022-02-16T04:13:54Z",
          "updatedAt": "2022-02-16T04:13:54Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can someone provide a concise description of what the two different headers would be for and would contain (and would not contain)?\r\n\r\nThe names I'm using for each are just for explanation here, I've not thought much about what to actually call/name them.\r\n\r\nThe ISSUER_HEADER is protected by the Issuer and contains values set only by the Issuer, including `iss`, `alg`, etc. The \"normal\" stuff.\r\n\r\nThe VERIFY_HEADER is protected by the Holder and contains values regarding the specific presentation to a Verifier, including at least `nonce` and possibly other presentation exchange values.  The VERIFY_HEADER can only be added by an algorithm that supports generating a unique non-replay-able presentation.\r\n\r\nA JWP with no VERIFY_HEADER is only a statement by the Issuer.  They may be useful for bearer-only use-cases.",
          "createdAt": "2022-02-16T04:30:11Z",
          "updatedAt": "2022-02-16T04:30:11Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In VC Data Model terms, we would expect this \"VERIFY_HEADER\" to cover `domain` and `challenge` which map to `aud` and `nonce`.",
          "createdAt": "2022-02-22T19:45:16Z",
          "updatedAt": "2022-02-22T19:46:45Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this out since we haven't touched it in a while. The present draft (-02) uses a two headers on presentation, and we allow the presented form to use a different algorithm identifier.",
          "createdAt": "2023-11-10T15:08:24Z",
          "updatedAt": "2023-11-10T15:08:24Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOFsQObc48mHvc",
      "title": "Naming Things",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/13",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Using this issue to resolve outstanding naming discussions:\r\n- [ ] derive proof vs. generate proof\r\n- [ ] signing vs. generate proof\r\n- [ ] JSDT (JSON Selective Disclosure Token) vs ??? for companion spec to JWP",
      "createdAt": "2021-10-05T17:59:46Z",
      "updatedAt": "2021-11-09T22:46:58Z",
      "closedAt": "2021-11-09T22:46:58Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "My dilemma w/ \"JSDT\" is that it doesn't encompass the unlinkability aspect, which IMO is equally important as a principal foundation for a companion spec.  Selective disclosure is also just one aspect of the data minimization approach.\r\n\r\nPerhaps \"Minimization\" is the root of both aspects? Maybe JMP/JMT or JMDP/JMDT for Minimized or Minimal Disclosure? My inner nerd likes JMP/JMT because it's just the W flipped :) ",
          "createdAt": "2021-10-05T19:31:32Z",
          "updatedAt": "2021-10-05T19:31:32Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "See discussion thread here: https://github.com/json-web-proofs/json-web-proofs/pull/10#discussion_r716082098 and https://github.com/json-web-proofs/json-web-proofs/pull/10#discussion_r716083442",
          "createdAt": "2021-10-05T19:39:43Z",
          "updatedAt": "2021-10-05T20:01:28Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I started going with the following abbreviation pattern:\r\n* **JWP**: JSON Web Proofs (core container definition)\r\n* **JPA**: JSON Proof Algorithms (requirements for and definitions of proof algorithms)\r\n* **JPT**: JSON Proof Tokens  (a near-analogue of JWT, a specific application of JWPs)\r\n\r\nThe analogs also hold true for the CBOR versions of all three, **CWP**, **CPA**, and **CPT**.  ",
          "createdAt": "2021-10-20T23:55:26Z",
          "updatedAt": "2021-10-20T23:55:26Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "There's been no objections to the introduction of these this past month so I'm going to close this issue, we can re-open it should any arise.",
          "createdAt": "2021-11-09T22:46:58Z",
          "updatedAt": "2021-11-09T22:46:58Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOFsQObc49TK7V",
      "title": "Add a Proof Type for Merkle Proof Selective Disclosure to JPA",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/15",
      "state": "OPEN",
      "author": "OR13",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I took a stab at a \u201cJWP\u201d encoding of merkle disclosure proofs in a token format\u2026.\r\n\r\nhttps://or13.github.io/jwp-mdt/#name-root-proof\r\n\r\nThe main thing I noticed was some awkwardness regarding nesting JWS inside the protected header.\r\n\r\nit feels like JWP \u201cProtected Header\u201d should reserve a member \u201csignature\u201d and its value should not contain concatenated \u201cheader\u201d or \u201cpayload\u201d attributes\u2026\r\n\r\n```\r\n \"protected\": {\r\n\r\n    \"kid\": \"did:example:123#key-0\"\r\n\r\n    \"root\": \"SflKxwRJSM...\",\r\n    \"alg\": \"MDP+ES256+JP\", // merkle disclosure with json pointer\r\n    \"zip\": \"DEF\"\r\n\r\n    \"signature\": \"SflKxwRJSM\", // over the entire protected header, like a detached jws, but only the signature part.\r\n  },\r\n\r\n```\r\n\r\nOtherwise if we reserved a member \u201cjws\u201d we would have an encoded JWS header, nested insider an encoded JWP header, each with potentially different alg  zip kid, etc\u2026\r\n\r\n```\r\n \"protected\": {\r\n\r\n    \"kid\": \"did:example:123#key-0\"\r\n\r\n    \"root\": \"SflKxwRJSM...\",\r\n    \"alg\": \"MDP+ES256+JP\", // merkle disclosure with json pointer\r\n    \"zip\": \"DEF\"\r\n\r\n    \"jws\": \"{alg, kid, zip}..SflKxwRJSM\", // over the entire protected header, but confusing imo...\r\n  },\r\n\r\n```\r\n\r\nFor merkle proofs a signature over the root must be disclosed, so we need a \"signature\" in the \"protected header\".\r\n\r\n",
      "createdAt": "2021-10-17T20:58:06Z",
      "updatedAt": "2022-02-08T19:37:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another option might be to put the \"signature for the merkle root\"... on the end of the \"proof\" object...\r\n\r\nSo instead of this:\r\n\r\n#### Option 1\r\n\r\n```\r\n{\r\n\r\n  // From JWP \"Protected Header\"\r\n  // always disclosed\r\n  \"protected\": {\r\n\r\n    \"kid\": \"did:example:123#key-0\"\r\n\r\n    \"root\": \"SflKxwRJSM...\",\r\n    \"alg\": \"MDP+ES256+JP\", // merkle disclosure with json pointer\r\n    \"zip\": \"DEF\"\r\n\r\n    \"signature\": \"SflKxwRJSM\", // over the entire protected header.\r\n  },\r\n\r\n  // From JWP \"Payloads\" and \"Proof\"\r\n  // selectively disclosed\r\n  \"payloads\": [ { message }, ...]\r\n  \"proof\": [ { path, nonce }, ... ],\r\n}\r\n```\r\n\r\nWe would have this:\r\n\r\n\r\n#### Option 2\r\n\r\n```\r\n{\r\n\r\n  // From JWP \"Protected Header\"\r\n  // always disclosed\r\n  \"protected\": {\r\n\r\n    \"kid\": \"did:example:123#key-0\"\r\n\r\n    \"root\": \"SflKxwRJSM...\",\r\n    \"alg\": \"MDP+ES256+JP\", // merkle disclosure with json pointer\r\n    \"zip\": \"DEF\"\r\n  },\r\n\r\n  // From JWP \"Payloads\" and \"Proof\"\r\n  // selectively disclosed\r\n  \"payloads\": [ { message }, ...]\r\n\r\n  // first part selectively disclosed, second part required.\r\n  \"proof\": [ { path, nonce}, ... ] + \"SflKxwRJSM\", // signature over the entire protected header.\r\n}\r\n```\r\n\r\nDownside of this would be constantly splitting the signature from the proofs when deriving.... if thats acceptable, we could also do:\r\n\r\n#### Option 3\r\n\r\n```\r\n{\r\n\r\n  // From JWP \"Protected Header\"\r\n  // always disclosed\r\n  \"protected\": {\r\n    \"kid\": \"did:example:123#key-0\",\r\n    \"alg\": \"MDP+ES256+JP\",\r\n    \"zip\": \"DEF\"\r\n  },\r\n\r\n  // From JWP \"Payloads\" and \"Proof\"\r\n\r\n  // selectively disclosed\r\n  \"payloads\": [ { message }, ...]\r\n\r\n  // first part selectively disclosed, second part required.\r\n  \"proof\": [ { path, nonce}, ... ] \" + root + \"SflKxwRJSM\", // signature over the entire protected header.\r\n}\r\n```\r\n",
          "createdAt": "2021-10-17T21:08:33Z",
          "updatedAt": "2021-10-17T21:10:58Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I prefer Option 1",
          "createdAt": "2021-10-17T21:09:56Z",
          "updatedAt": "2021-10-17T21:09:56Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "While it's not as ideal from a parsing perspective, Option 3 is I believe the correct abstraction.\r\n\r\nThe challenge is really in the interface to the JWA, the implementing algorithm isn't expected to know or parse the actual protected header, it is encoded before even reaching it (see [JWS 5.1](https://datatracker.ietf.org/doc/html/rfc7515#section-5.1)).\r\n\r\nThe only part that the algorithm has full control over is the one that it generates, the signature/proof, and this value is opaque to the application layer and preserved as an encoded byte array to be passed back in for validation un-altered.\r\n\r\nThe merkle algorithm will need to encode everything it requires both to generate a disclosure and to validate the disclosed into the singular proof value.  I think it's completely legit for that to still be a JSON object, but to the higher JWP layer it will be an opaque base64url encoded octet string.\r\n\r\nMy pseudocode version of your Option 3 would look like:\r\n```javascript\r\nmerkle_proof = {\r\n  \"proofs\":[ { path, nonce}, ...]\r\n  \"root\":\"SflKxwRJSM...\",\r\n  \"signature\":\"ZflKxwRJSM...\"\r\n}\r\n\r\nproof_b64 = base64url(JSON.stringify(merkle_proof))\r\n\r\nmessage1_b64 = base64url(JSON.stringify({message}))\r\n\r\nheader = {\r\n  \"kid\": \"did:example:123#key-0\",\r\n  \"alg\": \"MDP+ES256+JP\",\r\n  \"zip\": \"DEF\"\r\n}\r\n\r\nheader_b64 = base64url(JSON.stringify(merkle_proof))\r\n\r\njwp_json = {\r\n  \"protected\": header_b64,\r\n  \"payloads\": [ message1_b64, ...]\r\n  \"proof\": proof_b64\r\n}\r\n\r\njwp_compact = header_b64 + \".\" + jwp_json.payloads.join(\"~\") + \".\" + proof_b64\r\n```",
          "createdAt": "2021-10-20T23:49:38Z",
          "updatedAt": "2021-10-20T23:49:38Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@quartzjer thanks, this makes a lot of sense, I will try and revise my proposal to align with it better.",
          "createdAt": "2021-10-21T18:06:41Z",
          "updatedAt": "2021-10-21T18:06:41Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@quartzjer I finally got some time to hack this out...\r\n\r\nhttps://github.com/OR13/jwp-mdt/tree/main/ref-impl#json-web-proof-for-merkle-proof-based-selective-disclosure\r\n\r\nI opted not to provide an `lyt` transform for the payloads, since I still don't fully understand how to do that... therefore these proofs can only be used on arrays, not objects.\r\n\r\nI like that it works with regular boring JWKs and JWS. \r\n(especially given the limited support in HSM for bls12381 or ed22519)....\r\n\r\nI don't love the constant base64url encoding and decoding... or the current header configurations.\r\n\r\nI also don't love that I had to invent a compact encoding for merkle proofs in JSON... \r\nwould really love to have just used another spec for that.\r\n\r\nI think a reasonable next step would be to generalize from arrays of payloads to objects, and start attempting to use `lyt`...\r\n\r\nMy naive plan for that is something like this:\r\n\r\n```\r\nconst credential = { context, type, issuer, issuanceDate, credentialSubject } \r\n// no proof since we will be used external proof per the spec\r\n\r\nconst lyt = generateLayoutFromVc(credential);\r\nconst payloads = getPayloadsFromLyt(credential, lyt);\r\n// ... then the rest is the same as it is now ... except `lyt` is embedded in the JWP header.\r\n\r\n// On the verify side, we need an option to \r\n// transform the verified result back to an object... only after verifying...\r\n// this is identical to the JWT behavior, you don't get a verification boolean, \r\n// you get back an object\r\n\r\nconst credential = getVcFromJwp(jwp);\r\n// This function needs to use layout with the jwp to construct the vc with disclosed terms.\r\n```\r\n\r\nHere is an example of JWP that only supports array types...\r\n\r\n```json\r\n{\r\n  \"protected\": {\r\n    \"kid\": \"did:example:123#key-0\",\r\n    \"alg\": \"MDP+EdDSA\",\r\n    \"zip\": \"DEF\"\r\n  },\r\n  \"payloads\": [\"YQ\", \"Yg\", \"Yw\"],\r\n  \"proof\": \"eyJyb290IjoiYzllYjU1YWU4OTk0M2Q0MDRmY2U2MzI3MTM4MTAxYzgwYjIyYzcxYmIzYTY2NmFkZTBiYWY5YTRiZmIzN2JjNiIsIm5vbmNlIjoidXJuOnV1aWQ6ZTJjYWRlMDQtMjg5Ny00YTUwLTk4NDItY2QyZGQ5ZGVhZTEwIiwicHJvb2ZzIjoiZUp5VnpOc1NRa0FBQU5CLzhhcVpWY3VXUitSU2E1bHFpRzE2MEtJaHViUlc2dXY3aHM0SG5JdGtSR1VEcmZaTVN3cEgwbmFkb3BwNTdDSVdlRUh5R2dvODFUalYyWWFNV0JoRjVhSVBxaWZ0cUowMk9lcWhTOEptV0hKTWsva2didThQMFRQZVFmWlVIR2toR1k0UWRtbHoyTis5VVhqeWlFQmY3Unl3cFpWaHpvU3pDQUtWTC8xY2U0Qi9hNnZPdUZ4UXdOOWl6VHI5UlRQUDlhTVkweUJZN1htVWhtMWMyZGJjRHVJclhYOGQra3ZpIiwic2lnbmF0dXJlIjoiQlVVWHZ5VE9LS0hiSHBYUTMydlc5bFJzRVB2WEZsVkF5a3l2YTFIV0pLVUdMTExyV3NwMDN4aVdNWVdOclhweUJRYUhyZHdkWk5CcEp6a0dXSlowQ1EifQ\"\r\n}\r\n\r\n```\r\n\r\nin the future it would have:\r\n\r\n```json\r\n{\r\n  \"protected\": {\r\n    \"kid\": \"did:example:123#key-0\",\r\n    \"alg\": \"MDP+EdDSA\",\r\n    \"zip\": \"DEF\",\r\n    \"lyt\": { ... } // and this can be used to return a verified object instead of verified arrays.\r\n  },\r\n  \"payloads\": [\"YQ\", \"Yg\", \"Yw\"],\r\n  \"proof\": \"eyJyb290IjoiYzllYjU1YWU4OTk0M2Q0MDRmY2U2MzI3MTM4MTAxYzgwYjIyYzcxYmIzYTY2NmFkZTBiYWY5YTRiZmIzN2JjNiIsIm5vbmNlIjoidXJuOnV1aWQ6ZTJjYWRlMDQtMjg5Ny00YTUwLTk4NDItY2QyZGQ5ZGVhZTEwIiwicHJvb2ZzIjoiZUp5VnpOc1NRa0FBQU5CLzhhcVpWY3VXUitSU2E1bHFpRzE2MEtJaHViUlc2dXY3aHM0SG5JdGtSR1VEcmZaTVN3cEgwbmFkb3BwNTdDSVdlRUh5R2dvODFUalYyWWFNV0JoRjVhSVBxaWZ0cUowMk9lcWhTOEptV0hKTWsva2didThQMFRQZVFmWlVIR2toR1k0UWRtbHoyTis5VVhqeWlFQmY3Unl3cFpWaHpvU3pDQUtWTC8xY2U0Qi9hNnZPdUZ4UXdOOWl6VHI5UlRQUDlhTVkweUJZN1htVWhtMWMyZGJjRHVJclhYOGQra3ZpIiwic2lnbmF0dXJlIjoiQlVVWHZ5VE9LS0hiSHBYUTMydlc5bFJzRVB2WEZsVkF5a3l2YTFIV0pLVUdMTExyV3NwMDN4aVdNWVdOclhweUJRYUhyZHdkWk5CcEp6a0dXSlowQ1EifQ\"\r\n}\r\n\r\n```\r\n",
          "createdAt": "2021-12-04T16:59:46Z",
          "updatedAt": "2021-12-04T17:06:38Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "There'll be some updates in other issues/threads here about the layout and claims mapping which would make your next step drastically simpler.\r\n\r\n> I also don't love that I had to invent a compact encoding for merkle proofs in JSON\r\n\r\nYeah, I can definitely see that.\r\n\r\nWhile I know your initial tooling here is JS/TS, if defining an algorithm I would actually lean towards doing it like all other crypto algorithms do in their signature/proof value: packed binary values.  The reason it's predominate is it minimizes the attack surface on the format (there is no format to attack) and removes all external dependencies from the essential validation logic.\r\n\r\nThe proof value here could be the binary octets of `root`+`signature`+`0x1`+`path`+`nonce`+`0x3`+`path`+`nonce`... since each of those values is a known fixed size (the `0x1` etc bytes indicate which index the proof is for).\r\n\r\n\r\n",
          "createdAt": "2021-12-10T00:57:04Z",
          "updatedAt": "2021-12-10T00:57:04Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@quartzjer yep, we are already partially doing that here... https://github.com/OR13/jwp-mdt/blob/main/ref-impl/merkle.js#L41\r\n\r\nI am familiar with TLV from NFC space, I could easily implement that approach... this is a very good suggestion.",
          "createdAt": "2021-12-10T15:56:37Z",
          "updatedAt": "2021-12-10T15:56:37Z"
        },
        {
          "author": "mprorock",
          "authorAssociation": "NONE",
          "body": "> The proof value here could be the binary octets of `root`+`signature`+`0x1`+`path`+`nonce`+`0x3`+`path`+`nonce`... since each of those values is a known fixed size (the `0x1` etc bytes indicate which index the proof is for).\r\n\r\nbig fan of those kind of well defined data packs - they work well with go and c structs, and are generally very portable and rapid to process",
          "createdAt": "2021-12-10T17:45:06Z",
          "updatedAt": "2021-12-10T17:45:06Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking about this a bit more, you wouldn't want to do  this... mostly because `path` values have a lot of redundant nodes... which are currently eliminated by compression.\r\n\r\nWe can still get a more compact proof value though, just like this:\r\n\r\n```\r\nroot + nonce + signature + compressed_proofs\r\n```",
          "createdAt": "2021-12-18T16:11:33Z",
          "updatedAt": "2021-12-18T16:11:33Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```js\r\nconst base64url = require(\"base64url\");\r\nconst { expandProofs } = require(\"./merkle\");\r\nconst expandedDerivedJwp = {\r\n  protected: { kid: \"did:example:123#key-0\", alg: \"MDP+EdDSA\", zip: \"DEF\" },\r\n  payloads: [\"Yg\"],\r\n  proof:\r\n    \"eyJyb290IjoiYzllYjU1YWU4OTk0M2Q0MDRmY2U2MzI3MTM4MTAxYzgwYjIyYzcxYmIzYTY2NmFkZTBiYWY5YTRiZmIzN2JjNiIsIm5vbmNlIjoidXJuOnV1aWQ6ZTJjYWRlMDQtMjg5Ny00YTUwLTk4NDItY2QyZGQ5ZGVhZTEwIiwicHJvb2ZzIjoiZUp4RnpMc09nakFVQU5CLzZhb0pscllYNm9aUjFDZytZMkkwRHREYkdud1ZMU2pFK08rNnVaM3A3TjhFYzZjdTFtbWMyWnZTcEV1a0ZpcWpQZ011NFNjWmNDcU5DVU9sZzVScFJnVmtraG5BanRJK3BnWWs4c3lFRW8yZlVrNHBrdmIvWER5c05iOHppcXRxWUFhT0ZjZFJXWTFhSlhoRlBvNjkvaTZQZW5YaTFJWjUzTkVwaXJNWDZYd0lEWnllWWlYV0lVTEJoc244Y3FkdXN0dld5eXA3TllsTW5XWHEyb25KNS9BRk45Zzl3Zz09Iiwic2lnbmF0dXJlIjoiQlVVWHZ5VE9LS0hiSHBYUTMydlc5bFJzRVB2WEZsVkF5a3l2YTFIV0pLVUdMTExyV3NwMDN4aVdNWVdOclhweUJRYUhyZHdkWk5CcEp6a0dXSlowQ1EifQ\",\r\n};\r\n\r\nconst tags = {\r\n  root: \"00\",\r\n  nonce: \"01\",\r\n  signature: \"02\",\r\n  proofs: \"03\",\r\n};\r\n\r\nconst alternateProofEncoding = (jwp) => {\r\n  const decodedProof = JSON.parse(base64url.decode(jwp.proof));\r\n  const root = Buffer.from(decodedProof.root, \"hex\");\r\n  const nonce = Buffer.from(decodedProof.nonce);\r\n  const signature = Buffer.from(decodedProof.signature, \"base64\");\r\n  const proofs = Buffer.from(decodedProof.proofs, \"base64\");\r\n  const buff = Buffer.concat([\r\n    Buffer.concat([\r\n      Buffer.from(tags.root, \"hex\"),\r\n      Buffer.from(root.length.toString(16), \"hex\"),\r\n      root,\r\n    ]),\r\n    Buffer.concat([\r\n      Buffer.from(tags.nonce, \"hex\"),\r\n      Buffer.from(nonce.length.toString(16), \"hex\"),\r\n      nonce,\r\n    ]),\r\n    Buffer.concat([\r\n      Buffer.from(tags.signature, \"hex\"),\r\n      Buffer.from(signature.length.toString(16), \"hex\"),\r\n      signature,\r\n    ]),\r\n    Buffer.concat([\r\n      Buffer.from(tags.proofs, \"hex\"),\r\n      Buffer.from(proofs.length.toString(16), \"hex\"),\r\n      proofs,\r\n    ]),\r\n  ]);\r\n  return {\r\n    ...jwp,\r\n    proof: base64url.encode(buff),\r\n  };\r\n};\r\n\r\nit(\"encode as TLV\", () => {\r\n  console.log(expandedDerivedJwp.proof.length); // 646\r\n  const jwp2 = alternateProofEncoding(expandedDerivedJwp);\r\n  console.log(jwp2.proof.length); // 436\r\n});\r\n```",
          "createdAt": "2021-12-18T16:31:20Z",
          "updatedAt": "2021-12-18T16:31:20Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOFsQObc4-iIVO",
      "title": "There's a distinction between knowing how to disclose a claim as a mechanical process and full understanding the semantics of a claim",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/17",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [
        "JPT",
        "PR-ready"
      ],
      "body": "Per the discussion on the 2-Nov-21 DIF JWP call, we need clearer language than \"understood\".  \r\n\r\n_Originally posted by @selfissued in https://github.com/json-web-proofs/json-web-proofs/pull/16#discussion_r741375561_",
      "createdAt": "2021-11-09T21:22:49Z",
      "updatedAt": "2024-02-27T23:18:08Z",
      "closedAt": "2024-02-27T23:18:08Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "We will definitely need exacting language here.\r\n\r\nWhile there is expected to be an informed consent process with the (or _a_) subject for the contained claims, we can probably agree that it's not feasible to try and make that a requirement here.  (I'd still like to have some non-normative text or `SHOULD`s along these lines though if we can work it in)\r\n\r\nThe *bare* mechanical process of which claims are disclosed is essentially built in by just choosing which payloads to include whether its known which claim they are for or not, this is essentially just a basic JWP though.  The mapping for which claim is which payload is defined in the layout.  My position is that all payloads MUST have an associated claim mapping in that layout.  There should NOT be any payloads included in a JPT that aren't accessible as a claim.\r\n\r\nThe second mechanical process would be simply the association from a claim name in the layout to the given payload for its value.  I think the crux of this issue is here, is there use-cases where the application may not semantically understand the claim name but would still want to disclose it?\r\n\r\nMy instinct is that that situation doesn't make sense, that without knowing what the claim is, what reason would there be to include it?  My logic is circular though: if the application has a requirement to include the claim, that _is_ a semantic understanding of it.\r\n\r\nI can imagine one intermediate case where a claim is some unknown descendent key/value of a known parent structure.  There's only a limited semantic understanding here - it's \"a property of a known structure\" but is still unknown itself.  Perhaps the issuer is maximizing flexibility by allowing lots of detailed disclosure, but the disclosing application is very simple and only supports a high level.  The disclosing application still knows those properties are descendants of known understood ones, so I would suggest that qualifies as a semantic understanding requirement.\r\n\r\nIs there other use-cases? Or perhaps I'm just extolling my understanding of the word \"semantics\" in this context :)\r\n",
          "createdAt": "2021-11-09T22:01:28Z",
          "updatedAt": "2021-11-09T22:01:28Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> My position is that all payloads MUST have an associated claim mapping in that layout. There should NOT be any payloads included in a JPT that aren't accessible as a claim.\r\n\r\nyes, this is a good idea.\r\n\r\n> I think the crux of this issue is here, is there use-cases where the application may not semantically understand the claim name but would still want to disclose it?\r\n\r\nYes, that is a thing... consider getting some json, and passing it along without alteration... you might only understand half the claims in it... you don't remove claims you don't understand.\r\n\r\n> if the application has a requirement to include the claim, that is a semantic understanding of it.\r\n\r\nYes, this gets to the intention of the issuer... if they signed it... don't mess with it.\r\n\r\nAt a minimum, `lyt` introduces an extra burden on the issuer... they can't just \"sign json\" that have to define a layout for it.\r\n\r\nThis burden can be reduced with reasonable defaults.\r\n\r\n1. There exists a default layout that can be deterministically generated from any JSON. (its a function of key value transforms, aka json pointer dictionaries). \r\n2. The intention of the issuer supersedes the intention of the holder w.r.t. semantics.\r\n\r\nThe issuer is defining the language, in order to use their proofs, everyone has to agree they are the boss.\r\n\r\nThis means if the issuer wants to be pedantic, they will force other folks to comprehend that stuff... don't fight the issuer on this, its their choice to express claims however they like.\r\n\r\nInstead of trying to design around the natural tendency to over engineer semantics, just let the market find the right solution.\r\n\r\nI think there should be an implied semantics that is built into the specification for layout, that aligns with existing understandings of \"private claims\"... https://datatracker.ietf.org/doc/html/rfc7519#section-4.3\r\n\r\nAn issuer does not need to \"register a lyt\" to use private claims... they are registering it by signing with it.\r\n\r\nIf the `lyt` does not provide enough information for the claims to be \"understood\" there are better solutions to that, and `lyt` should not attempt to invent semantic language features that can be found in existing languages...\r\n\r\nI am generally nervous about `lyt` doing any \"creative inventing\"... it should be limited to only the structure needed to convert between a proof structure and a json representation... how that json is \"understood\" should be out of scope... but clearly how to use the layout MUST be understood and should be \"in scope\".",
          "createdAt": "2021-12-04T17:40:14Z",
          "updatedAt": "2021-12-04T17:40:46Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the more complex `lyt` has been replaced by the simple flat `claims` array, I believe the semantics are much much easier for applications to understand here.\r\n\r\nWhile the value of a given claim might be a rich JSON object payload, the application only has to understand the unique name of that claim enough to either provide consent/disclosure choices or minimally just provide transparency about what is included.\r\n\r\nI'm still a fan of there being a SHOULD recognize all of the claim names, but leaving it open for use-cases where unknown issuer claims need to be passed through.",
          "createdAt": "2021-12-14T19:13:51Z",
          "updatedAt": "2021-12-14T19:13:51Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOFsQObc4-iQBj",
      "title": "You might want to encode `lyt` by reference instead of by value.",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/18",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JPT"
      ],
      "body": "Consider a commitment to salted hash (lyt)... etc... it might be that there are really large potential space savings for large \"payload types\"... when you don't need to keep repeating the payload structure in the header or the key... btw this is what linked data contexts are supposed to help you do... maybe they didn't solve the problem the best way... but imo its still worth considering the concept of an `lyt` registry... since someone will create that, regardless of what we want.\r\n\r\n_Originally posted by @OR13 in https://github.com/json-web-proofs/json-web-proofs/pull/16#discussion_r741400199_",
      "createdAt": "2021-11-09T22:05:36Z",
      "updatedAt": "2023-11-10T15:45:30Z",
      "closedAt": "2023-11-10T15:45:30Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I completely understand your comments here, I'm not in love with the coupled jwk-lyt approach either so hopefully we can find a happier path without adding too much complexity.  Consider it a starting point :)\r\n\r\nHere are the challenges related to this that I've been considering:\r\n* A JWP cannot be validated without the public key data, and similarly a JPT cannot be validated without the layout data\r\n* If the public key is not known by application context, the standard mechanism to resolve it is via the [`kid`](https://datatracker.ietf.org/doc/html/rfc7515#section-4.1.4) in the protected header that can be used to match the `kid` in a JWK\r\n* JWTs add the [`iss`](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.1) property to also define the specific issuer context\r\n* These \"resolution\" processes are typically defined by higher level protocols such as OpenID Connect and remain very open ended in the JOSE specs\r\n* If we add another parallel method such as `lid` that could create adoption challenges forcing other protocols to extend their resolution processes\r\n* It could also possibly double the number of round-trips for a verification requirement in some scenarios\r\n* Some JWP algorithms require public parameters for each payload slot, which also results in per-credential-type JWKs\r\n* If the wrong public key is resolved the validation fails, if the wrong layout is resolved is there new/unknown attack vectors?\r\n* JWKs are already specified to support multiple instances for the same public key data, each with additional context such as [`use`](https://datatracker.ietf.org/doc/html/rfc7517#section-4.2) defined, even if not used widely the intent is still inherently designed in\r\n* We don't have to require that the layout MUST be embedded in the JWK, only that such a method is available and well defined\r\n\r\n",
          "createdAt": "2021-11-09T22:45:13Z",
          "updatedAt": "2021-11-09T22:45:13Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see any problem embedding `lyt` in the protected header, either by value or be reference... A verifier is still going to be required to \"have the verification key\" and respect the protected headers... as they are required to do so today for `alg` and `crit`.\r\n\r\nThe biggest issue I have with embedding `lyt` in the JWK is the impact it has on key managment and provisioning... IMO, there should be no impact to key management or provisioning imposed by adopting JWP, instead it should \"just work\" for any public key jwk that even when the protected header does not refer to a specific `kid`.\r\n\r\nin a typical jose verify function we have:\r\n\r\n```\r\npayload = await verify(message and signature, publicKey);\r\n```\r\n\r\n`kid` is optional.\r\n\r\nI would propose JWP follow the same format initially:\r\n\r\n```\r\n[ ... payloads] = await verify(message and proof, publicKey);\r\n```\r\n\r\n`kid` is optional.\r\n\r\nIf we want to support `lyt` by value (maybe using content addressable identifiers)...\r\n\r\n```\r\n[ ... payloads] = await verify(message and proof, publicKey, documentLoader );\r\n```\r\n\r\nwhere:\r\n\r\n```\r\ndocumentLoader = (iri:string) => Promise<{ document: json }>\r\n```\r\n\r\nIf you want to mandate that `kid` be required, and deference to publicKeyJwk... you can shorten that to:\r\n\r\n```\r\n[ ... payloads] = await verify(message and proof, documentLoader );\r\n```\r\n\r\n^ this is what linked data folks will expect, if `lyt` can be embedded by reference instead of by value, and `kid` is a DID URL.\r\n\r\nBut clearly it can be written as this:\r\n\r\n```\r\npublicKey = documentLoader(kid);\r\nlyt = documentLoader(lid)\r\npublicKey = {\r\n... publicKey,\r\nlyt\r\n}\r\n[ ... payloads] = await verify(message and proof, publicKey );\r\n```\r\n\r\nAll of these solutions seem worse to me than putting `lyt` in the header, handling getting a public key jwk outside of the scope of the spec, and doing a normal verify:\r\n\r\n```\r\n[ ... payloads] = await verify(messages and proof, publicKey);\r\n```\r\n\r\n\r\n\r\n",
          "createdAt": "2021-11-17T00:07:04Z",
          "updatedAt": "2021-11-17T00:07:04Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft has switched to a simpler flat `claims` array instead of a layout.  It also adds a `cid` with a specific digest value such that externally defined claims can be verified as the same ones the issuer used.\r\n\r\nThis issue is still relevant for supporting the claims array by reference, currently it is left to the application to resolve the claims similar to how it would perform key resolution using only the `kid` value.  I believe this is sufficient, as external protocols can define a more complex resolution mechanism (like how `iss` is used in OpenID Connect to resolve the `kid` against the well known jwks).",
          "createdAt": "2021-12-14T18:57:54Z",
          "updatedAt": "2021-12-14T18:57:54Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing due to inactivity and the statement that the current mechanism is likely sufficient",
          "createdAt": "2023-11-10T15:45:30Z",
          "updatedAt": "2023-11-10T15:45:30Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOFsQObc4-mpxK",
      "title": "Define how JOSE registered header parameters apply to a JWP",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/19",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite",
        "selfissued"
      ],
      "labels": [
        "JWP"
      ],
      "body": "For example, all of the ones defined in [JWS](https://datatracker.ietf.org/doc/html/rfc7515) apply the same, except `cty` should be documented as not recommended.",
      "createdAt": "2021-11-10T21:20:36Z",
      "updatedAt": "2024-02-17T22:27:51Z",
      "closedAt": "2024-02-17T22:27:51Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that we need to do this analysis.",
          "createdAt": "2021-11-11T19:55:09Z",
          "updatedAt": "2021-11-11T19:55:09Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Has this been completed by the recent IANA section work?",
          "createdAt": "2024-02-16T22:34:13Z",
          "updatedAt": "2024-02-16T22:34:13Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by PR #106",
          "createdAt": "2024-02-17T22:27:51Z",
          "updatedAt": "2024-02-17T22:27:51Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOFsQObc4-mq-4",
      "title": "Introduce JPA and JPT inside of the JWP draft",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/20",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JWP"
      ],
      "body": "Create cross-linkable sections for terminology, such as \"JWP Protected Header\", etc.  Refer to existing JOSE definitions such as \"collision resistant names\" also.",
      "createdAt": "2021-11-10T21:27:20Z",
      "updatedAt": "2023-11-10T17:45:43Z",
      "closedAt": "2023-11-10T17:45:43Z",
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as a pre-publication issue",
          "createdAt": "2023-11-10T17:45:43Z",
          "updatedAt": "2023-11-10T17:45:43Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOFsQObc4-m3ZS",
      "title": "Move JPA request parts to subsections",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/21",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer"
      ],
      "labels": [
        "JPA"
      ],
      "body": "Also add recommendation that algorithms support a single octet string serialization for higher level protocols.",
      "createdAt": "2021-11-10T22:36:05Z",
      "updatedAt": "2024-02-27T23:26:23Z",
      "closedAt": "2024-02-27T23:26:23Z",
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes, please times 1,000.... never again with EC point compression patent work arounds...",
          "createdAt": "2021-12-04T17:21:39Z",
          "updatedAt": "2021-12-04T17:21:39Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "We need clarification on what change is pending for this issue, or if it has been resolved",
          "createdAt": "2024-02-16T22:36:24Z",
          "updatedAt": "2024-02-16T22:36:24Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this was addressed by https://github.com/json-web-proofs/json-web-proofs/pull/106, which defined the `alg` header parameter.",
          "createdAt": "2024-02-27T23:26:23Z",
          "updatedAt": "2024-02-27T23:26:23Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOFsQObc4-m3hk",
      "title": "Document known algorithm features & predicate proof support",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/22",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer",
        "selfissued"
      ],
      "labels": [
        "JPA"
      ],
      "body": "* range proof\r\n* equivalence\r\n* blind signatures\r\n* PoK\r\n* set (non-)membership\r\n\r\netc...",
      "createdAt": "2021-11-10T22:37:04Z",
      "updatedAt": "2024-02-17T22:29:43Z",
      "closedAt": "2024-02-17T22:29:42Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "On the call today there was a question about if predicate proofs are supported.  They definitely are (any and all types), though they aren't represented directly/individually in the JWP definition and are instead expected to be an integrated part of the `proof` value.\r\n\r\nSee also #27 where we'll work on some language to describe this relationship better.",
          "createdAt": "2021-11-17T02:15:15Z",
          "updatedAt": "2021-11-17T02:15:15Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It might be smart to start a tentative alg registry, so we can start referring to things by unambiguous names...\r\n\r\nIf we wait too long we will have all the problems that secp256k1 has.... \r\n\r\nhttps://github.com/microsoft/VerifiableCredentials-Crypto-SDK-Typescript/blob/906128f610e14ffaf122a8b31668b0de7799c054/libs/plugin/tests/Subtle.spec.ts#L18\r\n\r\n'K-256', 'ES256K', 'secp256k1', 'ES256K-R'...",
          "createdAt": "2021-12-04T17:20:44Z",
          "updatedAt": "2021-12-04T17:20:44Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83e\udd14, a registry is an intriguing thought.  It would be established in the JPA draft as a place to identify different proof types.  While the details are always part of a specific JPA, I can see the benefit of unique identifiers of proof types supported by each.\r\n\r\nThis isn't quite PR-ready, but it's definitely something to re-evaluate in the near future.",
          "createdAt": "2022-02-08T17:34:19Z",
          "updatedAt": "2022-02-08T17:34:19Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Has this been resolved by the recent IANA considerations section?",
          "createdAt": "2024-02-16T22:37:18Z",
          "updatedAt": "2024-02-16T22:37:18Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this was addressed by PR #106 ",
          "createdAt": "2024-02-17T22:29:43Z",
          "updatedAt": "2024-02-17T22:29:43Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOFsQObc4-qdEE",
      "title": "Define what the JWK Thumbprint is of a JWK with layout information",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/23",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Given we're proposing to add additional information to the JWKs we use, I believe that we need to define how this additional information is used or not used by JWK Thumbprints (https://www.rfc-editor.org/rfc/rfc7638.html).  I would propose that the additional members be ignored, just as other information such as \"use\", etc. are ignored, since they are not \"required members\".",
      "createdAt": "2021-11-11T20:02:09Z",
      "updatedAt": "2021-12-14T18:49:50Z",
      "closedAt": "2021-12-14T18:49:50Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d, agree they are ignored, the thumbprint will be the same for the same underlying key material.",
          "createdAt": "2021-11-11T21:06:40Z",
          "updatedAt": "2021-11-11T21:06:54Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I remain opposed to including `lyt` in JWKs... it does not belong there... it belongs in the protected header... its a property of the proof produced, not the key used to produce it.\r\n\r\nIf the JWK thumbprint is the same... that kinda confirms my point.\r\n\r\nPer https://www.rfc-editor.org/rfc/rfc7638.html#page-6\r\n\r\n> Only the required members of a key's representation are used when\r\n> computing its JWK Thumbprint value. \r\n\r\nIf `lyt` is not required, there will be problems with caching where you have this situation...\r\n\r\n```\r\ncase 0: kid -> jwk\r\ncase 1: kid -> jwk with lyt\r\n```\r\n\r\nbut if `lyt` is required to be in the key, case 0 will cause an error.",
          "createdAt": "2021-12-04T17:07:47Z",
          "updatedAt": "2021-12-04T17:11:36Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the `lyt` and the direct association of it with the JWK have been removed from the latest drafts, I'm going to close this issue.",
          "createdAt": "2021-12-14T18:49:50Z",
          "updatedAt": "2021-12-14T18:49:50Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOFsQObc4-u7c2",
      "title": "Indirect references in layouts seem inconsistent with being URL-safe",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/26",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JPT"
      ],
      "body": "JTPs are URL-safe but allowing binary portions of them via indirect references seems inconsistent.  Or was the intent that the payload be the base64url-encoded representation of the binary indirectly referenced object, such as a an object with media type `image/jpeg`?  If so, this language needs to be clarified.",
      "createdAt": "2021-11-13T00:07:25Z",
      "updatedAt": "2021-12-14T18:49:07Z",
      "closedAt": "2021-12-14T18:49:07Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> Or was the intent that the payload be the base64url-encoded representation of the binary indirectly referenced object\r\n\r\nThat was indeed the intent of the original language.\r\n\r\nI am starting to think that a JPT should be only strictly JSON values the same as a JWT.  JWP can support binary payloads for those use-cases, but the cost of trying to support their representation in a JPT is seeming like it only adds more complexity and diverges from trying to minimize the changes from a JWT.",
          "createdAt": "2021-11-17T02:06:25Z",
          "updatedAt": "2021-11-17T02:06:25Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I would stick to figuring this out in JSON first, then tackle binary and adjust the JSON side if any awkwardness is discovered... bad idea to do both at the same time imo.",
          "createdAt": "2021-12-04T17:16:17Z",
          "updatedAt": "2021-12-04T17:16:17Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this as indirect references have been removed and I agree w/ @OR13 to stick to JSON and tackle binary later (if/when necessary).",
          "createdAt": "2021-12-14T18:49:07Z",
          "updatedAt": "2021-12-14T18:49:07Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOFsQObc4-u7n8",
      "title": "Payloads can be predicates - not just claims",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/27",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer"
      ],
      "labels": [
        "PR-ready"
      ],
      "body": "There are a number of places in the current drafts where we say that predicates represent claims but we fail to say that they can also represent predicates.  We should develop consistent language for describing both and uniformly use it.",
      "createdAt": "2021-11-13T00:09:37Z",
      "updatedAt": "2022-07-11T23:36:11Z",
      "closedAt": "2022-07-11T23:36:11Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> There are a number of places in the current drafts where we say that predicates represent claims\r\n\r\nI think you mean where we say that payloads represent claims?\r\n\r\nRegardless, there definitely needs to be consistent language around how predicate proofs are expected to be done.",
          "createdAt": "2021-11-17T01:50:45Z",
          "updatedAt": "2021-11-17T01:50:45Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I we need to say that payloads can represent claims or predicate proofs.",
          "createdAt": "2021-11-17T01:52:43Z",
          "updatedAt": "2021-11-17T01:52:43Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> that payloads can represent claims or predicate proofs.\r\n\r\nTechnically, payloads can represent claims, but they do _not_ represent predicate proofs (unless the claim itself is a form of a predicate proof from the issuer, such as a hashchain, which are just integrity protected as any other claim would be).\r\n\r\nAny predicate proofs generated during a `prove` operation are combined into the singular resulting `proof` value.\r\n\r\nWe touched on this during the meeting today: predicate proof representations are specific to the underlying JPA and are never understandable or useful directly to the application.  Only the JPA implementation can properly encode/decode and verify them along with how it binds them to a particular slot.  ",
          "createdAt": "2021-11-17T01:59:57Z",
          "updatedAt": "2021-11-17T01:59:57Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the language can be made more consistent in all three drafts around exactly what a payload represents separate from proofs.  Marking this as a TODO.",
          "createdAt": "2022-02-08T17:26:38Z",
          "updatedAt": "2022-02-08T17:26:38Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOFsQObc4-9nBc",
      "title": "Extending Existing Json Web Algorithms to Support Some ZKPs ",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/28",
      "state": "OPEN",
      "author": "boumba100",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "JPA"
      ],
      "body": "As we already know, the existing set of Json Web Algorithms (JWA) only really support proof of authenticity (I.e., that a message was signed by a certain key, and that it was not modified). I propose extending some of the existing JWAs, enabling them to support more extensive proof types such as selective-disclosure, compound proofs, and predicate proofs. \r\n\r\n \r\n\r\nI believe this could be achieved with the following approach. \r\n\r\n \r\n\r\nGenerating a digital signature. \r\n\r\n1. Create a vector Pedersen commitment on the messages (m1...mi). \r\n    * COMMITMENT = g<sub>1</sub><sup>m1</sup> * g<sub>2</sub><sup>m2</sup> * g<sub>i</sub><sup>mi</sup> * g<sub>n</sub><sup>nonce</sup> . \r\n2. Sign the commitment using an existing digital signature algorithm (e.g., [ECDSA](https://datatracker.ietf.org/doc/html/rfc7518#section-3.4)). \r\n    * SIGNING_INPUT = HASH (COMMITMENT) \r\n    * SIGNATURE = GENERATE_SIGNATURE (SIGNING_INPUT) \r\n\r\nGenerating a proof. \r\n\r\n1. Generate the required message proofs (MESSAGE_PROOFS), e.g., [selective-disclosure/proof-of-knowledge](https://github.com/hyperledger/ursa/blob/main/libzmix/bbs/src/pok_vc.rs) \r\n2. PROOF = (COMMITMENT, MESSAGE_PROOFS, SIGNATURE) \r\n\r\n \r\n\r\nVerifying a proof. \r\n\r\n1. VERIFICATION_INPUT = HASH (COMMITMENT) \r\n2. VERIFY_SIGNATURE (VERIFICATION_INPUT, SIGNATURE) \r\n3. VERIFY_MESSAGE_PROOFS (MESSAGE_PROOFS, COMMITMENT) \r\n\r\n \r\n\r\nThe homomorphic encryption property of a Pedersen Commitment would enable a prover to create a larger set of proof types on hidden messages. In fact, this is how the Ursa [BBS+](https://github.com/hyperledger/ursa/blob/d83240bea7e9c3fa48bb3bec208255e24c72423d/libzmix/bbs/src/lib.rs#L202) and [PS signatures](https://github.com/hyperledger/ursa/tree/main/libzmix/src/signatures/ps) implementations support it. \r\n\r\n \r\n\r\n### Some Pros and Cons of this approach \r\n\r\nPros: \r\n\r\n* A small component to implement on top of existing digital signature libraries \r\n* Allows for  multiple messages to be signed instead of one\r\n* Could enable predicate proofs\r\n* Could enable compound proofs, even between unlinkable proof algorithms such as BBS+ (needs some investigating) \r\n\r\nCons: \r\n* Proofs are still linkable \r\n\r\n### Jpa Identifier \r\n\r\nA JPA identifier for ES256 plus the described approach could be `ES256+C`, where `C` stands for commitment. \r\n\r\n \r\n### Pedersen Commitment Building Block\r\n\r\nAnother aspect to take into consideration is that the Pedersen Commitment is a building block for many of the ZKP proof algorithms. With this into consideration, I am wondering if we should create a section in the JPA draft spec to document the different proof algorithms that could be applied to Pedersen Commitments. JPAs can then refer to those algorithms.  \r\n\r\n \r\n\r\nUseful Links \r\n\r\n* https://asecuritysite.com/encryption/ped \r\n* [Vector Pedersen Commitment Proof of Knowledge URSA RFC (this is how selective disclosure is done for BBS+ and PS Signatures)](https://github.com/hyperledger/ursa-rfcs/tree/main/text/pok-vpc)\r\n\r\n \r\n\r\nNoah ",
      "createdAt": "2021-11-17T16:35:37Z",
      "updatedAt": "2024-02-16T22:52:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I really like this approach, I'd love to help develop it further as well!\r\n\r\nThere's very high level similarities to the \"Single Use\" JPA that is starting to get documented in the latest draft.\r\n\r\nWould you want to contribute this as PR for a new section in the JPA draft, or develop it on its own further?",
          "createdAt": "2021-12-14T18:46:34Z",
          "updatedAt": "2021-12-14T18:46:34Z"
        },
        {
          "author": "boumba100",
          "authorAssociation": "NONE",
          "body": "Sounds good!\r\n\r\nI'll start documenting this approach in the JPA draft.\r\n",
          "createdAt": "2021-12-15T15:47:09Z",
          "updatedAt": "2021-12-15T15:47:09Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @boumba100, just bumping this thread as we now have two JPAs documented and curious if you think this can be developed into a third?",
          "createdAt": "2022-02-08T17:22:31Z",
          "updatedAt": "2022-02-08T17:22:31Z"
        },
        {
          "author": "boumba100",
          "authorAssociation": "NONE",
          "body": "The following link points to the draft I've been working on:\r\nhttps://github.com/boumba100/json-web-proofs/blob/jpa-draft-ec%2BC/draft-jmiller-json-proof-algorithms.md\r\n\r\nPlease feel free to make any suggestions.\r\n\r\nThanks,\r\nNoah",
          "createdAt": "2022-02-11T17:59:02Z",
          "updatedAt": "2022-02-11T17:59:02Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You may also like: https://vitalik.ca/general/2021/06/18/verkle.html",
          "createdAt": "2022-02-11T19:49:10Z",
          "updatedAt": "2022-02-11T19:49:10Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "@boumba100 Impressive!\r\n\r\nIMO what you've written up so far is easily substantial enough to be its own standalone work.  Would you be interested in creating it as a draft in your own name?  It can still be a PR to this repo, would just separate the work into an algorithm specific draft.\r\n\r\nWould you be free 30 minutes before the upcoming JWP sync call next Tuesday to walk me (and anyone else interested) through it all?\r\n\r\nAlso just to be sure I'm processing this correctly so far, this algorithm will support selective disclosure and predicate proofs but it will not support unlinkability since the `S` from the issuer is also provided as-is to the verifier, correct?",
          "createdAt": "2022-02-16T04:11:44Z",
          "updatedAt": "2022-02-16T04:11:44Z"
        },
        {
          "author": "boumba100",
          "authorAssociation": "NONE",
          "body": "Hi @quartzjer,\r\n\r\nThat proposition interests me.\r\n\r\nCount me in for a chat before the next call.\r\n\r\nRegarding proof linkability, you are correct.\r\n\r\nA commitment that is signed using a traditional ECDSA algorithm is linkable because the value of `s` will not change. That said, the vector-commitment building block could be combined with a ZKP signature/proof algorithm (e.g., BBS+, PS Signatures, blind signatures) to support unlinkable proofs.\r\n\r\n",
          "createdAt": "2022-02-16T14:18:08Z",
          "updatedAt": "2022-02-16T14:19:43Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, @OR13 's verkle reference is on a server which does not appear to currently be running, see instead https://web.archive.org/web/20231115115627/https://vitalik.ca/general/2021/06/18/verkle.html\r\n\r\n",
          "createdAt": "2024-02-16T22:47:59Z",
          "updatedAt": "2024-02-16T22:47:59Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a bit of a call-out to see if there is still interest in this family of algorithms.",
          "createdAt": "2024-02-16T22:52:17Z",
          "updatedAt": "2024-02-16T22:52:17Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOFsQObc5AE0-L",
      "title": "Use different claim name than 'alg' for JPAs?",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/29",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JPA",
        "JWP"
      ],
      "body": "Since none of the JWA values for `alg` will work for a JWP, is using the same `alg` claim name to reference them potentially confusing?  For example, should we use `jwa` instead to identify the algorithm name in the protected header?\r\n\r\nThere is definitely no case where both `alg` and `jwa` could both be used, but it is possible that a JPA could be defined to _also_ work for a traditional JWS, such as \"BBS+\" for example.\r\n\r\nIt seems to make sense to use the same value and registry, with just the caveat that some algorithm definitions will only work for proofs and most will not, similar to encryption or signing?",
      "createdAt": "2021-12-09T01:20:29Z",
      "updatedAt": "2021-12-09T22:22:18Z",
      "closedAt": "2021-12-09T22:22:18Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's more JOSE-like to use `alg` and to specify that some `alg` values only work for proofs (just like some `alg` values work for signatures and some work for encryption).",
          "createdAt": "2021-12-09T06:08:14Z",
          "updatedAt": "2021-12-09T06:08:14Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree, sticking with `alg`, closing this issue.",
          "createdAt": "2021-12-09T22:22:18Z",
          "updatedAt": "2021-12-09T22:22:18Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOFsQObc5AMWY4",
      "title": "Are JSON object claims supported?",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/33",
      "state": "CLOSED",
      "author": "OR13",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [
        "JPT",
        "PR-ready"
      ],
      "body": "Trivial claims, like these can easily be mapped to a payload array.\r\n\r\n```\r\n \"claims\": [\r\n    \"iat\",\r\n    \"exp\",\r\n    \"family_name\",\r\n    \"given_name\",\r\n    \"email\"\r\n  ]\r\n```\r\n\r\nOur use cases involve complex object usually of specific types... \r\n\r\nHow are objects supported by this spec?",
      "createdAt": "2021-12-10T15:43:41Z",
      "updatedAt": "2024-03-01T21:50:50Z",
      "closedAt": "2024-03-01T21:50:50Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Any of those claim names can be an object value (or any JSON value).\r\n\r\nThe processing of a complete JWP/JPT cannot itself be represented as a singular JSON object, each payload is a standalone  that has only a cryptographic association with the other payloads.",
          "createdAt": "2021-12-14T18:40:14Z",
          "updatedAt": "2021-12-14T18:40:14Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to mark this as a TODO for the next revision of JPT, to add an example claim that is a JSON object.",
          "createdAt": "2022-02-08T17:23:59Z",
          "updatedAt": "2022-02-08T17:23:59Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, we certainly want to be able to have claims like \"address\" that are structured.  However, I don't think we want to go down the road that SD-JWT did to enable disclosure of parts of structured claims.  Like others, they should be all-or-nothing.",
          "createdAt": "2024-02-17T22:56:02Z",
          "updatedAt": "2024-02-17T22:56:02Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "yes, I'll just add a single `address` claim as a JSON object to the examples.",
          "createdAt": "2024-02-17T22:58:23Z",
          "updatedAt": "2024-02-17T22:58:23Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOFsQObc5AcsUU",
      "title": "Should we be separating proof signatures with ~ ?",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/35",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the single-use JWP example, I was surprised that the signatures in the proof were simply concatenated together.  Search for \"The signature for the protected header is then also appended. Using the above examples, the resulting octet string is 320 in length (5 * 64):\" to see the concatenation.\r\n\r\nThe concatenation works as long as the signatures are fixed-length (which I agree is normally the case).  But we could separate the signatures by placing ~ characters between them, just as we do with payload elements.  This would be more general and provide defense in depth against bad code that uses the wrong length when parsing signatures.\r\n\r\nThis would also accommodate situations where different signatures use different algorithms and may be of different lengths.  (Will that ever occur?  Do we even know yet?)\r\n\r\nWhat do people think?",
      "createdAt": "2021-12-15T16:50:19Z",
      "updatedAt": "2022-01-25T21:54:02Z",
      "closedAt": "2022-01-25T21:54:02Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "For the Single Use algorithm definition I believe we'll need to add a table documenting exactly which existing JWAs are supported and what their fixed signature lengths are for each.  I don't believe any practical signature methods ever have variable length output as that would inherently violate them being uniform/indistinguishable regardless of what is signed.\r\n\r\nThe question is still valid though, since we introduce `~` as a separator for the payloads, is there utility for allowing the proof value to use it as well?\r\n\r\nMy current stance is no, as I view all of the JWP structural elements as existing to support the _application_ processing.  Every application/library using a JWP needs to understand the difference between the protected header, the individual payloads, and the opaque proof value that is passed to the relevant algorithm implementation.  All of these values can be base64url decoded by the application and treated as octet strings.\r\n\r\nTo have to pass the non-decoded proof value to the algorithm seems like an exception, and so does having the application break the proof value into parts and then pass the parts to the algorithm... the application cannot use the parts as they have no meaning to it.\r\n\r\nSo my thought is that if the algorithm needs any structure it must implement that strictly within its own layer.  All signature values have an internal structure, simple ones like XY appended for ECDSA or even much more complex ones like ( A', Abar, d, C1, e^, r2^, C2, r3^, s^, (m^[i], ..., m^[R]) ) all appended for a [BBS+ proof](https://mattrglobal.github.io/bbs-signatures-spec/#name-spkgen).  Signatures are usually kept free of structure and are a strict binary structure in order to avoid accidentally introducing an attack vector due to the structural elements or requiring a more complex parser or dependency in decoding them.\r\n\r\nAs the BBS+ example shows, the presented proof values will inevitably become internally complex, particularly as they have to encompass more variability around optional predicate proofs being included.  Even if we allowed for a `~` separator element here, it wouldn't possibly satisfy all of those needs.",
          "createdAt": "2021-12-15T17:35:11Z",
          "updatedAt": "2021-12-15T17:35:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "NONE",
          "body": "+1 my answer is also no, I think in general the stance for JWP should be that the signature value and any internal structure it may have should be opaque at the JWP layer (e.g treated just as a base 64 url encoded octet string) much like the internal structure of a ECDSA signature is opaque in a JWS",
          "createdAt": "2022-01-11T23:35:29Z",
          "updatedAt": "2022-01-11T23:35:29Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this as I believe there's consensus, we can re-open if there's additional input.",
          "createdAt": "2022-01-25T21:54:02Z",
          "updatedAt": "2022-01-25T21:54:02Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOFsQObc5Bd26J",
      "title": "VC Data Model Example",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/36",
      "state": "OPEN",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [
        "JPT"
      ],
      "body": "Placeholder to track adding a full example of a JPT using the VC Data Model into the draft.",
      "createdAt": "2022-01-10T20:37:39Z",
      "updatedAt": "2024-02-27T23:31:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "NONE",
          "body": "Because JWP payloads are only contain claims, would the body of JWT-VC be equivalent to the Header of a JWP-VC?\r\n\r\nSample Header of JWP-VC?:\r\n\r\n```\r\n{\r\n  \"iss\": \"did:example:1234\", //VC's issuer\r\n  \"sub\": \"did:example:5678\", //user\r\n  \"nbf\": 1541493724,\r\n  \"exp\": 1573029723,\r\n  \"jti\": \"http://example.com/credentials/2022\",\r\n  \"nonce\": 660!6345FSer,\r\n  \"vc\": {                    //omitting @context for now\r\n    \"type\": [\"VerifiableCredential\", \"BasicCredential\"],\r\n  },  \r\n  \"claims\": [                //need to clarify relationship between vc.credentialSubject and JWP header `claims`?\r\n    \"family_name\",\r\n    \"given_name\",\r\n    \"email\",\r\n    \"age\"\r\n  ],\r\n  \"typ\": \"JPT\",\r\n  \"alg\": \"BBS-X\"\r\n}\r\n\r\n```",
          "createdAt": "2022-02-11T19:22:39Z",
          "updatedAt": "2022-02-11T19:22:39Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "The example header would look more like:\r\n```json\r\n{\r\n  \"iss\": \"did:example:1234\",\r\n  \"vc\": { \r\n    \"type\": [\"VerifiableCredential\", \"BasicCredential\"],\r\n  },  \r\n  \"claims\": [\r\n    \"sub\",\r\n    \"nbf\",\r\n    \"exp\",\r\n    \"jti\",\r\n    \"family_name\",\r\n    \"given_name\",\r\n    \"email\",\r\n    \"age\"\r\n  ],\r\n  \"typ\": \"JPT\",\r\n  \"alg\": \"BBS-X\"\r\n}\r\n```\r\n\r\nThe header can only contain parameters/values that are a constant, if they are unique they become something that can be correlated.  All per-issuance values MUST be in a payload so that they can be selectively disclosed and unlinkable (when supported by the JPA).",
          "createdAt": "2022-02-16T03:43:23Z",
          "updatedAt": "2022-02-16T03:43:23Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "For draft 5: add comparable example based on current SD-JWT work, e.g. https://drafts.oauth.net/oauth-selective-disclosure-jwt/draft-ietf-oauth-selective-disclosure-jwt.html#name-example-4a-sd-jwt-based-ver",
          "createdAt": "2024-02-16T22:57:31Z",
          "updatedAt": "2024-02-16T22:57:31Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOFsQObc5CAAd2",
      "title": "It would seem more logical to have the JWP Protected Header signature be the first one, not the last one",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/38",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer"
      ],
      "labels": [],
      "body": "The JPA spec currently says:\r\n> To prepare the JWP for signing or verification a Parts List is created.  Each payload octet string is placed into the Parts List preserving their order from the JWP.  The JWP Protected Header octet string is then appended to this list as the last element\r\n\r\nIf I were designing this, I would have put the header signature first so that it always falls in the same place.  Currently its location is dependent upon the number of payload elements.  Can we agree to put it first?",
      "createdAt": "2022-01-18T19:44:44Z",
      "updatedAt": "2022-01-25T20:13:52Z",
      "closedAt": "2022-01-25T20:13:52Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "That was my first instinct as well.\r\n\r\nThe reason I flipped it was thinking about it from an implementors perspective: knowing that the proof value is an array of fixed-size signatures, so the obvious first thing to do is something like `sigs_array = proof.split(size_of_signature)`.  My thought was it could be more consistent to have that array's indexes be identical to the array of payloads in the JWP, you can't get an off-by-one error with that approach.\r\n\r\nThe protected header signature would then be `sigs_array[-2]` and the signer's public signature would be `sigs_array[-1]`.\r\n\r\nIt seemed potentially less error-prone vs. asking the implementor to pop/shift/sub-slice/etc.\r\n\r\nI'm perfectly comfortable flipping the order around if that's more logical.",
          "createdAt": "2022-01-18T20:01:27Z",
          "updatedAt": "2022-01-18T20:01:27Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd really prefer to put them in the order\r\n(1) signature of the protected header,\r\n(2) signatures over the payloads,\r\n(3) public signature.\r\n\r\nI want that because then the signatures occur in the same order as the things being signed.  Thanks.",
          "createdAt": "2022-01-18T22:24:00Z",
          "updatedAt": "2022-01-18T22:24:00Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that you don't need a signature of the protected header wrapped into the overarching signature - you can create the payload for the overall signature by concatenate the protected header of the JWP with the signatures of the individual payloads.\r\n\r\nThis payload is synthetic from the protected header and proof, so approach just saves one signature in space and computational budget.",
          "createdAt": "2022-01-19T06:10:05Z",
          "updatedAt": "2022-01-19T06:10:05Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't understand what data structure you're proposing from the above comment, DW.  Can you be explicit about what signatures over what plaintexts you want to appear in what order?  And for bonus points, why?  Thanks.",
          "createdAt": "2022-01-19T06:27:24Z",
          "updatedAt": "2022-01-19T06:27:24Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: Variables refer to non-base64-encoded values, e.g. UTF8 JSON text for headers and binary data for payloads.\r\n\r\nGiven:\r\n- protected header `jwpph` with:\r\n  - `alg` algorithm for single use referencing underlying algorithm `ualg`, e.g. `alg` of `SU-ES256` and `ualg` of `ES256`\r\n  - understood applicable public key `pk` compatible with `ualg`\r\n  - a `proof_jwk` header value for an ephemeral JWK `epk` compatible with `ualg`\r\n- `payloads[0...n]`\r\n \r\nTo issue:\r\n1. Create a predictable, synthesized protected header `sph` based on the underlying algorithm `ualg`. For example, the algorithm `SU-ES256` creates a synthesized protected header `sph` of `{\"alg\":\"ES256\"}`\r\n2. For each `payload[n]`:\r\n\r\n   2.1.   create a JWS with the synthesized protected header `sph` and the payload value `payload[n]`, signed by the key `epk`.\r\n   2.2.  Capture the payload signature `psig[n]`\r\n\r\n3. Compute overarching signature:\r\n\r\n   3.1.  Create a JWS with the synthesized protected header `sph` and a payload containing a concatenation of the JWP protected header `jwpph` and each `psig[0...n]`, signed by the key `pk`.\r\n   3.2.  Capture the overarching signature `osig`\r\n \r\n4. The proof is the concatenation of `psig[0...n]` and `osig`.\r\n\r\nTo verify:\r\n1. Crete synthetic protected header as above\r\n2. Split proof into `psig[0...n]` and `osig`.\r\n3. Verify overarching signature using `sph`, the concatenation of `jwpph` and `psig[0...n]`, and `pk`.\r\n4. For each disclosed `payload[n]`:\r\n\r\n   4.1 Verify payload signature using `sph`, `psig[n]`, and `epk`.\r\n\r\nTo derive:\r\n1. Delete payload slots which you do not wish to disclose\r\n\r\n",
          "createdAt": "2022-01-19T06:56:39Z",
          "updatedAt": "2022-01-19T06:56:39Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm also having a separate discussion on whether `epk` is needed, or if it is meant to avoid the potential misuse of component signatures.",
          "createdAt": "2022-01-19T07:00:02Z",
          "updatedAt": "2022-01-19T07:00:02Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this as the latest draft has the suggested ordering.",
          "createdAt": "2022-01-25T20:13:52Z",
          "updatedAt": "2022-01-25T20:13:52Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "I_kwDOFsQObc5CayJq",
      "title": "Types of / Definition of \"Binding\"",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/41",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [],
      "body": "When supporting unlinkability, a JPA can also support a form of \"binding\" that ensures any honest Prover is the only entity that can generate a valid proof when given a challenge from a Verifier.\r\n\r\nThis algorithmic-level binding primitive is different and separate from any higher level types of binding such as using a DID in a payload, a protocol-based Proof of Posession, keychain signatures, or ephemeral keys.  All of those types of higher level bindings are not able to provide unlinkability for a Prover when presenting the same JWP to multiple Verifiers.\r\n\r\nTODO: \r\n- [ ] Define Unlinkability (JWP)\r\n- [ ] Define Unlinkable Binding (JPA)\r\n- [ ] Define Linkable Binding (JPT)",
      "createdAt": "2022-01-25T20:13:02Z",
      "updatedAt": "2024-03-01T21:51:55Z",
      "closedAt": "2024-03-01T21:51:55Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Per discussion with @dwaite on the JWP editors' call, we think that these should be defined in JWP.",
          "createdAt": "2024-02-20T22:48:22Z",
          "updatedAt": "2024-02-20T22:48:22Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #78 .\r\n\r\n",
          "createdAt": "2024-03-01T07:26:29Z",
          "updatedAt": "2024-03-01T07:58:51Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOFsQObc5DiA_D",
      "title": "Using registered JWT claim names",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/43",
      "state": "CLOSED",
      "author": "Sakurann",
      "authorAssociation": "NONE",
      "assignees": [
        "dwaite"
      ],
      "labels": [],
      "body": "Can registered JWT claim names be used? if so, how? \r\nFor example, if I want to include issuance date and expiration date in JWP, should I use a header to do so?",
      "createdAt": "2022-02-11T19:15:11Z",
      "updatedAt": "2024-02-17T01:31:35Z",
      "closedAt": "2024-02-17T01:31:35Z",
      "comments": [
        {
          "author": "Sakurann",
          "authorAssociation": "NONE",
          "body": "Issue #36 ",
          "createdAt": "2022-02-11T19:15:32Z",
          "updatedAt": "2022-02-11T19:15:32Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe we need to add that using registered JWT claims is the best practice to the JSON Proof Token specification.",
          "createdAt": "2022-02-11T19:30:28Z",
          "updatedAt": "2022-02-11T19:30:28Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we'll likely need a separate registry where we re-register all the existing JWT claims and explain any capabilities added by JWP (such as using predicate proofs).\r\n\r\nThe one exception from this that I can think of is the `iss` claim.  That one should be in the protected header and not a payload.",
          "createdAt": "2022-02-16T03:30:39Z",
          "updatedAt": "2022-02-16T03:30:39Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "The current JPT spec references that JWT claim names should come from the JWT IANA registry, and does not define any additional IANA registry for extending those claim values (such as providing for indicating capabilities like predicate proofs).\r\n\r\nCurrent JWP guidance is that things like predicate proofs would not be claims, but rather be part of the proof value itself.\r\n\r\nThe `iss` issuer protected header value is now listed in an initial registry section under JWP IANA considerations.\r\n\r\nI believe this can be closed.",
          "createdAt": "2024-02-16T23:03:47Z",
          "updatedAt": "2024-02-16T23:03:47Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOFsQObc5IC-Oe",
      "title": "Add COSE/CBOR examples of Single Use",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/49",
      "state": "OPEN",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-19T18:56:39Z",
      "updatedAt": "2024-02-16T23:04:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding to the COSE/CBOR work planned for draft 6",
          "createdAt": "2024-02-16T23:04:25Z",
          "updatedAt": "2024-02-16T23:04:25Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "I_kwDOFsQObc5I5ya_",
      "title": "Support for multiple signatures/proofs",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/50",
      "state": "OPEN",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "H/T @OR13 on looping me into a thread about the difficulty (complete lack-of) of supporting multiple signatures in JWTs,  this is definitely a use case we should try to directly support for JWPs.\r\n\r\nMy initial take would be to extend the use of ~ to support compound issuer headers and proofs:\r\n`issuer_header_alice~issuer_header_bob.payload_1~payload_2~payload_3.issuer_proof_alice~issuer_proof_bob`\r\nand the presentation\r\n`issuer_header_alice~issuer_header_bob.payload_1~~payload_3.presentation_proof_alice~presentation_proof_bob`\r\n\r\nThe multiple issuer headers/proofs wouldn't have any intrinsic linking/relationship (unless they encoded such internally in their headers), so the presenter would be free to include/exclude whatever ones they choose to.  The verifier would be required to verify _all_ of them (that are included).",
      "createdAt": "2022-05-02T16:49:39Z",
      "updatedAt": "2024-02-27T23:44:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are basically 3 problems to be solved.\r\n\r\n1. how are the issuers committing to multisig (header semantics)\r\n2. how are issuers able to attach signatures (adding or appending signatures)\r\n3. what process does an honest verifier have to follow ensure issuer multisig is achieved.\r\n\r\n\r\nIn order for a verifier to believe multisig, they need N valid signatures over the same data, we do't want an issuer to be \"removable\" which means that \"all the headers\" need to be signed the same way... if the issuer intends all to be required.\r\n\r\nThere are also schemes where signatures can be added to together, and ones where that is not possible.\r\n\r\nFor example, lets assume the following headers:\r\n\r\n\r\n```\r\n{\r\n  \"kid\": \"did:example:bob#key-0\",\r\n  \"alg\": \"ES256\"\r\n}\r\n```\r\n\r\n```\r\n{\r\n  \"kid\": \"did:example:alice#key-0\",\r\n  \"alg\": \"ES384\"\r\n}\r\n```\r\n\r\nAssuming that order can be relied on, a verifier would pop the first header, and signature, verify the payloads, and then pop every other header and signature and verify that the payloads match the first.\r\n\r\nHowever, in a scheme where signatures can be added (like Schnorr on Bitcoin, some storage could be saved:\r\n\r\n```\r\n{\r\n  \"kid\": \"did:example:bob#key-0 + did:example:alice#key-0\",\r\n  \"alg\": \"SS256K\",\r\n}\r\n```\r\n\r\nSee example: https://medium.com/coinmonks/on-bitcoins-schnorr-signature-algorithm-and-taproot-script-and-witness-sizes-fe4d1e6591a7\r\n\r\nIn this scheme, either a single \"multisig public key\" would be present, or a verifier could compute it from the header.\r\n\r\n\r\n",
          "createdAt": "2022-05-03T12:48:18Z",
          "updatedAt": "2022-05-03T12:53:45Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "A Schnorr-based scheme would need its own JPA with semantics specific and optimized to it, I don't think this generic multi-issuer syntax needs to solve for specific schemes.  I'd like an approach here that is strictly one level above a JPA such that any defined algorithm used by an issuer can be included in a multi-issued JWP.\r\n\r\n> we do't want an issuer to be \"removable\" which means that \"all the headers\" need to be signed the same way\r\n\r\nI may not be understanding what you're saying here? As a generic syntax for including multiple issuer header-proof pairs (across the same payloads), I would fully expect the holder to be in control of which pairs to use/disclose. \r\n\r\nIf one of the issuers has specific requirements about which other issuers MUST be included, they can encode that in their header either as a statement \"valid only if kid-X is present\" or as a witness \"here's the hash of kid-X's signature\" etc.\r\n\r\nThese would all be application-specific logic. The JWP layer would simply validate that all of the included proofs are correct for their given headers and the disclosed payloads. If there's specific rules about which keys must be used or how many proofs must be present, that is part of the application's specific validation logic (the same as custom verifier logic around which claims must be disclosed, etc).",
          "createdAt": "2022-05-03T17:46:30Z",
          "updatedAt": "2022-05-03T17:46:30Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So there are basically 3 scenarios which we discussed:\r\n\r\n1. multi-suite multi-sig (EdDSA, ES256K, ES384) (with out without an upfront commitment to issuers)\r\n2. single suite multiple headers (ES256K x3) (with out without an upfront commitment to issuers)\r\n3. single suite single header (SS256K) (is an upfront commitment to an issuer, that is implied by public keys)",
          "createdAt": "2022-05-03T18:59:05Z",
          "updatedAt": "2022-05-03T19:03:32Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "It's possible to also have:\r\n\r\n4. multi-suite multi-sig with a single/shared issuer header (that lists all the issuers)",
          "createdAt": "2022-05-03T20:02:17Z",
          "updatedAt": "2022-05-03T20:02:17Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "On the last call @tplooker brought up handling of the presentation header when there are multiple signatures from different suites.\r\n\r\nMy suggestion is that there is only a single presentation header that every included proof must provide integrity protection for (by the holder). If there are JPA-specific fields in that header they must all be included in the same single presentation header (and must be using registered non-conflicting header parameter names already anyway).",
          "createdAt": "2022-05-03T20:06:55Z",
          "updatedAt": "2022-05-03T20:06:55Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "For the different categories of multisig (listed above): could we used the word \"_conjoined_\" to describe when the issuers are aware of and witnessing each other's issuance (in a verifiable way), and \"_disjoined_\" to describe when they are unaware and the holder is independently combining different issuer header/proof pairs?\r\n\r\nHappy to use better or any existing language to differentiate the two types.\r\n\r\nFor Schnorr-based multisig I'd like to call them \"_aggregated_\", and still believe they are best implemented as a JPA since the cryptographic layer performs the aggregation/verification and the application isn't processing multiple issuer header/signature pairs.",
          "createdAt": "2022-05-03T20:22:47Z",
          "updatedAt": "2022-05-03T20:22:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "NONE",
          "body": "> My initial take would be to extend the use of ~ to support compound issuer headers and proofs\r\n\r\nI think one thing to highlight here is that at the JWP layer there are two serialisations to consider how this would be represented [JSON](https://github.com/json-web-proofs/json-web-proofs/blob/main/draft-jmiller-json-web-proof.md#json-serialization) and [compact](https://github.com/json-web-proofs/json-web-proofs/blob/main/draft-jmiller-json-web-proof.md#compact-serialization) and the constraint referred to around how JWT cannot express multiple signatures is actually due to the fact that a valid JWT can only be expressed in compact JWS form.\r\n\r\nSuffice to say I think there are a few things to un-pack here\r\n\r\n1) Do we want to support expressing multiple signatures in JWP (i think the answer is yes and at a minimum supporting this in the JSON serialisation would not be a great lift IMO)\r\n2) Do we want to support multiple signatures in compact JWP form such as how @quartzjer has made a proposal\r\n3) Will JPT be limited like JWT to just compact serialisation (apologies if that decision has already been taken and I missed it)\r\n\r\n> My suggestion is that there is only a single presentation header that every included proof must provide integrity protection for (by the holder). If there are JPA-specific fields in that header they must all be included in the same single presentation header (and must be using registered non-conflicting header parameter names already anyway).\r\n\r\nI agree with this\r\n\r\n> For the different categories of multisig (listed above): could we used the word \"conjoined\" to describe when the issuers are aware of and witnessing each other's issuance (in a verifiable way), and \"disjoined\" to describe when they are unaware and the holder is independently combining different issuer header/proof pairs?\r\n\r\nUn sure about the exact language at this stage but agree its an important distinction to make, not to make it even more complex but some multisig protocols might mean all signers aren't entirely mutually aware of one and other e.g the last signer in a chain might know all other signers but not the first signer depending on the protocol.",
          "createdAt": "2022-05-11T09:38:02Z",
          "updatedAt": "2022-05-11T09:38:02Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "After mulling on this a LOT, I'm currently thinking that support for multiple issuers/proofs/etc is always most properly done by adding a JPA specifically to address the needs and underlying cryptographic relationships.\r\n\r\nThere's a lot of subtlety in what an application is expecting when using any type of multisig, and providing a single/simple high level encoding for just one of them isn't likely to even be an 80% solution.  It may even be actively harmful if used in situations where it is not exactly what is needed.\r\n\r\nI'm proposing to close this for now, and we can address with better requirements in future JPA development",
          "createdAt": "2022-06-12T23:16:32Z",
          "updatedAt": "2022-06-12T23:16:32Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there any example regarding your proposal to define this in JPA?  AFAIK, there are no concrete schemes that support any form of multisig in either JPA, JWP, or JWS as of this date.",
          "createdAt": "2022-06-13T16:39:25Z",
          "updatedAt": "2022-06-13T16:39:25Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe the flexibility will be there to do this within an algorithm definition. For example, use an `alg=\"BBS-MULTI\"` that is just an extension of the BBS alg that supports multiple signatures and has specific semantics around how they are validated.\r\n\r\nIf we adopt #59 then the algorithm can use the `~` to assist with this.",
          "createdAt": "2022-06-13T18:18:35Z",
          "updatedAt": "2022-06-13T18:18:35Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there interest in resurrecting this topic?",
          "createdAt": "2024-02-16T23:12:54Z",
          "updatedAt": "2024-02-16T23:12:54Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm skeptical of adding multiple signatures/proofs over the same payloads.  It seems like a lot of complexity to add to support an infrequent scenario.  That said, I'd be willing to be convinced if there are compelling use cases needing this functionality to support.\r\n\r\nMaybe we should discuss this possibility at IETF 119 in Brisbane.",
          "createdAt": "2024-02-17T22:34:34Z",
          "updatedAt": "2024-02-17T22:34:34Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "@dwaite and I propose to close this unless concrete use cases necessitating multiple signatures is endorsed by the working group.",
          "createdAt": "2024-02-20T22:14:55Z",
          "updatedAt": "2024-02-27T23:44:01Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOFsQObc5J2OT4",
      "title": "JWP Draft Publish TODO list",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/53",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer"
      ],
      "labels": [],
      "body": "This is tracking items to be done on the main JWP draft before being published as an IETF ID\r\n\r\n- [x] Decide on example (BBS vs. SU)\r\n- [x] Update SU-JWS alg naming (s/SU/JWS/)\r\n- [x] Finish MAC alg #48 \r\n- [x] Add language for #27 \r\n- [x] Formalize language\r\n- [x] Verify/add all references\r\n- [ ] Decide on #50 \r\n- [x] Introduce JPA/JPT #20 \r\n- [x] #19 \r\n- [ ] #7 \r\n- [x] #8 \r\n- [x] #11 ",
      "createdAt": "2022-05-17T17:28:09Z",
      "updatedAt": "2024-02-12T01:00:49Z",
      "closedAt": "2024-02-12T01:00:04Z",
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "aged pre-publication list. Closing in lieu of milestones",
          "createdAt": "2024-02-12T01:00:05Z",
          "updatedAt": "2024-02-12T01:00:05Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "I_kwDOFsQObc5KwYxr",
      "title": "Consider renaming \"Json Proof Algorithm\" and \"JPA\"",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/54",
      "state": "CLOSED",
      "author": "gabrielbauman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "JPAs should probably be renamed.\r\n\r\n- There's an initialism [clash](https://duckduckgo.com/?q=jpa&kp=1&t=newext&atb=v316-1&ia=web) with Java Persistence API (JPA), making it hard to search for\r\n- Things like the Single Use JPA support multiple crypto \"algorithms\", which rapidly gets confusing: \"which algorithm does this JSON Proof Algorithm use?\"\r\n- Using the JOSE \"alg\" key to point to something other than a cryptographic algorithm seems like a stretch and doesn't follow the principle of least surprise\r\n\r\nI'd suggest \"JSON Proof Method\" or \"JSON Proof Strategy\".",
      "createdAt": "2022-05-31T17:53:46Z",
      "updatedAt": "2024-02-16T23:13:34Z",
      "closedAt": "2024-02-16T23:13:34Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "This name is intentionally parallel to JSON Web Algorithms (JWA) [RFC 7518].\r\n\r\nConflicts among short acronyms are inevitable.  I was upset when IBM introduced the IBM PC, because up until that point in computer circles, PC stood for Program Counter.  I got over it. ;-)\r\n\r\nI don't see a compelling case for a name change.",
          "createdAt": "2024-01-01T02:38:20Z",
          "updatedAt": "2024-01-01T02:38:20Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "closing",
          "createdAt": "2024-02-16T23:13:34Z",
          "updatedAt": "2024-02-16T23:13:34Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOFsQObc5K50kT",
      "title": "Define and register media types for JWPs",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/55",
      "state": "CLOSED",
      "author": "gabrielbauman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[Media type(s)](https://datatracker.ietf.org/doc/html/rfc6838) for JWPs will need to be defined and registered.\r\n\r\nFor comparison, JWTs use `application/jwt+json`.\r\n\r\nWe could similarly use `application/jwp+json` and leave it to applications to determine which form is being parsed. We could also consider registering multiple media types, one for each form. I'm not sure what the best practice is in this case.",
      "createdAt": "2022-06-01T18:04:14Z",
      "updatedAt": "2024-02-16T23:14:20Z",
      "closedAt": "2024-02-16T23:14:20Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, this is needed.",
          "createdAt": "2024-01-01T02:38:59Z",
          "updatedAt": "2024-01-01T02:38:59Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Types are now registered within the JSON Web Proof IANA considerations",
          "createdAt": "2024-02-16T23:14:20Z",
          "updatedAt": "2024-02-16T23:14:20Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOFsQObc5K58M4",
      "title": "Define requirements for JPAs",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/56",
      "state": "CLOSED",
      "author": "gabrielbauman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Implementations need to know which JPAs MUST and/or SHOULD be implemented, and which are OPTIONAL.",
      "createdAt": "2022-06-01T18:19:40Z",
      "updatedAt": "2024-02-16T23:14:56Z",
      "closedAt": "2024-02-16T23:14:56Z",
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "This is part of the algorithm registry now defined by the JPA IANA Considerations.",
          "createdAt": "2024-02-16T23:14:56Z",
          "updatedAt": "2024-02-16T23:14:56Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "I_kwDOFsQObc5LnxrO",
      "title": "Proposal: expand presented form to support separate presentation signature",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/57",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer"
      ],
      "labels": [
        "JPA",
        "JWP"
      ],
      "body": "I'd like to add another presentation form with five sections:\r\n`<presentation_header>.<issuer_header>.<payload_1>~<payload_2>.<presentation_proof>.<presentation_signature>`\r\n\r\nRight now, the SU/MAC algs incorporate the presentation signature into the proof and it doesn't feel right.  The holder should be able to choose their own presentation algorithm independently from the issuer, and it should be able to be any normal JWS one.  \r\n\r\nFor algorithms such as BBS that internally incorporate replay protection and presentation header support, they would remain four-part but also re-order to be consistent:\r\n`<presentation_header>.<issuer_header>.<payload_1>~<payload_2>.<presentation_proof>`\r\n",
      "createdAt": "2022-06-12T22:26:47Z",
      "updatedAt": "2024-02-27T23:45:37Z",
      "closedAt": "2024-02-27T23:45:37Z",
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "I suspect this is part of a larger conversation about multi-signature/multi-proof structuring and whether that influences compact serialization/JSON serialization. See #50 ",
          "createdAt": "2024-02-16T23:16:41Z",
          "updatedAt": "2024-02-16T23:16:41Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe that we need make presentation signatures/proofs independent of the issuer, as @quartzjer suggests.",
          "createdAt": "2024-02-17T22:37:53Z",
          "updatedAt": "2024-02-17T22:37:53Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Could use clarity around examples",
          "createdAt": "2024-02-20T22:17:35Z",
          "updatedAt": "2024-02-20T22:17:35Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm closing this out as a duplicate of #59 ",
          "createdAt": "2024-02-27T23:45:32Z",
          "updatedAt": "2024-02-27T23:45:32Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOFsQObc5LnzNY",
      "title": "Allow algorithms to use ~ separator in proof values",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/59",
      "state": "CLOSED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [
        "JPT",
        "JPA"
      ],
      "body": "Having worked on the SU and MAC algo drafts which both make use of proof values that are actually arrays, I would like to update the JPT core definition to treat all proof values as an array natively.\r\n\r\nThe array would be identical to how payloads are encoded, in compact it would use `~` separator, and in JSON it would simply be an array of base64url-encoded strings.\r\n\r\nThe JWP implementation would be required to always decode it into an array of individual variable-length octet strings and then pass that array into the algorithm, even if there is only one item.\r\n\r\nThis provides notable cryptographic simplification benefit to algorithm definitions, such that they don't have to internally define their own separators, padding, etc.",
      "createdAt": "2022-06-12T23:00:44Z",
      "updatedAt": "2024-03-01T21:51:26Z",
      "closedAt": "2024-03-01T21:51:26Z",
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "I would be in favor of this. We do have signatures formed from combining binary data in JWA (such as ECDSA), but these have a fixed binary format. The addition of multiple payloads and of additional proof elements like predicate proofs would appear to create a need for dynamically sized binary data however, which means we are both putting on a burden for algorithms to create a scheme and a risk of additional out-of-bounds conditions in implementations.\r\n\r\nThis would mean we should probably make the JPA proof representation consistently into an array of binary values.",
          "createdAt": "2024-02-16T23:21:03Z",
          "updatedAt": "2024-02-16T23:21:03Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Doing this makes sense to me.",
          "createdAt": "2024-02-17T22:39:17Z",
          "updatedAt": "2024-02-17T22:39:17Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Will do a prototype to evaluate for draft 3",
          "createdAt": "2024-02-20T22:24:01Z",
          "updatedAt": "2024-02-20T22:24:01Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Planning to add text to this, but the changes to algorithms to use it will likely be draft-4 milestone",
          "createdAt": "2024-02-27T23:34:18Z",
          "updatedAt": "2024-02-27T23:34:18Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOFsQObc5j-2Bc",
      "title": "Publish working group drafts",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/65",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "quartzjer"
      ],
      "labels": [],
      "body": "To do:\r\n\r\n- Change titles from draft-jmiller-*-01 to draft-ietf-*-00, both in the titles and in the references\r\n- Update the dates in the references\r\n- Update the history entries to start over at -00, with the entry saying \"Created initial working group draft based on draft-jmiller-*-01\"\r\n- Change mbj@microsoft.com to michael_b_jones@hotmail.com and change \"Microsoft\" to \"individual\".",
      "createdAt": "2023-04-20T20:55:50Z",
      "updatedAt": "2023-07-12T17:00:20Z",
      "closedAt": "2023-07-12T17:00:20Z",
      "comments": []
    },
    {
      "number": 70,
      "id": "I_kwDOFsQObc5m_PwB",
      "title": "JWP issuer proof may have more than one use",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/70",
      "state": "CLOSED",
      "author": "brentzundel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Section 4.1.3 of JSON Web Proofs it reads \"The issuer proof is only for the holder to perform validation . . .\"\r\nI believe it is also the case for a number of supporting algorithms that the issuer proof is used to generate the presentation proof.\r\n\r\nI recommend either adding language that briefly describes this additional usage of the issuer proof, or removing the word 'only' to reduce confusion.",
      "createdAt": "2023-05-26T15:43:25Z",
      "updatedAt": "2023-10-21T17:36:26Z",
      "closedAt": "2023-10-21T17:36:26Z",
      "comments": []
    },
    {
      "number": 71,
      "id": "I_kwDOFsQObc5m_WKC",
      "title": "JPT section 6 sentence needs something",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/71",
      "state": "CLOSED",
      "author": "brentzundel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is a sentence in JPT section 6 that read, \"This cid can be used similar to a kid in\r\n   order to ensure externally resolve and then verify that the correct\r\n   list of claim names is being used when processing the payloads\r\n   containing the claim values.\"\r\n\r\nI think a word or two may be missing",
      "createdAt": "2023-05-26T16:02:21Z",
      "updatedAt": "2023-10-21T17:35:19Z",
      "closedAt": "2023-10-21T17:35:19Z",
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "I don't see the `cid` being used in the example of that section either.",
          "createdAt": "2023-06-02T13:43:35Z",
          "updatedAt": "2023-06-02T13:43:35Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOFsQObc5rXxTD",
      "title": "Draft 02 needs (retroactive) Changes section",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/75",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-12T17:01:10Z",
      "updatedAt": "2023-10-21T18:07:14Z",
      "closedAt": "2023-10-21T18:07:13Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by #82",
          "createdAt": "2023-10-21T18:07:13Z",
          "updatedAt": "2023-10-21T18:07:13Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOFsQObc5rXyL_",
      "title": "Need IANA considerations",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/76",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [
        "JPA"
      ],
      "body": "From @OR13, https://mailarchive.ietf.org/arch/msg/jose/GkL3I9hEoKjaIDCgno_rYqQsSP0/ :\r\n\r\n> It would be nice to see an initial table for the requested registry similar to how HPKE established registries:\r\n>\r\n>   * https://www.rfc-editor.org/rfc/rfc9180.html#name-algorithm-identifiers\r\n>   * https://www.rfc-editor.org/rfc/rfc9180.html#name-kem-identifiers\r\n>\r\n> Similarly for any new reserved claims ( such as `pjwk` ), it would be nice to see them all in one place.",
      "createdAt": "2023-07-12T17:04:01Z",
      "updatedAt": "2024-02-14T01:08:07Z",
      "closedAt": "2024-02-14T01:08:07Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll take a stab at creating a table for the header parameters we need.\r\n\r\nWe also need an algorithms registry.",
          "createdAt": "2024-01-05T22:55:59Z",
          "updatedAt": "2024-01-05T22:55:59Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "I_kwDOFsQObc5rXy_-",
      "title": "Define parameters and terminology in appropriate sections",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/77",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [
        "JPA"
      ],
      "body": "From @OR13, https://mailarchive.ietf.org/arch/msg/jose/GkL3I9hEoKjaIDCgno_rYqQsSP0/ :\r\n\r\n> Assume the reader has some awareness of JOSE, and introduce terms like `issuer_header` and `presentation_header` so that they defined in their sections, for example:\r\n>\r\n> https://datatracker.ietf.org/doc/html/draft-ietf-jose-json-proof-algorithms-00#name-presentation-protected-header-2\r\n>\r\n> does not include \"presentation_header\" header.",
      "createdAt": "2023-07-12T17:06:35Z",
      "updatedAt": "2024-03-02T19:30:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Typographically, we should use names like \"Issuer Header\" rather than `issuer_header` for things that are not parameter or field names.",
          "createdAt": "2024-01-05T22:48:18Z",
          "updatedAt": "2024-01-05T22:48:18Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "While this particular example seems solved, we have two general issues:\r\n\r\n1. algorithmic values and JSON parameters may have the same choice in snake vs camel vs upper case - we may wish to have two styles here for clarity\r\n2. we have definitions and processing steps in single use algorithm that should be raised to be generalized.",
          "createdAt": "2024-01-05T22:49:34Z",
          "updatedAt": "2024-01-05T22:49:34Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "I_kwDOFsQObc5rbGF6",
      "title": "for single-use algorithm, document whether the issuer and holder algorithms may be different",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/78",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [
        "JPA"
      ],
      "body": "From @OR13, https://mailarchive.ietf.org/arch/msg/jose/GkL3I9hEoKjaIDCgno_rYqQsSP0/ :\r\n\r\n> An example with a mixed algorithm for issue and holder would be nice here,\r\nor a comment about it being forbidden... for example issuer signing with\r\nES256 and holder presenting with EdDSA.",
      "createdAt": "2023-07-13T06:15:20Z",
      "updatedAt": "2024-03-02T19:30:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Clearly the issuer and holder algorithms have to be able to be different.  I'll review the specs with this in mind.",
          "createdAt": "2024-01-01T02:46:22Z",
          "updatedAt": "2024-01-01T02:46:22Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this work has been done, @selfissued are you ok with this being closed?",
          "createdAt": "2024-02-17T00:07:10Z",
          "updatedAt": "2024-02-17T00:07:10Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's consider this together with #57.  On the surface of it, it seems that we have to to address that one to address this one.",
          "createdAt": "2024-02-17T22:42:05Z",
          "updatedAt": "2024-02-17T22:42:05Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not think this is the same as #57 / #59 . We just need to make this clear for algorithms in general",
          "createdAt": "2024-02-27T23:50:46Z",
          "updatedAt": "2024-02-27T23:50:46Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOFsQObc5sjjGt",
      "title": "what about JWE?",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/83",
      "state": "OPEN",
      "author": "brentzundel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [],
      "body": "What, if any, should the relationship be between JWP and JWE?\r\n\r\nThis Issue is to track the question that was brought up during IETF 117.",
      "createdAt": "2023-07-25T22:27:38Z",
      "updatedAt": "2024-02-17T00:08:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "My initial gut reaction to this is that ZKPs are more like signatures than encryption.  I *think* that encryption is out of scope.\r\n\r\nThat said, we may want to describe encrypting a JWP object with JWE.",
          "createdAt": "2024-01-01T02:48:07Z",
          "updatedAt": "2024-01-01T02:48:07Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "I suspect that encryption with JWP are going to be part of storage protection or transport, e.g. wrapping a JWP in JWE.\r\n\r\n",
          "createdAt": "2024-01-05T22:35:32Z",
          "updatedAt": "2024-01-05T22:35:32Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Setting a reminder for draft 6 to potentially describe JWE wrapping a JWP for issuance/presentation. ",
          "createdAt": "2024-02-17T00:08:18Z",
          "updatedAt": "2024-02-17T00:08:18Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDOFsQObc52e934",
      "title": "Align terminology holder vs prover",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/89",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are a few cases where prover (e.g. prover key) is still used in the draft. Proposing these be changed to holder (e.g. holder key).",
      "createdAt": "2023-11-10T15:21:55Z",
      "updatedAt": "2024-01-05T18:11:15Z",
      "closedAt": "2024-01-05T18:11:15Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed on replacing prover with holder.",
          "createdAt": "2024-01-01T02:49:24Z",
          "updatedAt": "2024-01-01T02:49:24Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "I_kwDOFsQObc52lIJC",
      "title": "Multiple Issuers",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/90",
      "state": "CLOSED",
      "author": "SamuelSchlesinger",
      "authorAssociation": "NONE",
      "assignees": [
        "dwaite"
      ],
      "labels": [],
      "body": "Currently, the algorithms provided naturally have a single issuer for the underlying information we are proving statements about. However, in trying to add support for more general-purpose ZKPs (R1CS, for instance), I don't think this is general enough. In particular, here is a natural proposal for a 2-issuer proof in the context of verifiable credentials: \"exists X. I have a birth certificate with social security number X, and a background check issued for citizen with social security number X\". By forcing all of the information required by the verifier to be provided by a single \"issued proof\", we are undermining the privacy properties of the protocols which more general zero-knowledge proofs enable.\r\n\r\nI propose we change the language in the web-proofs draft to allow for multiple \"issued proofs\". Because they are no longer 1-to-1 with proofs, I also propose to bikeshed the language here: Let's call them \"issued facts\" instead, or \"provable facts\".",
      "createdAt": "2023-11-12T15:09:53Z",
      "updatedAt": "2024-02-20T22:15:47Z",
      "closedAt": "2024-02-20T22:15:46Z",
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #57 ",
          "createdAt": "2024-02-17T00:08:51Z",
          "updatedAt": "2024-02-17T00:08:51Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's even more closely related to #50.",
          "createdAt": "2024-02-17T22:43:38Z",
          "updatedAt": "2024-02-17T22:43:38Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing since this is a duplicate of #50.",
          "createdAt": "2024-02-20T22:15:46Z",
          "updatedAt": "2024-02-20T22:15:46Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "I_kwDOFsQObc54jFgz",
      "title": "JS Implementation",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/91",
      "state": "OPEN",
      "author": "pax-k",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I would like to contribute to the official JS implementation of your spec, and to make it super easy for anyone to integrate JWP in their apps. I could take care of developing a clean architecture for the lib, implementing the spec, writing tests, publishing the lib, writing examples for different use-cases / platforms (browser, mobile, server). I've been working with VCs/DIDs/DWNs for the past year and have experience in building isomorphic JS libs.\r\nIs this something you have on your roadmap?",
      "createdAt": "2023-12-03T10:46:12Z",
      "updatedAt": "2024-02-17T00:25:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm curious - which of the algorithms did you build?  All of Single-Use, BBS, and MAC?",
          "createdAt": "2024-01-01T07:22:34Z",
          "updatedAt": "2024-01-01T07:22:34Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "@pax-k We would love more implementations!\r\n\r\nSince our goal is to describe interoperability in specifications rather than to say that a particular implementation is authoritatively \"correct\", we don't really encourage one implementation over others. That said, we do use Node to generate examples and the like today, and could certainly use something a bit better than our barebones scripts to do things like generate examples and even maintain test vectors.",
          "createdAt": "2024-02-17T00:25:06Z",
          "updatedAt": "2024-02-17T00:25:06Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "I_kwDOFsQObc57k3NV",
      "title": "\"The holder's signature needs to also incorporate the presented proof\"",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/94",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [
        "JPA"
      ],
      "body": "In review, we interpreted this old comment as the presentation proof needs to sign over the entire derived message (issuer header and presented payloads) rather than just the header. this changes the SU and MAC based algorithms.",
      "createdAt": "2024-01-09T22:14:50Z",
      "updatedAt": "2024-02-27T23:34:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "I will evaluate as part of my work on resolving #59 ",
          "createdAt": "2024-02-20T22:24:46Z",
          "updatedAt": "2024-02-20T22:24:46Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "I_kwDOFsQObc57k3aw",
      "title": "Spec build issues around JPA section 6.2.5",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/95",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [
        "JPA"
      ],
      "body": "There is a missing JSON serialization from the build - fix this.",
      "createdAt": "2024-01-09T22:15:33Z",
      "updatedAt": "2024-03-01T08:13:17Z",
      "closedAt": "2024-03-01T08:13:17Z",
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by 64facf8",
          "createdAt": "2024-03-01T08:13:17Z",
          "updatedAt": "2024-03-01T08:13:17Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "I_kwDOFsQObc57k6IW",
      "title": "Evaluate promoting parts of section 7 of JPT to the JWP spec",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/96",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [
        "JPT",
        "JWP"
      ],
      "body": "In evaluating rules described for JPT, it makes sense to describe these in the JWP spec for all applications.",
      "createdAt": "2024-01-09T22:26:48Z",
      "updatedAt": "2024-03-02T19:30:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 97,
      "id": "I_kwDOFsQObc57k6jT",
      "title": "Refactor JPT to share examples in JWP",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/97",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [
        "JPT"
      ],
      "body": "JWP has an appendix showing an example JPT; propose to refactor both specs to include the same (potentially generated) example.",
      "createdAt": "2024-01-09T22:28:38Z",
      "updatedAt": "2024-02-27T23:56:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 98,
      "id": "I_kwDOFsQObc57k6rz",
      "title": "JPT should recommend using the IANA registry for JWT claim names",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/98",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [
        "JPT"
      ],
      "body": "",
      "createdAt": "2024-01-09T22:29:14Z",
      "updatedAt": "2024-02-06T19:13:56Z",
      "closedAt": "2024-02-06T19:13:56Z",
      "comments": []
    },
    {
      "number": 99,
      "id": "I_kwDOFsQObc57k8Ii",
      "title": "briefly discuss issued and presented forms in JPT",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/99",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [
        "JPT"
      ],
      "body": "",
      "createdAt": "2024-01-09T22:34:53Z",
      "updatedAt": "2024-03-02T19:30:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "needs to use consistent language with the other drafts",
          "createdAt": "2024-02-27T23:19:02Z",
          "updatedAt": "2024-02-27T23:19:02Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "I_kwDOFsQObc57k-oO",
      "title": "Evaluate need for JSON serialization",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/100",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-09T22:45:03Z",
      "updatedAt": "2024-02-27T23:57:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I will talk to people about this at IETF 119 in Brisbane.",
          "createdAt": "2024-02-27T23:56:54Z",
          "updatedAt": "2024-02-27T23:56:54Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "I_kwDOFsQObc57k-uU",
      "title": "Represent serialization difference between zero-length payloads and non-disclosed payloads in compact representation",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/101",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-09T22:45:26Z",
      "updatedAt": "2024-03-01T22:02:48Z",
      "closedAt": "2024-03-01T22:02:47Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "This is important.",
          "createdAt": "2024-02-17T23:03:42Z",
          "updatedAt": "2024-02-17T23:03:42Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Will add special case for compact encoding that an underscore (`_`) represents a zero length payload.",
          "createdAt": "2024-02-20T22:30:42Z",
          "updatedAt": "2024-02-20T22:30:42Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "I_kwDOFsQObc57lBB6",
      "title": "Define audience header parameter",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/102",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "Define the use of an `\"aud\"` presentation header parameter to be suggested alongside `\"nonce\"`",
      "createdAt": "2024-01-09T22:54:59Z",
      "updatedAt": "2024-03-02T01:54:20Z",
      "closedAt": "2024-03-02T01:54:20Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe that `aud` should be a claim rather than a header parameter.  Same with `nonce`.\r\n\r\nBut I agree that we should discuss this.",
          "createdAt": "2024-02-17T23:06:37Z",
          "updatedAt": "2024-02-17T23:06:37Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Clarifying - `aud` makes sense as a presentation header parameter, for use of protocols which use this for holders to target a particular verifier.",
          "createdAt": "2024-02-27T23:58:31Z",
          "updatedAt": "2024-02-27T23:59:12Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDOFsQObc57lCyk",
      "title": "Should we keep non-ZKP algorithms",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/103",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per discussion in IETF 118 microphone comments, should we keep algorithms which do not have a reasonably inexpensive nonsinkable presentation.",
      "createdAt": "2024-01-09T23:01:58Z",
      "updatedAt": "2024-02-17T23:09:35Z",
      "closedAt": null,
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Being able to represent and use non-ZKP algorithms is a forcing function that we're writing the specifications in widely-applicable manner.  That doesn't mean that, in the end, we need to have the single-use algorithms be REQUIRED or even RECOMMENDED.  But I'm loathe to rip them out now, because having multiple algorithms and multiple kinds of algorithms will help keep us honest.",
          "createdAt": "2024-02-17T23:09:34Z",
          "updatedAt": "2024-02-17T23:09:34Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "I_kwDOFsQObc57lC5X",
      "title": "What additional ZKP algorithms should we add",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/104",
      "state": "OPEN",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-09T23:02:20Z",
      "updatedAt": "2024-01-09T23:02:20Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 108,
      "id": "I_kwDOFsQObc5_4FT1",
      "title": "Update BBS to latest draft",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/108",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [],
      "body": "Currently draft 5",
      "createdAt": "2024-02-20T22:35:37Z",
      "updatedAt": "2024-03-01T21:51:08Z",
      "closedAt": "2024-03-01T21:51:08Z",
      "comments": []
    },
    {
      "number": 115,
      "id": "I_kwDOFsQObc6A_m7-",
      "title": "Define cid",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/115",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JPT"
      ],
      "body": "It would be good to say more about what `cid` is and how to use it.  For starters, what does \"cid\" stand for?\r\n\r\nHow is the `cid` value computed and what checks are done using it?\r\n\r\nThe need for a clearer definition was first raised in PR #110 .",
      "createdAt": "2024-03-01T20:51:57Z",
      "updatedAt": "2024-07-22T00:05:09Z",
      "closedAt": "2024-07-22T00:05:09Z",
      "comments": []
    },
    {
      "number": 118,
      "id": "I_kwDOFsQObc6BQLo_",
      "title": "Update to draft-ietf-cose-bls-key-representations-04",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/118",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dwaite"
      ],
      "labels": [],
      "body": "This is currently pending upstream library changes for access to x/y coordinates",
      "createdAt": "2024-03-05T07:35:57Z",
      "updatedAt": "2024-07-21T17:44:04Z",
      "closedAt": "2024-07-21T17:44:03Z",
      "comments": [
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes,  we need to track this uodate.",
          "createdAt": "2024-03-05T11:04:43Z",
          "updatedAt": "2024-03-05T11:04:43Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Opened as mattrglobal/pairing_crypto#185",
          "createdAt": "2024-03-05T17:33:21Z",
          "updatedAt": "2024-03-05T17:33:21Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "updated in drafts 4",
          "createdAt": "2024-07-21T17:44:03Z",
          "updatedAt": "2024-07-21T17:44:03Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "I_kwDOFsQObc6BW3Wl",
      "title": "Register +jwp Structured Syntax Suffix",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/issues/119",
      "state": "CLOSED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "selfissued"
      ],
      "labels": [],
      "body": "... so people can use typ=\"foo+jwp\" for foo JWP objects.",
      "createdAt": "2024-03-05T22:33:57Z",
      "updatedAt": "2024-07-21T17:11:25Z",
      "closedAt": "2024-07-21T17:11:25Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg4MjgxMzEx",
      "title": "Initial Importing",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/1",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This brings in the rest of the [original HackMD markdown](https://hackmd.io/@quartzjer/JSON_Web_Proof).",
      "createdAt": "2021-07-13T00:32:40Z",
      "updatedAt": "2024-03-05T19:08:03Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "0f75b328d6cfdefbae51e74efa454f01d2829922",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "initial_full_import",
      "headRefOid": "6837298d451ff78e3aff48f14574cedc58dd5b4b",
      "closedAt": "2021-07-14T04:48:41Z",
      "mergedAt": "2021-07-14T04:48:41Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "31a96070dfb473391d45bb51105165dca2bbdc6d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA1ODQ5MDc2",
          "commit": {
            "abbreviatedOid": "6837298"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "looks great!",
          "createdAt": "2021-07-14T04:48:35Z",
          "updatedAt": "2021-07-14T04:48:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NDEwMTQy",
      "title": "Update draft-jmiller-json-web-proofs.md",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/3",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mike's initial suggestions",
      "createdAt": "2021-07-22T18:34:05Z",
      "updatedAt": "2021-07-22T19:03:24Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "31a96070dfb473391d45bb51105165dca2bbdc6d",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-initial-suggestions",
      "headRefOid": "b92901747936fc39e007f0e1a678767fa7be1f2b",
      "closedAt": "2021-07-22T19:03:24Z",
      "mergedAt": "2021-07-22T19:03:24Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "facb77d408bf07cbdc7096980149bdebad3eddcb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzMTM3OTg5",
          "commit": {
            "abbreviatedOid": "b929017"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-22T19:00:43Z",
          "updatedAt": "2021-07-22T19:00:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NDMwMjIy",
      "title": "Renames to be a consistent singular",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/6",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "No material content changes.",
      "createdAt": "2021-07-22T19:08:43Z",
      "updatedAt": "2024-03-05T19:08:04Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "facb77d408bf07cbdc7096980149bdebad3eddcb",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "rename_singular",
      "headRefOid": "f3d8703187a7854c59791796cbb3c5faf160b0ec",
      "closedAt": "2021-07-24T07:37:28Z",
      "mergedAt": "2021-07-24T07:37:28Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "dc5191883a70ee91ba33856dd2a565bc72fa7815"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjE0MjE3",
          "commit": {
            "abbreviatedOid": "f3d8703"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-07-24T07:37:16Z",
          "updatedAt": "2021-07-24T07:37:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOFsQObc4r-MOk",
      "title": "[WIP] Streamlined Scope",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/10",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are two significant things to note in this PR:\r\n1. Renaming of the `derive` step and \"derivation\" to the `prove` step and generating proofs, to be more consistent with the usage of \"proofs\" elsewhere in the draft.\r\n2. Removing all language regarding the mapping of what values are in which payload slot, leaving this to the application or a companion spec.\r\n\r\nThe result is a simpler spec that focuses strictly on the cryptographic container with pluggable proof algorithms. ",
      "createdAt": "2021-09-20T16:09:23Z",
      "updatedAt": "2021-10-05T23:37:20Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "1f8cf966c342cc0f71b484dcce6bc52d5a11cee0",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "streamlined_scope",
      "headRefOid": "ec5d1761c451e9407e986470b64104661b495a47",
      "closedAt": "2021-10-05T23:37:16Z",
      "mergedAt": "2021-10-05T23:37:16Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "9e9b7f8681e2257354a93e8b043dc16a37eb607a"
      },
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @OR13, this is some excellent feedback! \r\n\r\nI've got some work to do incorporating it, which might take me a week or so since I'll be out most of this coming week.",
          "createdAt": "2021-09-25T19:46:18Z",
          "updatedAt": "2021-09-25T19:46:18Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "@OR13 I think I've either made some improvements or filed/linked issues for all the feedback and points you raised, if I missed any I'm happy to keep refining too.",
          "createdAt": "2021-10-05T19:58:42Z",
          "updatedAt": "2021-10-05T19:58:42Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks all for the feedback! ",
          "createdAt": "2021-10-05T23:37:10Z",
          "updatedAt": "2021-10-05T23:37:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4tg--8",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:30:49Z",
          "updatedAt": "2021-09-25T18:30:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I am not sure this change is good. \r\n\r\n`proof-generation` is relevant to JWS/JWT, but `proof-derivation` is a new concept for JOSE  imo.",
              "createdAt": "2021-09-25T18:30:49Z",
              "updatedAt": "2021-09-25T18:30:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg-_4",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:31:46Z",
          "updatedAt": "2021-09-25T18:31:46Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n* [BBS+](https://github.com/mattrglobal/bbs-signatures)\r\n* [MerkleDisclosureProof2021](https://github.com/transmute-industries/merkle-disclosure-proof-2021)\r\n```",
              "createdAt": "2021-09-25T18:31:46Z",
              "updatedAt": "2021-09-25T18:31:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_Du",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:35:17Z",
          "updatedAt": "2021-09-25T18:35:17Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I know what you mean here, but potentially we might use language that overlaps with https://csrc.nist.gov/Projects/pec/zkproof\r\n\r\nSomething to the effect of \"...only a subset of the original claims\" or  \"Proofs of knowledge\"  for the original claims.",
              "createdAt": "2021-09-25T18:35:17Z",
              "updatedAt": "2021-09-25T18:35:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_LZ",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:43:14Z",
          "updatedAt": "2021-09-25T18:43:14Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "\r\nI would prefer to see JWP support interfaces like:\r\n\r\n`create/generate` - construct and secure document and proof.\r\n`derive/prove` - transform a document and proof in such a way that they remain verifiable while's enhancing privacy.\r\n`verify` - verify a document and proof.\r\n\r\nI'm not sure its wise to limit `sign/create` to happening only once.... consider multi-signature scenarios where material is collected from parties over time.\r\n\r\nWe could potential address those scenarios by thinking of `sign` as `contribute to proof` where it might happen once, or a few times.",
              "createdAt": "2021-09-25T18:43:14Z",
              "updatedAt": "2021-09-25T18:43:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_M5",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:44:44Z",
          "updatedAt": "2021-09-25T18:44:44Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "<3 this feels like an excellent way of protecting JWP from over coupling to a particular approach, but we will need to remain vigilant.",
              "createdAt": "2021-09-25T18:44:44Z",
              "updatedAt": "2021-09-25T18:44:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_SL",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:50:41Z",
          "updatedAt": "2021-09-25T18:50:41Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "This feels like too many legal values for a payload....\r\n\r\nIn typescript this type would look like this:\r\n\r\n```\r\ntype Payload: string | number | Buffer | any; // yikes any? really?\r\n```\r\n\r\nThis will cause security issues later.\r\n\r\nIMO, payload should be JSON... if you can't serialize or deserialize JSON (IoT / CBOR/ pure binary use cases)....you probably won't like base64url encoding either... \r\n\r\nAlternatively, we might consider CBOR instead of JSON, but I really don't like the payload not having a single know type.",
              "createdAt": "2021-09-25T18:50:41Z",
              "updatedAt": "2021-09-25T18:50:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_W5",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:55:19Z",
          "updatedAt": "2021-09-25T18:55:19Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "I agree with this, but we should beware of scenarios where time information MUST be disclosed...\r\n\r\nproving I have a DL, without proving it's not expired could be a problem... pushing that information to the payload could cause interop issues, similar to `nbf`, `iat`....",
              "createdAt": "2021-09-25T18:55:19Z",
              "updatedAt": "2021-09-25T18:55:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_ZU",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T18:57:48Z",
          "updatedAt": "2021-09-25T18:57:48Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "This sounds to me like https://datatracker.ietf.org/doc/html/rfc7638 but applying to JWP protected headers.\r\n\r\nWe should beware of serialization ordering issues with objects.... \r\n\r\nThis digest would function as a correlation identifier for any derived proof.",
              "createdAt": "2021-09-25T18:57:48Z",
              "updatedAt": "2021-09-25T18:57:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_f2",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:04:01Z",
          "updatedAt": "2021-09-25T19:04:01Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "We don't have a definition of `value` nor a single type of payload, which makes this sentence very hard to understand....\r\n\r\nIn my preferred world where the payloads are JSON, this might read as:\r\n\r\nThe order and construction of specific payload objects prior to JSON serialization is out of scope for this specification.\r\n\r\nMechanisms for ordering serialized payloads are out of scope for this specification.\r\n\r\nwe need to address both:\r\n\r\n```\r\ntype Payload: JSON | ANY\r\n\r\ntype Payloads: OrderedArray<Payload>\r\n```\r\n\r\nboth are out of scope.\r\n\r\n",
              "createdAt": "2021-09-25T19:04:01Z",
              "updatedAt": "2021-09-25T19:05:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_lp",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:09:14Z",
          "updatedAt": "2021-09-25T19:09:15Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "I am not sure I agree with this... how you internally represent EC points is not relevant to a JSON Data Format spec... \r\n\r\nMight be better to say: encoding requirements for libraries that produce JWPs are out of scope, as are defining JSON serializations for ZKP parameters or options.... however I suspect that will have to happen somewhere...\r\n\r\n",
              "createdAt": "2021-09-25T19:09:15Z",
              "updatedAt": "2021-09-25T19:09:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_nH",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:11:21Z",
          "updatedAt": "2021-09-25T19:11:21Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "This sentence does not make sense to me... are you meaning to say that the length of `payload: Array<ANY>` is constant / final and hidding values is like doing this:\r\n\r\nitems[disclosureIndex'] = 'hidden' ?\r\n",
              "createdAt": "2021-09-25T19:11:21Z",
              "updatedAt": "2021-09-25T19:11:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_ob",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:12:48Z",
          "updatedAt": "2021-09-25T19:12:48Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "this is not possible if disclosure of the original header digest is required.",
              "createdAt": "2021-09-25T19:12:48Z",
              "updatedAt": "2021-09-25T19:12:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_rC",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-25T19:15:50Z",
          "updatedAt": "2021-09-25T19:15:50Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "As much as I love base64url... it kinda sucks that `-` breaks highlighting... I take it this is one of those cases where the old way of doing things is probably worth preserving more than the improvement, buts its worth noting that base64url inflates data, has no built in error correction, is not \"double clickable\" and allows multiple serializations to deserialize to the same buffer.\r\n\r\nThese issues might not be worth deviating from the convention of just using bas64url, but they are worth noting.",
              "createdAt": "2021-09-25T19:15:50Z",
              "updatedAt": "2021-09-25T19:15:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4tg_t9",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This PR is awesome, I left some comments, none of my comments are blocking as this is DIF not W3C or IETF.\r\n\r\n",
          "createdAt": "2021-09-25T19:18:49Z",
          "updatedAt": "2021-09-25T19:18:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4t25Wz",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:48:20Z",
          "updatedAt": "2021-10-01T20:48:21Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "JWS supports an unlimited amount of legal values for a payload - in that it's simply signing an array of bytes.  Similarly, the JWP layer should know nothing about the content of ifs payloads, other than their representations as arrays of bytes.",
              "createdAt": "2021-10-01T20:48:21Z",
              "updatedAt": "2021-10-01T20:48:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t25oA",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:50:07Z",
          "updatedAt": "2021-10-01T20:50:08Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "We should talk about \"MUST be disclosed\" payloads on the next DIF Crypto JWP call.  It's a great topic.  That said, I don't think this PR should block on solving that.",
              "createdAt": "2021-10-01T20:50:08Z",
              "updatedAt": "2021-10-01T20:50:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t26Jd",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:53:29Z",
          "updatedAt": "2021-10-01T20:53:29Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "A spec layered about JWP where payloads are JSON should absolutely define this.  We'd tentatively started calling this JSON Selective Disclosure Token (JSDT), I believe.  The beauty of this PR is that it separates concerns, in the same way that concerns are separated between JWS and JWT.",
              "createdAt": "2021-10-01T20:53:29Z",
              "updatedAt": "2021-10-01T20:53:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t26XR",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:54:54Z",
          "updatedAt": "2021-10-01T20:54:54Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "\"that\" is grammatically correct here.  Please revert the change to \"which\".",
              "createdAt": "2021-10-01T20:54:54Z",
              "updatedAt": "2021-10-01T20:54:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t26iJ",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:55:59Z",
          "updatedAt": "2021-10-01T20:55:59Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Another great topic for the next call...",
              "createdAt": "2021-10-01T20:55:59Z",
              "updatedAt": "2021-10-01T20:55:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t29im",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T21:17:43Z",
          "updatedAt": "2021-10-01T21:17:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It seems to me that there's both proof generation and proof derivation steps, as well as a proof verification step.  Which were you intending to talk about here (or maybe both of the first two)?",
              "createdAt": "2021-10-01T21:17:43Z",
              "updatedAt": "2021-10-01T21:17:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t2-LK",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T21:22:40Z",
          "updatedAt": "2021-10-01T21:22:41Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "This has to be in scope somewhere.  It may be the algorithms spec.  It may also make its way into the JSDT spec.  Clean engineering of the layers will be key.",
              "createdAt": "2021-10-01T21:22:40Z",
              "updatedAt": "2021-10-01T21:22:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t2-kS",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T21:25:46Z",
          "updatedAt": "2021-10-01T21:25:46Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Does Derivation move to the JSDT spec?  We may still want to at least informatively say that applications of JWP will do derivation.",
              "createdAt": "2021-10-01T21:25:46Z",
              "updatedAt": "2021-10-01T21:25:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t2-0A",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T21:27:47Z",
          "updatedAt": "2021-10-01T21:27:47Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "I disagree with the \"multiple serializations to deserialize to the same buffer\" comment.  There is a single base64url encoding of any string of bytes.  Given there's a 1:1 correspondence, I don't understand this comment, @OR13 .",
              "createdAt": "2021-10-01T21:27:47Z",
              "updatedAt": "2021-10-01T21:27:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t2-9W",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I believe that this PR moves us forward, and so should be merged.  That said, I'm fine with another commit being added to address some of the comments made in the PR beforehand.",
          "createdAt": "2021-10-01T21:28:57Z",
          "updatedAt": "2021-10-01T21:28:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4t6-sn",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T15:16:03Z",
          "updatedAt": "2021-10-04T15:16:04Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "https://github.com/decentralized-identity/sidetree/blob/3184bfabd4b01e22c9d56fb16feadb5b303da9c4/lib/core/versions/1.0/Multihash.ts#L208\r\n\r\n```\r\n// Compare the strings instead of buffers, \r\n// because encoding schemes such as base64URL \r\n// can allow two distinct strings to decode into the same buffer.\r\n// e.g. 'EiAJID5-y7rbEs7I3PPiMtwVf28LTkPFD4BWIZPCtb6AMg' and\r\n//      'EiAJID5-y7rbEs7I3PPiMtwVf28LTkPFD4BWIZPCtb6AMv' would decode into the same buffer.\r\n```",
              "createdAt": "2021-10-04T15:16:03Z",
              "updatedAt": "2021-10-04T15:16:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t6_Wm",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T15:18:08Z",
          "updatedAt": "2021-10-04T15:18:09Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "is there a link to JSDT?",
              "createdAt": "2021-10-04T15:18:09Z",
              "updatedAt": "2021-10-04T15:18:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t7BBW",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T15:23:35Z",
          "updatedAt": "2021-10-04T15:23:35Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I am in favor of:\r\n\r\n```\r\ntype PayloadOptions = Buffer;\r\ntype Payload = base64url (Buffer). base64url (PayloadOptions).\r\ntype Payloads = Array<Payload>;\r\n```\r\n\r\nimplementers shouldn't have to care about the payload content, the alg registry should tell you how to care about options or payloads.",
              "createdAt": "2021-10-04T15:23:35Z",
              "updatedAt": "2021-10-04T15:23:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8svH",
          "commit": {
            "abbreviatedOid": "d1f3633"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T00:52:09Z",
          "updatedAt": "2021-10-05T00:52:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Regardless of the cryptographic primitive used by the _issuer_, they are still performing the act of signing, the issuer is adding authentication (that they signed it) and integrity.  The holder upon receiving a _signed_ JWP then validates the signature to make sure it is authentic and has integrity.\r\n\r\nWhen interacting with a verifier, the holder derives a proof of authenticity and integrity of the header and disclosed payloads.  The cryptographic primitive is predominately ZKPs, but the act is still proving since the holder isn't the original signer.\r\n\r\nThat's the way I've grown to think about it across all of the papers and code I've read in this space.  I think \"proof generation\" is more appropriate, as it is always an act of creation of a new output that is used to prove. Derivation could have other interpretations/meanings or create the wrong expectations.\r\n",
              "createdAt": "2021-10-05T00:52:09Z",
              "updatedAt": "2021-10-05T00:52:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8ux_",
          "commit": {
            "abbreviatedOid": "5bb8ad6"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T01:10:30Z",
          "updatedAt": "2021-10-05T01:10:30Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I mentioned in another comment my thought process behind sign/sign_verify and proove/proof_verify language, happy to pick that up in that thread or we can create an issue to continue also.\r\n\r\nGood point about the \"only once\" language, fixing that now :+1: ",
              "createdAt": "2021-10-05T01:10:30Z",
              "updatedAt": "2021-10-05T01:16:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8wve",
          "commit": {
            "abbreviatedOid": "5d1a886"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T01:32:03Z",
          "updatedAt": "2021-10-05T01:32:04Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "This is an unfortunate complexity I think we'll have to work through and deal with in some form.\r\n\r\nThe JWP _algorithm interface_ simply *must* support rich types.  JWP itself as a container format absolutely treats each payload as an array of bytes, but during the act of signing, proof generation, and proof validation the algorithm has to have the ability to accept rich types.\r\n\r\nThese rich interfaces are language/library level and not part of the protocol, but they are important to support required capabilities such as blinded values (algo has to be given an elliptic curve point), predicate proofs (algo requires a number, set member value, etc).\r\n\r\nThere's no reason to make these encodings be part of the protocol, they really are an implementation language level detail and algorithm specific.  There's not even an interop issue that I can tell since the algorithms that support these have very specific ways they use them via a hash2curve or other such cryptographic transformation.\r\n\r\nI definitely need help explaining this and adding better text around it, so I welcome the discussions :) ",
              "createdAt": "2021-10-05T01:32:03Z",
              "updatedAt": "2021-10-05T01:32:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8xBg",
          "commit": {
            "abbreviatedOid": "5d1a886"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T01:35:22Z",
          "updatedAt": "2021-10-05T01:35:23Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "I believe we'll be forming a sibling JWP spec that adds semantics around specific claims like JWT. Presentation exchange is also a good place for these types of rules.\r\n\r\nI don't think these payload-specific requirements need to be handled at the core JWP layer other than integrity protecting and disclosing the fixed header. ",
              "createdAt": "2021-10-05T01:35:23Z",
              "updatedAt": "2021-10-05T01:35:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t8xWI",
          "commit": {
            "abbreviatedOid": "5d1a886"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T01:39:13Z",
          "updatedAt": "2021-10-05T01:39:13Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Excellent point @OR13, this definitely needs some language around that, with probably more detail in a security considerations.\r\n\r\nThe protected header SHOULD be minimal and static across all usages of a given key, and static as in simply re-using the digested version.  It's only real purpose is to contain signals of how to process the JWP, key id, etc.",
              "createdAt": "2021-10-05T01:39:13Z",
              "updatedAt": "2021-10-05T01:39:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4t_xPH",
          "commit": {
            "abbreviatedOid": "f18fce7"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T16:39:26Z",
          "updatedAt": "2021-10-05T16:39:26Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Agree that the payload contents should be addressed in a companion spec, and I also agree this wording is definitely incomplete and needs more work.",
              "createdAt": "2021-10-05T16:39:26Z",
              "updatedAt": "2021-10-05T16:39:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAB6y",
          "commit": {
            "abbreviatedOid": "f18fce7"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:48:02Z",
          "updatedAt": "2021-10-05T17:48:03Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "I'm going to close this sub-thread since it's the same discussion on the payload encodings above.",
              "createdAt": "2021-10-05T17:48:02Z",
              "updatedAt": "2021-10-05T17:48:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uACoI",
          "commit": {
            "abbreviatedOid": "f18fce7"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:50:24Z",
          "updatedAt": "2021-10-05T17:50:25Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "It is possible when the header digest is static and applies to all JWPs an issuer generates.",
              "createdAt": "2021-10-05T17:50:24Z",
              "updatedAt": "2021-10-05T17:50:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAFfS",
          "commit": {
            "abbreviatedOid": "f18fce7"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:55:21Z",
          "updatedAt": "2021-10-05T17:55:21Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Given that we plan on defining a COSE Proof analog to JWP, my preference is to keep JWP as close to JOSE conventions as possible for easier adoption in those existing environments.\r\n\r\nCOSE Proofs can serve as the basis for much more efficient representations that can be serialized/encoded independently by a constrained transport as needed.",
              "createdAt": "2021-10-05T17:55:21Z",
              "updatedAt": "2021-10-05T17:55:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAGZk",
          "commit": {
            "abbreviatedOid": "7d98b98"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:56:53Z",
          "updatedAt": "2021-10-05T17:56:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Corrected.",
              "createdAt": "2021-10-05T17:56:53Z",
              "updatedAt": "2021-10-05T17:56:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAlO0",
          "commit": {
            "abbreviatedOid": "7d98b98"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:33:23Z",
          "updatedAt": "2021-10-05T19:33:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I created issue #13 to continue this thread.",
              "createdAt": "2021-10-05T19:33:23Z",
              "updatedAt": "2021-10-05T19:33:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAl70",
          "commit": {
            "abbreviatedOid": "7d98b98"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:36:36Z",
          "updatedAt": "2021-10-05T19:36:36Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "\ud83d\udcaf agreed!",
              "createdAt": "2021-10-05T19:36:36Z",
              "updatedAt": "2021-10-05T19:36:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAmGy",
          "commit": {
            "abbreviatedOid": "7d98b98"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:37:21Z",
          "updatedAt": "2021-10-05T19:37:21Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Let's continue this in issue #8 ",
              "createdAt": "2021-10-05T19:37:21Z",
              "updatedAt": "2021-10-05T19:37:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAqVv",
          "commit": {
            "abbreviatedOid": "387de07"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:57:08Z",
          "updatedAt": "2021-10-05T19:57:09Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Related to issue #8, I also made some minor improvements to this text to be more clear.",
              "createdAt": "2021-10-05T19:57:09Z",
              "updatedAt": "2021-10-05T19:57:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uAuAv",
          "commit": {
            "abbreviatedOid": "ec5d176"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T20:14:35Z",
          "updatedAt": "2021-10-05T20:14:35Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "Pushed some improvements here that hopefully clarify also.",
              "createdAt": "2021-10-05T20:14:35Z",
              "updatedAt": "2021-10-05T20:14:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uA4kR",
          "commit": {
            "abbreviatedOid": "ec5d176"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T21:04:50Z",
          "updatedAt": "2021-10-05T21:04:50Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "like this change.",
              "createdAt": "2021-10-05T21:04:50Z",
              "updatedAt": "2021-10-05T21:04:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4uA_w4",
          "commit": {
            "abbreviatedOid": "ec5d176"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T21:43:35Z",
          "updatedAt": "2021-10-05T21:43:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOFsQObc4tGAnC",
      "title": "[WIP] draft of a JSON Proof Algorithms spec",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/14",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The goal is to outline the requirements and options for proof algorithms, and then start to define mappings to the existing known ones within that framework.",
      "createdAt": "2021-10-12T19:41:54Z",
      "updatedAt": "2021-10-12T20:14:13Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "9e9b7f8681e2257354a93e8b043dc16a37eb607a",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jpa-draft",
      "headRefOid": "22f7a44880f3b0a8185b11bdfec3015b8129591f",
      "closedAt": "2021-10-12T20:14:13Z",
      "mergedAt": "2021-10-12T20:14:13Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "e3d02f9b0f21639273c1c9bedfecb41387ddc8e9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4uXDmL",
          "commit": {
            "abbreviatedOid": "22f7a44"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Merge it!  Thanks for moving us from a blank page to something to edit.",
          "createdAt": "2021-10-12T19:54:30Z",
          "updatedAt": "2021-10-12T19:54:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOFsQObc4txMet",
      "title": "JSON Proof Tokens",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/16",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Work in progress on the start of a JSON Proof Token draft, very much still just a skeleton.",
      "createdAt": "2021-10-28T00:01:39Z",
      "updatedAt": "2021-11-05T21:22:54Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "72161d873ca5c8316485c3eaa09da07bc5c8bfd2",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jpt_draft",
      "headRefOid": "f2de4bbf18a0c95dd16bf9d76c9fb4b022aa2659",
      "closedAt": "2021-11-05T21:22:54Z",
      "mergedAt": "2021-11-05T21:22:54Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "8ba77cf002287fd9d27ac3ef75e87047391ca5da"
      },
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "While still a draft, I believe it's at a good point to review and potentially merge.",
          "createdAt": "2021-11-02T18:31:58Z",
          "updatedAt": "2021-11-02T18:31:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4vbs9l",
          "commit": {
            "abbreviatedOid": "f2de4bb"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T18:38:57Z",
          "updatedAt": "2021-11-02T18:38:58Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "this is layout right? are other layouts configurable, or is this the only supported one?",
              "createdAt": "2021-11-02T18:38:57Z",
              "updatedAt": "2021-11-02T18:38:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4vbu_H",
          "commit": {
            "abbreviatedOid": "f2de4bb"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T18:48:24Z",
          "updatedAt": "2021-11-02T18:48:25Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Per the discussion on the 2-Nov-21 DIF JWP call, we need clearer language than \"understood\".  There's a distinction between knowing how to disclose a claim as a mechanical process and full understanding the semantics of a claim.",
              "createdAt": "2021-11-02T18:48:24Z",
              "updatedAt": "2021-11-02T18:48:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4vbvOz",
          "commit": {
            "abbreviatedOid": "f2de4bb"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I would merge this either now or after addressing the small number of current review comments.  For one thing, I'd like the draft to be checked into main so I can create PRs against it.",
          "createdAt": "2021-11-02T18:49:30Z",
          "updatedAt": "2021-11-02T18:49:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4vb1c3",
          "commit": {
            "abbreviatedOid": "f2de4bb"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T19:17:58Z",
          "updatedAt": "2021-11-02T19:17:59Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Interested to see this debate over \"key\" vs \"header\" embedding for this value.\r\n\r\nI tend to have a natural frustation with binding keys to specifc uses arbitrarily.\r\n\r\nMostly because it violates the principle of \"if it can happen, it does happen\"...\r\n\r\nYou can say this key is \"signing\" and not \"encryption\" but if its supports ECHD, you can't stop folks from doing that....\r\n\r\nWe see this play out over and over again... most recently in the did core concept of \"verification relationships\"... or \"keys used for specific purposes like authentication or credential issuance\".\r\n\r\nThis feels even worse than that to me, since its \"keys used to issue specific credential types\".... I'd rather not see that zkp-cl feature repeated here.\r\n\r\nInstead I would like to see a system where the same key, might be for many purposes, without revealing what purposes it was used for... for example:\r\n\r\n\r\n```\r\n{\r\n      \"kty\": \"EC\",\r\n      \"crv\": \"P-256\",\r\n      \"x\": \"KSbFyuU2BC1erMom2dMnQM5X4ifBdDXm1yQujBlGbrM\",\r\n      \"y\": \"e50tXUMdJkdPseZkuIgCR_FMZ_zozeKusq6W4tr6-2M\"\r\n}\r\n```\r\n\r\nI use it for encryption, I use it for signing, I use it for merkle proofs, you don't know any of that by seeing the key.",
              "createdAt": "2021-11-02T19:17:59Z",
              "updatedAt": "2021-11-02T19:17:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4vb3J3",
          "commit": {
            "abbreviatedOid": "f2de4bb"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-02T19:26:20Z",
          "updatedAt": "2021-11-02T19:26:21Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Another consideration is that you might want to encode `lyt` by reference instead of by value....\r\n\r\nConsider a commitment to salted hash (lyt)... etc... it might be that there are really large potential space savings for large \"payload types\"... when you don't need to keep repeating the payload structure in the header or the key... btw this is what linked data contexts are supposed to help you do... maybe they didn't solve the problem the best way... but imo its still worth considering the concept of an `lyt` registry... since someone will create that, regardless of what we want.",
              "createdAt": "2021-11-02T19:26:20Z",
              "updatedAt": "2021-11-02T19:26:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 24,
      "id": "PR_kwDOFsQObc4uc5KV",
      "title": "Create README.md",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/24",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Repo readme for setting expectations and linking to current draft renders",
      "createdAt": "2021-11-12T11:38:57Z",
      "updatedAt": "2021-11-12T21:47:11Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "8ba77cf002287fd9d27ac3ef75e87047391ca5da",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "dwaite-readme",
      "headRefOid": "5eee425adbde635fa4a45c8ac9e6732dba7d1cbe",
      "closedAt": "2021-11-12T21:47:06Z",
      "mergedAt": "2021-11-12T21:47:06Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "0e46e3fee79866bb43d7bee8d79975c5b2bcc583"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4v--_p",
          "commit": {
            "abbreviatedOid": "5eee425"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for doing this, DW.  I particularly like having the links to the rendered drafts.",
          "createdAt": "2021-11-12T17:10:40Z",
          "updatedAt": "2021-11-12T17:10:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDOFsQObc4ueXoS",
      "title": "Clarifications to and expansions of all three specifications",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/25",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-12T20:45:25Z",
      "updatedAt": "2021-11-13T22:10:46Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "8ba77cf002287fd9d27ac3ef75e87047391ca5da",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-clarifications-and-expansions",
      "headRefOid": "8263b74c1d8be8317d04a2088c575ee9e2898988",
      "closedAt": "2021-11-13T22:10:46Z",
      "mergedAt": "2021-11-13T22:10:45Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "ecd30242b04f9245e3c55babfe116ed8fde6724f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4v_0k9",
          "commit": {
            "abbreviatedOid": "d5addb8"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "So many excellent fixes, thank you!",
          "createdAt": "2021-11-12T22:01:16Z",
          "updatedAt": "2021-11-12T22:01:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOFsQObc4vlmrV",
      "title": "Expanded real example for JWP",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/30",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Uses BBS+.",
      "createdAt": "2021-12-09T02:22:17Z",
      "updatedAt": "2021-12-09T19:50:40Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "ecd30242b04f9245e3c55babfe116ed8fde6724f",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jwp-examples",
      "headRefOid": "957d0395af833d5346328627f673c21f10f2d371",
      "closedAt": "2021-12-09T19:50:30Z",
      "mergedAt": "2021-12-09T19:50:30Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "fc938b66d9b886ab39e58058123a2a91e06dcfa5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4xTqHV",
          "commit": {
            "abbreviatedOid": "239b265"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Good progress.  Merge it!",
          "createdAt": "2021-12-09T06:11:23Z",
          "updatedAt": "2021-12-09T06:12:44Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Next maybe we can define `BBS+` in the algorithms spec.",
              "createdAt": "2021-12-09T06:11:23Z",
              "updatedAt": "2021-12-09T06:12:44Z"
            },
            {
              "originalPosition": 98,
              "body": "JWA or JPA?",
              "createdAt": "2021-12-09T06:12:19Z",
              "updatedAt": "2021-12-09T06:12:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOFsQObc4voppe",
      "title": "updates and expansions to the JPA draft",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/31",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Includes a first pass at minimal language for the SU and BBS algos.",
      "createdAt": "2021-12-09T20:35:07Z",
      "updatedAt": "2021-12-10T05:13:06Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "fc938b66d9b886ab39e58058123a2a91e06dcfa5",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jpa-draft",
      "headRefOid": "343439d2f1d024580afd59785f1b063e24cc07ca",
      "closedAt": "2021-12-10T05:13:05Z",
      "mergedAt": "2021-12-10T05:13:05Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "bb27fb5f225ad7ef3828d32aeb2edab57815dd53"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4xYQSm",
          "commit": {
            "abbreviatedOid": "343439d"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Good progress!",
          "createdAt": "2021-12-10T05:12:51Z",
          "updatedAt": "2021-12-10T05:12:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOFsQObc4vprfx",
      "title": "First pass at replacing the \"layout\" approach with a much simpler claim names array one",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/32",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is the simplest possible structure I can imagine to accomplish the minimal goals of a JPT.\r\n\r\nIt lacks the ability to express more complex JSON structures that internally contain payloads, but this tradeoff may be worth that limitation in order to have a very simple solution.\r\n\r\nFor more complex requirements that this may not satisfy there are multiple other approaches we can document and suggest, such as using multiple JWPs (the signer can link them using a common claim instance value) and using CBOR/CWPs instead.",
      "createdAt": "2021-12-10T01:33:34Z",
      "updatedAt": "2024-03-05T19:08:05Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "fc938b66d9b886ab39e58058123a2a91e06dcfa5",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jpt_draft",
      "headRefOid": "64b9854663d7101145f5d5b2a2d71328f7b73819",
      "closedAt": "2021-12-10T05:16:03Z",
      "mergedAt": "2021-12-10T05:16:02Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "7a4e8b3d1d401a7f0f68399c934502875fc57150"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4xYQk4",
          "commit": {
            "abbreviatedOid": "64b9854"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I believe this simplification aligns with @OR13 's feedback.",
          "createdAt": "2021-12-10T05:15:53Z",
          "updatedAt": "2021-12-10T05:15:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4xajWJ",
          "commit": {
            "abbreviatedOid": "64b9854"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-10T15:45:09Z",
          "updatedAt": "2021-12-10T15:45:09Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I am against this language... keys should not store claims, it violates both the familiarity goal of the spec. ",
              "createdAt": "2021-12-10T15:45:09Z",
              "updatedAt": "2021-12-10T15:45:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4xajdn",
          "commit": {
            "abbreviatedOid": "64b9854"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-10T15:45:34Z",
          "updatedAt": "2021-12-10T15:45:34Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I opened https://github.com/json-web-proofs/json-web-proofs/issues/33 to track the object encoding issue seperatly.",
              "createdAt": "2021-12-10T15:45:34Z",
              "updatedAt": "2021-12-10T15:45:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4xajtb",
          "commit": {
            "abbreviatedOid": "64b9854"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-10T15:46:27Z",
          "updatedAt": "2021-12-10T15:46:27Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Also an example and normative language are needed here.",
              "createdAt": "2021-12-10T15:46:27Z",
              "updatedAt": "2021-12-10T15:46:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOFsQObc4v3Ell",
      "title": "A full example of a single-use JPT",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/34",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's not perfect, but it's a solid start.\r\n\r\nMy generation code also isn't exactly correct, so I'll need to update the contents.",
      "createdAt": "2021-12-15T01:29:32Z",
      "updatedAt": "2021-12-15T16:27:40Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "7a4e8b3d1d401a7f0f68399c934502875fc57150",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jwp-examples",
      "headRefOid": "87f8bff05e176caadb8e511b99c5306b6d6669de",
      "closedAt": "2021-12-15T16:27:39Z",
      "mergedAt": "2021-12-15T16:27:39Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "0d85a53f02d1b0c3dfe50e2f6039214979e1f94a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4xp2BU",
          "commit": {
            "abbreviatedOid": "87f8bff"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for doing this, @quartzjer !",
          "createdAt": "2021-12-15T16:27:32Z",
          "updatedAt": "2021-12-15T16:27:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOFsQObc4xD7I8",
      "title": "Expanding and correcting the text for the Single Use algorithm definition",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/37",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-14T21:37:34Z",
      "updatedAt": "2022-01-18T19:37:33Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "474e9bb9bbed4277ca0465a2f62415b5235e5dc8",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jpa-draft",
      "headRefOid": "f8069e508d487cef3e7ed99f48b21f68019f4f10",
      "closedAt": "2022-01-18T19:37:33Z",
      "mergedAt": "2022-01-18T19:37:33Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "41cf50af0933600c4a76ca6abeddb73d3656d74b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4zA96s",
          "commit": {
            "abbreviatedOid": "f8069e5"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-18T19:37:26Z",
          "updatedAt": "2022-01-18T19:37:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOFsQObc4xdqEy",
      "title": "Updated/Corrected Single Use Algo/Examples",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/39",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-23T23:16:54Z",
      "updatedAt": "2022-01-24T16:42:54Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "41cf50af0933600c4a76ca6abeddb73d3656d74b",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jpa-draft",
      "headRefOid": "dc198c5551a78b542e26ed90f2790cebc05afeab",
      "closedAt": "2022-01-24T05:04:07Z",
      "mergedAt": "2022-01-24T05:04:06Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "ff900fb203fb87843ec12291592b3f9dea1613b6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4zSc8p",
          "commit": {
            "abbreviatedOid": "dc198c5"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm going to merge this because I'm reviewing this spec with our engineering team in the morning.  Please nonetheless reply to my comments.  If you're busy, Jeremy, I'll create a PR addressing them after I hear your responses.\r\n\r\nThanks for doing this!",
          "createdAt": "2022-01-24T04:45:01Z",
          "updatedAt": "2022-01-24T05:01:27Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "When would this be necessary?  Or is `proof_header` an option we don't need?",
              "createdAt": "2022-01-24T04:45:01Z",
              "updatedAt": "2022-01-24T05:01:27Z"
            },
            {
              "originalPosition": 29,
              "body": "Should \"only the public values\" actually be \"only the REQUIRED values to represent the public key\"?",
              "createdAt": "2022-01-24T04:46:43Z",
              "updatedAt": "2022-01-24T05:01:27Z"
            },
            {
              "originalPosition": 5,
              "body": "A definition for \"Stable Key\" should be added to the Terminology section.",
              "createdAt": "2022-01-24T04:47:55Z",
              "updatedAt": "2022-01-24T05:01:27Z"
            },
            {
              "originalPosition": 46,
              "body": "The word \"modify\" is overly broad.  We should concisely describe the specific modifications that are allowed, that is, selectively disclosing subsets of the payloads.",
              "createdAt": "2022-01-24T04:51:30Z",
              "updatedAt": "2022-01-24T05:01:27Z"
            },
            {
              "originalPosition": 50,
              "body": "all of the header and payload signatures -> the header signature and all the payload signature",
              "createdAt": "2022-01-24T04:59:05Z",
              "updatedAt": "2022-01-24T05:01:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4zVVJt",
          "commit": {
            "abbreviatedOid": "dc198c5"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T16:36:51Z",
          "updatedAt": "2022-01-24T16:36:51Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I am not aware of any need, but I decided to include it here as a placeholder should one arise.",
              "createdAt": "2022-01-24T16:36:51Z",
              "updatedAt": "2022-01-24T16:36:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4zVVTK",
          "commit": {
            "abbreviatedOid": "dc198c5"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T16:37:18Z",
          "updatedAt": "2022-01-24T16:37:18Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Yes, that's much better language for it :+1: ",
              "createdAt": "2022-01-24T16:37:18Z",
              "updatedAt": "2022-01-24T16:37:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4zVVZB",
          "commit": {
            "abbreviatedOid": "dc198c5"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T16:37:35Z",
          "updatedAt": "2022-01-24T16:37:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Agreed!",
              "createdAt": "2022-01-24T16:37:36Z",
              "updatedAt": "2022-01-24T16:37:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4zVWfB",
          "commit": {
            "abbreviatedOid": "dc198c5"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T16:40:50Z",
          "updatedAt": "2022-01-24T16:40:50Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Definitely, excellent improvement plan.",
              "createdAt": "2022-01-24T16:40:50Z",
              "updatedAt": "2022-01-24T16:40:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4zVXJ5",
          "commit": {
            "abbreviatedOid": "dc198c5"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T16:42:53Z",
          "updatedAt": "2022-01-24T16:42:54Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Yep!",
              "createdAt": "2022-01-24T16:42:54Z",
              "updatedAt": "2022-01-24T16:42:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOFsQObc4xhFWw",
      "title": "Minor improvements",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/40",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As suggested by @selfissued on PR #39 ",
      "createdAt": "2022-01-24T19:33:38Z",
      "updatedAt": "2022-05-31T18:24:52Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "ff900fb203fb87843ec12291592b3f9dea1613b6",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jpa-draft",
      "headRefOid": "182333b5ec1b83bc01b500ffaae80fd8370433cc",
      "closedAt": "2022-01-24T21:49:09Z",
      "mergedAt": "2022-01-24T21:49:09Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "3e53f3dc4953ed3bbeb250eac229015d4d0f00ed"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4zWkeB",
          "commit": {
            "abbreviatedOid": "182333b"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for these improvements.",
          "createdAt": "2022-01-24T21:49:00Z",
          "updatedAt": "2022-01-24T21:49:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOFsQObc4yJWD2",
      "title": "JSON Proof Algorithm definition for BBS",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/42",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This contributes a JPA definition based on the existing software implementation of BBS.",
      "createdAt": "2022-02-07T04:43:18Z",
      "updatedAt": "2022-05-31T18:24:54Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "3e53f3dc4953ed3bbeb250eac229015d4d0f00ed",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jpa-bbs",
      "headRefOid": "888c63214f301ef108d28653335213e2f0887b22",
      "closedAt": "2022-02-08T17:00:57Z",
      "mergedAt": "2022-02-08T17:00:57Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "22e4f7515acbf11d9b9da040ca110e5512e89a33"
      },
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks both of you for the feedback! I've incorporated most of the feedback and replied to the rest.",
          "createdAt": "2022-02-08T05:31:04Z",
          "updatedAt": "2022-02-08T05:31:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc40Irke",
          "commit": {
            "abbreviatedOid": "ccfb2f0"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T13:35:40Z",
          "updatedAt": "2022-02-07T13:35:41Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "so you preserve revealed index locations with nulls correct?",
              "createdAt": "2022-02-07T13:35:40Z",
              "updatedAt": "2022-02-07T13:35:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40Jdah",
          "commit": {
            "abbreviatedOid": "ccfb2f0"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T15:58:27Z",
          "updatedAt": "2022-02-07T15:58:27Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Yes, in the JSON serialization a [null](https://github.com/json-web-proofs/json-web-proofs/blob/main/draft-jmiller-json-web-proof.md?plain=1#L141) is used to represent non-disclosed payloads.",
              "createdAt": "2022-02-07T15:58:27Z",
              "updatedAt": "2022-02-07T15:58:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40K6oA",
          "commit": {
            "abbreviatedOid": "ccfb2f0"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T21:39:14Z",
          "updatedAt": "2022-02-07T21:39:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "<3 ",
              "createdAt": "2022-02-07T21:39:15Z",
              "updatedAt": "2022-02-07T21:39:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40K65L",
          "commit": {
            "abbreviatedOid": "ccfb2f0"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T21:40:26Z",
          "updatedAt": "2022-02-07T21:40:26Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "ideally we could add a comment here to point to a WG or IETF draft for this value... even pointing to a GitHub repo would be better than just including the magic string here.",
              "createdAt": "2022-02-07T21:40:26Z",
              "updatedAt": "2022-02-07T21:40:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40K7TP",
          "commit": {
            "abbreviatedOid": "ccfb2f0"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-07T21:42:13Z",
          "updatedAt": "2022-02-07T21:42:14Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "For readability, I might repeat the protected header, and the entire decoded payload here... just to make the relationship to this encoded value even clearer.",
              "createdAt": "2022-02-07T21:42:14Z",
              "updatedAt": "2022-02-07T21:42:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40K7VJ",
          "commit": {
            "abbreviatedOid": "ccfb2f0"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T21:42:22Z",
          "updatedAt": "2022-02-07T21:42:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc40LSt9",
          "commit": {
            "abbreviatedOid": "ccfb2f0"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for adding this.  I made a few editorial suggestions.",
          "createdAt": "2022-02-07T23:50:19Z",
          "updatedAt": "2022-02-08T00:03:07Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "This is two sentences.  Separate them with a period.",
              "createdAt": "2022-02-07T23:50:19Z",
              "updatedAt": "2022-02-08T00:03:07Z"
            },
            {
              "originalPosition": 25,
              "body": "The last sentence should become two sentences.",
              "createdAt": "2022-02-07T23:51:13Z",
              "updatedAt": "2022-02-08T00:03:07Z"
            },
            {
              "originalPosition": 29,
              "body": "Another run-on sentence.",
              "createdAt": "2022-02-07T23:51:35Z",
              "updatedAt": "2022-02-08T00:03:07Z"
            },
            {
              "originalPosition": 35,
              "body": "Add a comma after \"In future versions of this algorithm\".",
              "createdAt": "2022-02-07T23:52:23Z",
              "updatedAt": "2022-02-08T00:03:07Z"
            },
            {
              "originalPosition": 39,
              "body": "What is a \"signed JWP Proof value\".  Should \"signed\" be deleted so it just says \"JWP Proof value\"?",
              "createdAt": "2022-02-07T23:53:21Z",
              "updatedAt": "2022-02-08T00:03:07Z"
            },
            {
              "originalPosition": 47,
              "body": "By \"trusted source\" do you mean \"trusted source of random numbers\"?",
              "createdAt": "2022-02-07T23:55:07Z",
              "updatedAt": "2022-02-08T00:03:07Z"
            },
            {
              "originalPosition": 49,
              "body": "Do we want 0 to refer to the headers or should revealing the headers not require any action, in which case 0 would refer to the first payload?  What does BBS+ do in this regard?",
              "createdAt": "2022-02-07T23:57:02Z",
              "updatedAt": "2022-02-08T00:03:07Z"
            },
            {
              "originalPosition": 63,
              "body": "What's the X stand for?",
              "createdAt": "2022-02-07T23:58:44Z",
              "updatedAt": "2022-02-08T00:03:07Z"
            },
            {
              "originalPosition": 5,
              "body": "2nd and 4th -> second and fourth",
              "createdAt": "2022-02-08T00:01:48Z",
              "updatedAt": "2022-02-08T00:03:07Z"
            },
            {
              "originalPosition": 82,
              "body": "issuer.tld -> issuer.example",
              "createdAt": "2022-02-08T00:02:20Z",
              "updatedAt": "2022-02-08T00:03:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40Lsb2",
          "commit": {
            "abbreviatedOid": "ccfb2f0"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T03:24:03Z",
          "updatedAt": "2022-02-08T03:24:04Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "This value is \"registered\" below by this document... but the formal language to create the JPA registrations isn't in place yet so it's a bit of a chicken-or-egg at the moment :) ",
              "createdAt": "2022-02-08T03:24:03Z",
              "updatedAt": "2022-02-08T03:24:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L3-0",
          "commit": {
            "abbreviatedOid": "9ec0aaa"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:15:27Z",
          "updatedAt": "2022-02-08T05:15:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "The goal is to have the fully unrolled example as part of the JPA BBS definition with only a high level summary here in the main draft.  If there's time I might bring up this strategy on the sync tomorrow as there could definitely be a better approach.",
              "createdAt": "2022-02-08T05:15:27Z",
              "updatedAt": "2022-02-08T05:15:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L4-z",
          "commit": {
            "abbreviatedOid": "9ec0aaa"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:23:49Z",
          "updatedAt": "2022-02-08T05:23:49Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Since this first definition is based on the existing implementation, the language here is defining how to map the inputs into that software.  The revealed indices array argument _must_ start with a `0` as the first entry in this case in order to use the software correctly for a JWP.",
              "createdAt": "2022-02-08T05:23:49Z",
              "updatedAt": "2022-02-08T05:23:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L5UA",
          "commit": {
            "abbreviatedOid": "9ec0aaa"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:26:38Z",
          "updatedAt": "2022-02-08T05:26:38Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "It was just the first value I could think of that won't conflict with any future value and stands out as an indicator that it is a special \"dead end\" definition.",
              "createdAt": "2022-02-08T05:26:38Z",
              "updatedAt": "2022-02-08T05:26:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L5h-",
          "commit": {
            "abbreviatedOid": "888c632"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:28:20Z",
          "updatedAt": "2022-02-08T05:28:21Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Updated.",
              "createdAt": "2022-02-08T05:28:21Z",
              "updatedAt": "2022-02-08T05:28:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L5jM",
          "commit": {
            "abbreviatedOid": "888c632"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:28:28Z",
          "updatedAt": "2022-02-08T05:28:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Updated.",
              "createdAt": "2022-02-08T05:28:28Z",
              "updatedAt": "2022-02-08T05:28:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L5lO",
          "commit": {
            "abbreviatedOid": "888c632"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:28:44Z",
          "updatedAt": "2022-02-08T05:28:44Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Updated.",
              "createdAt": "2022-02-08T05:28:44Z",
              "updatedAt": "2022-02-08T05:28:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L5mZ",
          "commit": {
            "abbreviatedOid": "888c632"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:28:53Z",
          "updatedAt": "2022-02-08T05:28:53Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Updated.",
              "createdAt": "2022-02-08T05:28:53Z",
              "updatedAt": "2022-02-08T05:28:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L5ny",
          "commit": {
            "abbreviatedOid": "888c632"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:29:02Z",
          "updatedAt": "2022-02-08T05:29:03Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Updated.",
              "createdAt": "2022-02-08T05:29:03Z",
              "updatedAt": "2022-02-08T05:29:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L5o7",
          "commit": {
            "abbreviatedOid": "888c632"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:29:10Z",
          "updatedAt": "2022-02-08T05:29:11Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Updated.",
              "createdAt": "2022-02-08T05:29:10Z",
              "updatedAt": "2022-02-08T05:29:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L5qE",
          "commit": {
            "abbreviatedOid": "888c632"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:29:19Z",
          "updatedAt": "2022-02-08T05:29:20Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Updated.",
              "createdAt": "2022-02-08T05:29:19Z",
              "updatedAt": "2022-02-08T05:29:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40L5rL",
          "commit": {
            "abbreviatedOid": "888c632"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-08T05:29:26Z",
          "updatedAt": "2022-02-08T05:29:27Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Updated.",
              "createdAt": "2022-02-08T05:29:26Z",
              "updatedAt": "2022-02-08T05:29:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc40OwdW",
          "commit": {
            "abbreviatedOid": "888c632"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-08T16:12:30Z",
          "updatedAt": "2022-02-08T16:12:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "PR_kwDOFsQObc4zTjQq",
      "title": "[WIP] Presentation header",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/45",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-22T19:40:34Z",
      "updatedAt": "2022-03-03T16:55:34Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "22e4f7515acbf11d9b9da040ca110e5512e89a33",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "presentation_header",
      "headRefOid": "316cd555bc6fae5a8b2ad064fd23e3c2f9f4bc3c",
      "closedAt": "2022-03-03T16:55:28Z",
      "mergedAt": "2022-03-03T16:55:27Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "d6e4e1d9142f26560e4ae764247e3d1c195d4d8b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc41EL2S",
          "commit": {
            "abbreviatedOid": "08b0408"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-22T19:51:52Z",
          "updatedAt": "2022-02-22T19:51:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "this is the key change, I think its heading the right direction.",
              "createdAt": "2022-02-22T19:51:52Z",
              "updatedAt": "2022-02-22T19:52:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc41JEM3",
          "commit": {
            "abbreviatedOid": "08b0408"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Please address the nits in this review, then merge!",
          "createdAt": "2022-02-23T19:19:26Z",
          "updatedAt": "2022-02-23T19:29:27Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "\"statement\" reads oddly.  Please change it back to \"token\".",
              "createdAt": "2022-02-23T19:19:26Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            },
            {
              "originalPosition": 34,
              "body": "used from and defined by -> used as defined by (twice)",
              "createdAt": "2022-02-23T19:20:27Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            },
            {
              "originalPosition": 48,
              "body": "algorithm specific -> algorithm-specific",
              "createdAt": "2022-02-23T19:22:28Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            },
            {
              "originalPosition": 52,
              "body": "results -> result\r\nAdd commas around \"upon receiving a signed JWP\".",
              "createdAt": "2022-02-23T19:23:31Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            },
            {
              "originalPosition": 55,
              "body": "Add a comma after \"disclosed payloads\".",
              "createdAt": "2022-02-23T19:25:23Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            },
            {
              "originalPosition": 57,
              "body": "protected -> provided",
              "createdAt": "2022-02-23T19:25:53Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            },
            {
              "originalPosition": 64,
              "body": "Add a comma after \"integrity protected headers\".",
              "createdAt": "2022-02-23T19:26:38Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            },
            {
              "originalPosition": 66,
              "body": ", -> ;\r\nwho's -> for which the",
              "createdAt": "2022-02-23T19:27:19Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            },
            {
              "originalPosition": 68,
              "body": "Add a comma after \"Internally\".\r\nBreak the last sentence into two sentences at the comma.",
              "createdAt": "2022-02-23T19:28:24Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            },
            {
              "originalPosition": 70,
              "body": "Add a comma after \"presented\".",
              "createdAt": "2022-02-23T19:29:01Z",
              "updatedAt": "2022-02-23T19:29:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc41YN28",
          "commit": {
            "abbreviatedOid": "51cd58a"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T20:05:07Z",
          "updatedAt": "2022-02-28T20:05:07Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "instead of -> in addition to",
              "createdAt": "2022-02-28T20:05:07Z",
              "updatedAt": "2022-02-28T20:05:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc41Y7OW",
          "commit": {
            "abbreviatedOid": "51cd58a"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-03-01T00:11:34Z",
          "updatedAt": "2022-03-01T00:13:53Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Would love to suggest better words than 'validate' and 'verify' - perhaps verify becomes 'confirm' a presentation?",
              "createdAt": "2022-03-01T00:11:34Z",
              "updatedAt": "2022-03-01T00:13:53Z"
            },
            {
              "originalPosition": 126,
              "body": "Should this be 'bound to the holder it was presented by'?",
              "createdAt": "2022-03-01T00:12:38Z",
              "updatedAt": "2022-03-01T00:13:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc41dw0q",
          "commit": {
            "abbreviatedOid": "689e2b7"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T01:11:48Z",
          "updatedAt": "2022-03-02T01:11:49Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "s/validate/confirm/",
              "createdAt": "2022-03-02T01:11:49Z",
              "updatedAt": "2022-03-02T01:11:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc41jHlq",
          "commit": {
            "abbreviatedOid": "316cd55"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-03T03:01:25Z",
          "updatedAt": "2022-03-03T03:01:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDOFsQObc40H6Jf",
      "title": "VC language normalization and presentation header support",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/46",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates the JPA draft to align with the updated language and terms in the main JWP draft as well as adds support for the presentation header to the SU and BBS algorithms.\r\n\r\nIt does NOT update the examples (yet), that is coming in a separate PR.",
      "createdAt": "2022-03-08T18:52:41Z",
      "updatedAt": "2022-03-14T21:36:56Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "d6e4e1d9142f26560e4ae764247e3d1c195d4d8b",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "presentation_su",
      "headRefOid": "c50368412ce9ad5035a574c0a5860e3adbc7cc49",
      "closedAt": "2022-03-14T21:36:53Z",
      "mergedAt": "2022-03-14T21:36:53Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "26fab27da74cee33f921438ee0a5f58257c62319"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc412gaW",
          "commit": {
            "abbreviatedOid": "c503684"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-08T19:27:09Z",
          "updatedAt": "2022-03-08T19:27:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc412jD_",
          "commit": {
            "abbreviatedOid": "c503684"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-08T19:37:32Z",
          "updatedAt": "2022-03-08T19:37:32Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "+1 to this language.",
              "createdAt": "2022-03-08T19:37:32Z",
              "updatedAt": "2022-03-08T19:37:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc412jMX",
          "commit": {
            "abbreviatedOid": "c503684"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-08T19:38:02Z",
          "updatedAt": "2022-03-08T19:38:03Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "+1 to this.",
              "createdAt": "2022-03-08T19:38:02Z",
              "updatedAt": "2022-03-08T19:38:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc412jf7",
          "commit": {
            "abbreviatedOid": "c503684"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-08T19:39:13Z",
          "updatedAt": "2022-03-08T19:39:14Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "hmm, i think `jwk` is already  a registered term for header use... I wonder if we need the proof prefix.",
              "createdAt": "2022-03-08T19:39:13Z",
              "updatedAt": "2022-03-08T19:39:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc412jmV",
          "commit": {
            "abbreviatedOid": "c503684"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-08T19:39:37Z",
          "updatedAt": "2022-03-08T19:39:38Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "ahh I see the reason to disambiguate here..",
              "createdAt": "2022-03-08T19:39:38Z",
              "updatedAt": "2022-03-08T19:39:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc412kb0",
          "commit": {
            "abbreviatedOid": "c503684"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-08T19:42:50Z",
          "updatedAt": "2022-03-08T19:42:50Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "i like this language change.",
              "createdAt": "2022-03-08T19:42:50Z",
              "updatedAt": "2022-03-08T19:42:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc412kdW",
          "commit": {
            "abbreviatedOid": "c503684"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-08T19:42:56Z",
          "updatedAt": "2022-03-08T19:42:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4128YR",
          "commit": {
            "abbreviatedOid": "c503684"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks like a good set of improvements to me.  Ship it!",
          "createdAt": "2022-03-08T21:18:15Z",
          "updatedAt": "2022-03-08T21:18:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOFsQObc401In_",
      "title": "Examples Tooling",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/47",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This imports some code that generates real fixtures for the many example blocks in the various drafts.  It allows some simple automation of updating the numerous places that are impacted by small changes to the underling sample data.",
      "createdAt": "2022-03-22T17:58:43Z",
      "updatedAt": "2022-04-11T02:43:29Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "26fab27da74cee33f921438ee0a5f58257c62319",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "examples_tooling",
      "headRefOid": "e8ae8c6239a4e66d284c0f93bfa47a3fffe15054",
      "closedAt": "2022-04-11T02:42:00Z",
      "mergedAt": "2022-04-11T02:42:00Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "6efee849a816c270785f58734990f4c02e185d5d"
      },
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now ready for review.  It's almost entirely code, json, and the impacted updated fixtures.  Plus some additional minor editorial fixes found in the process.",
          "createdAt": "2022-04-05T03:40:50Z",
          "updatedAt": "2022-04-05T03:40:50Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "love the code integration",
          "createdAt": "2022-04-05T18:38:01Z",
          "updatedAt": "2022-04-05T18:38:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc43kn4X",
          "commit": {
            "abbreviatedOid": "e8ae8c6"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-05T18:37:43Z",
          "updatedAt": "2022-04-05T18:37:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc43lTKF",
          "commit": {
            "abbreviatedOid": "e8ae8c6"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-05T21:16:47Z",
          "updatedAt": "2022-04-05T21:16:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "PR_kwDOFsQObc42cZ7d",
      "title": "[WIP] Salted Hash Algorithm (MAC)",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/48",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is still a work-in-progress.\r\n\r\nAdding a Salted Hash (SH) JPA that works similarly to the Single Use algorithm but uses salts and hashes instead of an ephemeral key-pair.  It will be more efficient on compute, but could result in larger proof values depending on the number of payloads and selective disclosure.\r\n\r\nIt works similarly to the salted hash technique used by ISO 18013-5 for selective release.",
      "createdAt": "2022-04-19T18:28:47Z",
      "updatedAt": "2022-06-12T21:32:34Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "6efee849a816c270785f58734990f4c02e185d5d",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "sh_alg",
      "headRefOid": "52fbc9c9acd0c69bfa1422e8d2d43d67548033a6",
      "closedAt": "2022-06-12T21:32:31Z",
      "mergedAt": "2022-06-12T21:32:31Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "1603f1fe4d5aad24fe3feb3fc3f2f022a4405fe9"
      },
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "It might be useful to consider stronger digest derivation functions (e.g., PBKDF2, or the more recent password hashing algs), to prevent offline brute force attacks from sophisticated attackers. I'm [exploring](https://github.com/christianpaquin/selective-disclosure) adding selective-disclosure directly into JWT, and playing around with the concept made me realize this would be needed for generic credentials.",
          "createdAt": "2022-04-23T15:14:01Z",
          "updatedAt": "2022-04-23T15:14:01Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "body": "> It might be useful to consider stronger digest derivation functions (e.g., PBKDF2, or the more recent password hashing algs), to prevent offline brute force attacks from sophisticated attackers.\r\n\r\nAs long as we can require the issuer generate a sufficiently large shared secret from a trusted RNG, I don't believe a stronger derivation function is needed.",
          "createdAt": "2022-04-25T04:17:00Z",
          "updatedAt": "2022-04-25T04:17:00Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "> As long as we can require the issuer generate a sufficiently large shared secret from a trusted RNG, I don't believe a stronger derivation function is needed.\r\n\r\nAh, I see you are using full-size 256-bit salts; yes, indeed that should be strong enough.",
          "createdAt": "2022-04-25T14:50:37Z",
          "updatedAt": "2022-04-25T14:50:37Z"
        },
        {
          "author": "Sakurann",
          "authorAssociation": "NONE",
          "body": "Is there a plan to add an example and probably give a little bit more detailed overview in the beginning..?",
          "createdAt": "2022-05-03T18:27:08Z",
          "updatedAt": "2022-05-03T18:27:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc44ZQkC",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "this is awesome... I love the dependencies... only JOSE.",
          "createdAt": "2022-04-19T18:42:18Z",
          "updatedAt": "2022-04-19T18:42:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc44Z8wM",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "tplooker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T21:40:01Z",
          "updatedAt": "2022-04-19T21:40:01Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Suggest we call it Salted Hash as its not the HMAC being salted more the source of where the salt comes from?",
              "createdAt": "2022-04-19T21:40:01Z",
              "updatedAt": "2022-04-19T21:40:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44Z9Gb",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "tplooker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T21:41:49Z",
          "updatedAt": "2022-04-19T21:41:50Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "We discussed whether to seperate out two algorithm registrations here one that features holder binding the other does not. Im assuming by this text you would rather collapse this into one and just require implementers to validate the presence of this claim to detect whether it is a holder bound version? ",
              "createdAt": "2022-04-19T21:41:49Z",
              "updatedAt": "2022-04-19T21:41:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44Z9SL",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "tplooker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T21:42:51Z",
          "updatedAt": "2022-04-19T21:42:51Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I wonder if we should not salt the issuer header instead just the payloads? as the header will never not be disclosed so no need to salt it?",
              "createdAt": "2022-04-19T21:42:51Z",
              "updatedAt": "2022-04-19T21:42:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44Z9d6",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "tplooker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T21:43:47Z",
          "updatedAt": "2022-04-19T21:43:48Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Also I'd refer to the HMAC key as a randomly generated value that is just shared with the holder and used to re-derive the required salts for payloads the holder wishes to disclose in a presentation",
              "createdAt": "2022-04-19T21:43:48Z",
              "updatedAt": "2022-04-19T21:43:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44aAD5",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T21:58:16Z",
          "updatedAt": "2022-04-19T21:58:17Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "The salt is also then used as the key to HMAC each payload, so Salted HMAC is probably still appropriate :)\r\n\r\nThat said, I'm thinking we should just name this MAC-* instead, since that's the core operation used to both generate the salts and hash/verify the payloads.\r\n\r\nThis way it's obvious it can support [KMAC](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf) also.",
              "createdAt": "2022-04-19T21:58:16Z",
              "updatedAt": "2022-04-19T21:58:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44aBdw",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T22:06:36Z",
          "updatedAt": "2022-04-19T22:06:37Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I'm just starting with the stronger holder-bound version.\r\n\r\nI really don't want to create a JPA that lacks support for binding or replay protection if we don't have to.  The argument is the same as alg:\"none\", that it's useful when the channel or context provides the protections, but if we can avoid that here then we minimize the chance for people to implement or use it incorrectly.",
              "createdAt": "2022-04-19T22:06:37Z",
              "updatedAt": "2022-04-19T22:06:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44aCnf",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T22:13:53Z",
          "updatedAt": "2022-04-19T22:13:53Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I find the consistent treatment of the issuer header much more preferable from a security perspective.  The octet sequence that the issuer signs needs to be a uniform array-of-MACs so that it doesn't internally require any separator tags.\r\n\r\nWe could perhaps use the array of just the payload MACs as the key to MAC the issuer header, then the holder won't need to include its salt in the presentation proof and save another 32 or 64 bytes (depending on which MAC)?",
              "createdAt": "2022-04-19T22:13:53Z",
              "updatedAt": "2022-04-19T22:13:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44aRqR",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "tplooker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T23:09:13Z",
          "updatedAt": "2022-04-19T23:09:14Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Just a note as we have already discussed this out of band, I think its probably sufficient to just HASH each payload with the salt appended rather than a formal HMAC which will save one less HASH operation per payload signed. Would be interested in benchmarking whether there is any actual performance gained or lost between these two approaches though",
              "createdAt": "2022-04-19T23:09:14Z",
              "updatedAt": "2022-04-19T23:09:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44aTGm",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "tplooker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T23:12:31Z",
          "updatedAt": "2022-04-19T23:12:32Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "To me this is related to the conversation we have been having in https://github.com/decentralized-identity/bbs-signature/issues/102 which boils down to whether you want a cryptographically enforce-able seperation between information that is always required to be revealed vs information that is suppose to be selectively disclosed by the holder. If you opt for the former then it makes sense to treat the header differently at the cryptographic layer.",
              "createdAt": "2022-04-19T23:12:32Z",
              "updatedAt": "2022-04-19T23:12:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44Z2RV",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-19T21:09:00Z",
          "updatedAt": "2022-04-19T23:21:40Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Why use HMAC to calculate the payload digests, vs. H(payload, salt)? Better preimage brute force resistance?",
              "createdAt": "2022-04-19T21:09:00Z",
              "updatedAt": "2022-04-19T23:21:40Z"
            },
            {
              "originalPosition": 51,
              "body": "If anything, you might want to rename the payload salts to payload keys (or something similar) if sticking with HMAC, just to avoid confusion.",
              "createdAt": "2022-04-19T23:15:01Z",
              "updatedAt": "2022-04-19T23:21:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44s9gM",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-25T03:17:39Z",
          "updatedAt": "2022-04-25T03:17:39Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I just pushed an update renaming this to just the MAC algorithm, such that it can be used with any standardized MAC algorithm such as HMAC, KMAC, or even a simple hash(salt . payload) one should we desire.",
              "createdAt": "2022-04-25T03:17:39Z",
              "updatedAt": "2022-04-25T03:17:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44s_R-",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-25T03:38:41Z",
          "updatedAt": "2022-04-25T03:38:42Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "The difference in my mind with JWP is that as a container spec it requires that the headers are always disclosed, the underlying algorithms don't need to provide the enforcement, JWP implementations will always do that.\r\n\r\nIt's more nuanced for BBS though as it can be used in many other applications without a spec to enforce it :)",
              "createdAt": "2022-04-25T03:38:41Z",
              "updatedAt": "2022-04-25T03:38:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44tBmz",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-25T04:07:21Z",
          "updatedAt": "2022-04-25T04:07:21Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "@christianpaquin great point, I updated the language to use keys instead of salts.",
              "createdAt": "2022-04-25T04:07:21Z",
              "updatedAt": "2022-04-25T04:07:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44tCB5",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-25T04:12:07Z",
          "updatedAt": "2022-04-25T04:12:08Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "It's less invention, and since what we're actually doing for each payload is generating an authentication code I'd like to support any existing safe MAC.",
              "createdAt": "2022-04-25T04:12:07Z",
              "updatedAt": "2022-04-25T04:12:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44wV85",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "tplooker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-25T17:08:26Z",
          "updatedAt": "2022-04-25T17:08:26Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Yeah thats true, if you are intending on the crypto algorithm being used in a way that it is never expected to be used across an application context then I suppose this risk is mitigated, not entirely ruled out but mitigated. Although I still think handling the header differently (e.g just HASH rather than HMAC) would be worthwhile even just for reducing implementation complexity. With the current approach aren't you always required to reveal a salt/key for the header alongside any payloads?",
              "createdAt": "2022-04-25T17:08:26Z",
              "updatedAt": "2022-04-25T17:08:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44wkGK",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-25T17:59:55Z",
          "updatedAt": "2022-04-25T17:59:55Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "> Although I still think handling the header differently (e.g just HASH rather than HMAC) would be worthwhile even just for reducing implementation complexity. \r\n\r\nAs a programmer I would agree, but with a standards hat on I definitely lean the other way: introducing another cryptographic primitive adds notable complexity to the spec, even if the MAC is based on a hash it's still a distinct primitive with different security assumptions.\r\n\r\n> With the current approach aren't you always required to reveal a salt/key for the header alongside any payloads?\r\n\r\nAs currently defined yes, but we could eliminate that by using a fixed/spec-defined key to MAC the header, I can update the draft if that sounds reasonable?",
              "createdAt": "2022-04-25T17:59:55Z",
              "updatedAt": "2022-04-25T17:59:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc44xg8D",
          "commit": {
            "abbreviatedOid": "262b25c"
          },
          "author": "tplooker",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-25T22:11:01Z",
          "updatedAt": "2022-04-25T22:11:01Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "> As currently defined yes, but we could eliminate that by using a fixed/spec-defined key to MAC the header, I can update the draft if that sounds reasonable?\r\n\r\nYes I think I that would be a good improvement and strike a better balance! Keeps the scheme simple from a primative perspective but also doesn't induce the need to manage a random salt for the header where there is no need for it to be random",
              "createdAt": "2022-04-25T22:11:01Z",
              "updatedAt": "2022-04-25T22:11:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc45QyqT",
          "commit": {
            "abbreviatedOid": "d006a5a"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is a great addition to the specs.  Thanks for doing this!",
          "createdAt": "2022-05-03T17:06:17Z",
          "updatedAt": "2022-05-03T17:06:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc46U4se",
          "commit": {
            "abbreviatedOid": "9bbc396"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T13:16:00Z",
          "updatedAt": "2022-05-19T13:16:00Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "\"the correct fixed header with\" ? not sure abut this language, could be clear.",
              "createdAt": "2022-05-19T13:16:00Z",
              "updatedAt": "2022-05-19T13:16:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc46WZPi",
          "commit": {
            "abbreviatedOid": "9bbc396"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T17:14:53Z",
          "updatedAt": "2022-05-19T17:14:53Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Good eye! I literally felt the hesitation as I was typing it that I needed to explain that better, but I pushed on just to get the larger body all written first.\r\n\r\nI'll circle back and make another pass, but I don't expect it to be perfect in this PR as there's a few larger editorial/cleanup ones that will be fast following it.",
              "createdAt": "2022-05-19T17:14:53Z",
              "updatedAt": "2022-05-19T17:14:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOFsQObc43TKTR",
      "title": "[WIP] IETF BOF Request",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/51",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Will be submitted at https://datatracker.ietf.org/doc/bof-requests when ready for https://www.ietf.org/how/meetings/114/",
      "createdAt": "2022-05-04T15:31:07Z",
      "updatedAt": "2022-05-31T18:24:57Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "6efee849a816c270785f58734990f4c02e185d5d",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "bof_request",
      "headRefOid": "c8e92eb66d69e937437612668c15d9cfa9215326",
      "closedAt": "2022-05-12T16:26:55Z",
      "mergedAt": "2022-05-12T16:26:55Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "7ce8059cbac95e074428ab3365c42d1343076b44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc454oKz",
          "commit": {
            "abbreviatedOid": "c8e92eb"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Please merge.  I want to create a PR against it containing minor tweaks.",
          "createdAt": "2022-05-12T16:25:56Z",
          "updatedAt": "2022-05-12T16:25:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDOFsQObc43vMuo",
      "title": "Mike's suggestions to the BoF text",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/52",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Feel free to send the BoF proposal to the IESG after merging this!  Thanks for getting us there!",
      "createdAt": "2022-05-12T17:57:38Z",
      "updatedAt": "2022-05-12T22:57:38Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "7ce8059cbac95e074428ab3365c42d1343076b44",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-bof-suggestions",
      "headRefOid": "4699de27a56b3e83182eced69d812081547de3ff",
      "closedAt": "2022-05-12T22:57:38Z",
      "mergedAt": "2022-05-12T22:57:38Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "3ff316813bc564bdea012784c11ac917e354398f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc456HNz",
          "commit": {
            "abbreviatedOid": "4699de2"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-12T22:57:27Z",
          "updatedAt": "2022-05-12T22:57:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDOFsQObc45hmAq",
      "title": "Adding editors notes and cleanups",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/58",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just some helpful notes for those that might be reading a draft directly.\r\n\r\nAlso fixed some language that closes #27 in the JPT draft.",
      "createdAt": "2022-06-12T22:54:56Z",
      "updatedAt": "2022-07-11T23:36:14Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "1603f1fe4d5aad24fe3feb3fc3f2f022a4405fe9",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "editor_notes",
      "headRefOid": "fa6e311af7ba4641879d265aba42e9d06fb40ee0",
      "closedAt": "2022-07-11T23:36:11Z",
      "mergedAt": "2022-07-11T23:36:11Z",
      "mergedBy": "quartzjer",
      "mergeCommit": {
        "oid": "c7fc769a833065944d89c6c41dc05058a35019b0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOFsQObc45x_BK",
      "title": "update charter-ietf-jose-03",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/60",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This update makes it so that the proposed charter does not restrict adopting new algorithms solely for the purpose of JWPs\n",
      "createdAt": "2022-06-16T14:34:35Z",
      "updatedAt": "2022-07-24T16:44:26Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "1603f1fe4d5aad24fe3feb3fc3f2f022a4405fe9",
      "headRepository": null,
      "headRefName": "charter",
      "headRefOid": "baabb96785f1bb4d1eb08a69d526df2b2a4134fe",
      "closedAt": "2022-07-24T16:44:26Z",
      "mergedAt": "2022-07-24T16:44:26Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "dbd64e6c0e0509abf8da11736f9ffcf65b427e33"
      },
      "comments": [
        {
          "author": "panva",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc @selfissued ",
          "createdAt": "2022-06-16T14:35:30Z",
          "updatedAt": "2022-06-16T14:35:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4-U4Xk",
          "commit": {
            "abbreviatedOid": "baabb96"
          },
          "author": "Sakurann",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-20T20:50:06Z",
          "updatedAt": "2022-07-20T20:50:12Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I would keep the original text.",
              "createdAt": "2022-07-20T20:50:06Z",
              "updatedAt": "2022-07-20T20:50:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4-U5hJ",
          "commit": {
            "abbreviatedOid": "baabb96"
          },
          "author": "panva",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-20T20:54:50Z",
          "updatedAt": "2022-07-20T20:54:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Why? There's a backlog of algorithms that do not fall within \"needed for JWPs\".",
              "createdAt": "2022-07-20T20:54:50Z",
              "updatedAt": "2022-07-20T20:54:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc4-gVvP",
          "commit": {
            "abbreviatedOid": "baabb96"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "We'd discussed this during a Connect call and agreed that there's a need to register new algorithm identifiers for algorithms used with JWS and JWE.  Therefore, it makes sense to broaden the charter language as done in this PR.",
          "createdAt": "2022-07-24T16:44:09Z",
          "updatedAt": "2022-07-24T16:44:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "PR_kwDOFsQObc47OmXD",
      "title": "lots of fixing for draft publishing",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/61",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-11T23:56:47Z",
      "updatedAt": "2024-02-28T07:22:52Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "c7fc769a833065944d89c6c41dc05058a35019b0",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "linelen-force",
      "headRefOid": "44ebcd68ecde40bdc6ddb45bceefeddb2e99daad",
      "closedAt": "2022-07-25T00:54:50Z",
      "mergedAt": "2022-07-25T00:54:50Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "17a5108961a087ff7ef6559719adf3583d98571b"
      },
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "With the docname fix, LGTM",
          "createdAt": "2022-07-24T05:35:41Z",
          "updatedAt": "2022-07-24T05:35:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc4-U4MM",
          "commit": {
            "abbreviatedOid": "51a08ab"
          },
          "author": "Sakurann",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-20T20:49:21Z",
          "updatedAt": "2022-07-20T20:49:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4-f760",
          "commit": {
            "abbreviatedOid": "886b423"
          },
          "author": "Sakurann",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-23T18:21:39Z",
          "updatedAt": "2022-07-23T18:21:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4-gEB1",
          "commit": {
            "abbreviatedOid": "44ebcd6"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-24T05:36:42Z",
          "updatedAt": "2022-07-24T05:36:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc4-gieq",
          "commit": {
            "abbreviatedOid": "44ebcd6"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Used to build the released IETF draft-jmiller-jose-*-00 versions.",
          "createdAt": "2022-07-25T00:54:38Z",
          "updatedAt": "2022-07-25T00:54:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOFsQObc5Ag_dF",
      "title": "Make working group name TBD",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/62",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also state that we'll be coordinating with the OAuth SD-JWT work.",
      "createdAt": "2022-10-10T18:45:43Z",
      "updatedAt": "2022-10-10T22:05:49Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "17a5108961a087ff7ef6559719adf3583d98571b",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-charter-wg-name-tbd",
      "headRefOid": "f95762ee428a5440ea271e665ca7dc7f2d052232",
      "closedAt": "2022-10-10T22:05:49Z",
      "mergedAt": "2022-10-10T22:05:49Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "8420e04caaa68ac2c6829958ceb500ad0e57c820"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5DvHFF",
          "commit": {
            "abbreviatedOid": "f236d12"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-10T18:55:40Z",
          "updatedAt": "2022-10-10T18:55:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOFsQObc5Ar529",
      "title": "Charter edits requested at the 12-Oct-22 Virtual Interim BoF",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/63",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-12T21:41:45Z",
      "updatedAt": "2022-10-12T22:05:05Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "8420e04caaa68ac2c6829958ceb500ad0e57c820",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-edits-requested-at-virtual-interim-bof",
      "headRefOid": "8ce0ac473498dc82b05caa65b63d8d284f1154c9",
      "closedAt": "2022-10-12T22:05:05Z",
      "mergedAt": "2022-10-12T22:05:05Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "c569de06b2a24695ed7fb9806bd3982cbe185536"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5D73VM",
          "commit": {
            "abbreviatedOid": "8ce0ac4"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-12T21:57:54Z",
          "updatedAt": "2022-10-12T21:57:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOFsQObc5LnNGV",
      "title": "Mike's edits for individual -01 drafts",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/64",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-08T22:43:55Z",
      "updatedAt": "2023-03-08T23:09:38Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "c569de06b2a24695ed7fb9806bd3982cbe185536",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-edits-for-individual-01-drafts",
      "headRefOid": "a17d0b52c02482ce58ffea117c8ea5c8003b5255",
      "closedAt": "2023-03-08T23:09:37Z",
      "mergedAt": "2023-03-08T23:09:37Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "f40b144453ff140bb4d87b1ef98069d99d02eff1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5PX2mP",
          "commit": {
            "abbreviatedOid": "a17d0b5"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-08T23:07:43Z",
          "updatedAt": "2023-03-08T23:07:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOFsQObc5O0syo",
      "title": "Rename initial submissions",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/66",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-04-21T04:32:26Z",
      "updatedAt": "2024-03-04T22:21:21Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "f40b144453ff140bb4d87b1ef98069d99d02eff1",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "initial-wg",
      "headRefOid": "f2dc218e30587d29b8cbfcb0d9a68328bd2f180a",
      "closedAt": "2023-04-21T17:51:52Z",
      "mergedAt": "2023-04-21T17:51:52Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "f3bc2a0fbf62b87adba5f61cf82a88d10b61f15b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5TN_n0",
          "commit": {
            "abbreviatedOid": "f2dc218"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, DW.  LGTM!",
          "createdAt": "2023-04-21T17:42:09Z",
          "updatedAt": "2023-04-21T17:42:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOFsQObc5O4gUK",
      "title": "Mike's edits for working group -00 drafts",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/67",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I believe that after this is merged, we can publish.",
      "createdAt": "2023-04-21T18:15:03Z",
      "updatedAt": "2023-04-21T21:16:05Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "f3bc2a0fbf62b87adba5f61cf82a88d10b61f15b",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-00-edits",
      "headRefOid": "f1d0907318a1364760d8216f91c20ea99a02a68a",
      "closedAt": "2023-04-21T21:16:04Z",
      "mergedAt": "2023-04-21T21:16:04Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "a2d6cf1fd25e91c0733b6f2d52237abcc009c430"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5TO3hH",
          "commit": {
            "abbreviatedOid": "f1d0907"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2023-04-21T21:15:54Z",
          "updatedAt": "2023-04-21T21:15:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 68,
      "id": "PR_kwDOFsQObc5O7u0D",
      "title": "Modify README.md",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/68",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a merger of the generated README from the (upgraded) internet draft tools bot, and the previous content.",
      "createdAt": "2023-04-23T07:35:18Z",
      "updatedAt": "2024-02-28T07:22:35Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "d6502b8e58b29ab2186c030def655f9d198cd4d7",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "dwaite-merge-generated-readme",
      "headRefOid": "656afd59819e888c01b164a09159741e0296cad2",
      "closedAt": "2023-04-26T20:49:23Z",
      "mergedAt": "2023-04-26T20:49:23Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "6a8df7073dadf417b73046cf7810db85f2390d32"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5TnOtp",
          "commit": {
            "abbreviatedOid": "656afd5"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-26T20:46:24Z",
          "updatedAt": "2023-04-26T20:46:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOFsQObc5PPMDb",
      "title": "Adding myself as an author",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/69",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "JPT",
        "JPA"
      ],
      "body": "A commit to add myself as an author to the other two documents - I was only listed in the base JWP spec.\r\n\r\nI suspect this is hitting a sanity check and preventing me from uploading these two -00 docs.",
      "createdAt": "2023-04-26T21:02:49Z",
      "updatedAt": "2023-04-26T21:04:34Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "6a8df7073dadf417b73046cf7810db85f2390d32",
      "headRepository": "dwaite/json-web-proofs",
      "headRefName": "add-dwaite-author",
      "headRefOid": "440c7486e8bbc67c5bf006c259a1a377dff5dcf3",
      "closedAt": "2023-04-26T21:04:34Z",
      "mergedAt": "2023-04-26T21:04:34Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "e5fd209b0c8e197fdf480aedb2b0c7df8e248fad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5TnVfx",
          "commit": {
            "abbreviatedOid": "440c748"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-26T21:03:59Z",
          "updatedAt": "2023-04-26T21:03:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOFsQObc5VIxKb",
      "title": "Move to reference the internet draft of BBS",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/72",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update to point to BBS. Note that this does not specify a specific version in the hope that draft 3 is published this afternoon.",
      "createdAt": "2023-07-10T22:45:37Z",
      "updatedAt": "2023-07-10T22:55:42Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "e5fd209b0c8e197fdf480aedb2b0c7df8e248fad",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "bbs-update",
      "headRefOid": "b50d42216bda077c0cd2e819dc39342448f46b70",
      "closedAt": "2023-07-10T22:55:37Z",
      "mergedAt": "2023-07-10T22:55:37Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "14b5770efe28f858dace0407e9c162266ed84173"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5ayXCr",
          "commit": {
            "abbreviatedOid": "b50d422"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T22:55:12Z",
          "updatedAt": "2023-07-10T22:55:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOFsQObc5VIzc7",
      "title": "Minor improvements",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/73",
      "state": "MERGED",
      "author": "quartzjer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just getting a few small things in before the IETF meeting cutoff.\r\n\r\n(based on [suggestions](https://mailarchive.ietf.org/arch/msg/jose/GkL3I9hEoKjaIDCgno_rYqQsSP0/) from @OR13)\r\n",
      "createdAt": "2023-07-10T22:53:29Z",
      "updatedAt": "2023-07-10T23:06:00Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "e5fd209b0c8e197fdf480aedb2b0c7df8e248fad",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jer-draft-minor",
      "headRefOid": "bb323cb74d2078a59135fe33bb98e7701933905a",
      "closedAt": "2023-07-10T23:05:07Z",
      "mergedAt": "2023-07-10T23:05:07Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "65bac90b0f9fb74f49ef9037f368cba986bcfdc6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5ayWz9",
          "commit": {
            "abbreviatedOid": "bb323cb"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T22:53:58Z",
          "updatedAt": "2023-07-10T22:53:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5ayYzO",
          "commit": {
            "abbreviatedOid": "bb323cb"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T23:04:46Z",
          "updatedAt": "2023-07-10T23:04:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOFsQObc5VI5u7",
      "title": "reference the current JWP I-D and HMAC RFC using citation syntax",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/74",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-10T23:17:20Z",
      "updatedAt": "2024-02-28T07:22:32Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "65bac90b0f9fb74f49ef9037f368cba986bcfdc6",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "update-references",
      "headRefOid": "8466fd5705c434319efcbefad21c296af08bed30",
      "closedAt": "2023-07-10T23:20:02Z",
      "mergedAt": "2023-07-10T23:20:02Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "431b98af23311123d81a38a5d791ebfd10912c03"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5ayb0-",
          "commit": {
            "abbreviatedOid": "8466fd5"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T23:19:40Z",
          "updatedAt": "2023-07-10T23:19:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOFsQObc5WJvt6",
      "title": "clarify JPT 'cid' sentence and add example",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/79",
      "state": "MERGED",
      "author": "brentzundel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes #71 by clarifying a sentence. It also adds an example with a `cid` value.",
      "createdAt": "2023-07-22T18:53:44Z",
      "updatedAt": "2023-10-21T17:35:18Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "431b98af23311123d81a38a5d791ebfd10912c03",
      "headRepository": "brentzundel/json-web-proofs",
      "headRefName": "issue-71",
      "headRefOid": "60b966a536062e9fee5400c634422e94ede673c6",
      "closedAt": "2023-10-21T17:35:18Z",
      "mergedAt": "2023-10-21T17:35:18Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "b0fd775c9509776afec5a7e27692c9f884898c35"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5cDYZ7",
          "commit": {
            "abbreviatedOid": "60b966a"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-07-24T22:47:55Z",
          "updatedAt": "2023-07-24T22:47:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5kz0Z6",
          "commit": {
            "abbreviatedOid": "60b966a"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-21T17:34:55Z",
          "updatedAt": "2023-10-21T17:34:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDOFsQObc5WJvxl",
      "title": "add .idea to .gitignore",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/80",
      "state": "MERGED",
      "author": "brentzundel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "this PR add the string `.idea` to the .gitignore file so that users of JetBrains IDEs won't be prompted to include their local settings in PRs.",
      "createdAt": "2023-07-22T18:55:04Z",
      "updatedAt": "2023-07-24T22:45:40Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "431b98af23311123d81a38a5d791ebfd10912c03",
      "headRepository": "brentzundel/json-web-proofs",
      "headRefName": "gitignore",
      "headRefOid": "cde98a5720aa3101edf149cf1da9e630f755c913",
      "closedAt": "2023-07-24T22:45:40Z",
      "mergedAt": "2023-07-24T22:45:40Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "43eb204be581d59e6df8e387ba509f43280f83ed"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5cDX51",
          "commit": {
            "abbreviatedOid": "cde98a5"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-07-24T22:45:22Z",
          "updatedAt": "2023-07-24T22:45:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOFsQObc5WJwE6",
      "title": "clarify use of issuer proof",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/81",
      "state": "MERGED",
      "author": "brentzundel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes #70 by rewording the sentence to remove the word \"only\"",
      "createdAt": "2023-07-22T19:01:50Z",
      "updatedAt": "2023-10-21T17:36:25Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "431b98af23311123d81a38a5d791ebfd10912c03",
      "headRepository": "brentzundel/json-web-proofs",
      "headRefName": "issue-70",
      "headRefOid": "dcb02774ca1426074dba646d6e89a4c86eb0bea1",
      "closedAt": "2023-10-21T17:36:25Z",
      "mergedAt": "2023-10-21T17:36:25Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "505dec28b41582819df04739a6f1a5960cd9d0a2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5cDXYK",
          "commit": {
            "abbreviatedOid": "dcb0277"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-07-24T22:42:28Z",
          "updatedAt": "2023-07-24T22:42:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5kz0fT",
          "commit": {
            "abbreviatedOid": "dcb0277"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-21T17:35:58Z",
          "updatedAt": "2023-10-21T17:35:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOFsQObc5WRwk0",
      "title": "Add missing document history subsections",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/82",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #75 ",
      "createdAt": "2023-07-24T23:12:51Z",
      "updatedAt": "2023-10-21T00:59:44Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "43eb204be581d59e6df8e387ba509f43280f83ed",
      "headRepository": "dwaite/json-web-proofs",
      "headRefName": "retroactive-change-section",
      "headRefOid": "f8d82defa4232654c82c3dfc06da1806d9b58a26",
      "closedAt": "2023-10-21T00:59:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5cvZnp",
          "commit": {
            "abbreviatedOid": "f8d82de"
          },
          "author": "brentzundel",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-31T23:09:50Z",
          "updatedAt": "2023-07-31T23:09:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 84,
      "id": "PR_kwDOFsQObc5cAh3O",
      "title": "Fixing Compact Serialization and Presentation Header Handling in BBS Algorithm Example",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/84",
      "state": "CLOSED",
      "author": "AlbertoSvg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hello Everyone,\r\n\r\nI submitted this pull request to address what I believe is an error in the [BBS algorithm example](https://datatracker.ietf.org/doc/html/draft-ietf-jose-json-proof-algorithms#name-example-2) in the JPA draft. In the provided presented JWP representation, there is only one \"protected\" header referring to the issued protected header. However, according to section [6.2.6](https://datatracker.ietf.org/doc/html/draft-ietf-jose-json-proof-algorithms#section-6.2.6) of this draft and section [4.2.1](https://datatracker.ietf.org/doc/html/draft-ietf-jose-json-web-proof#section-4.2.1) of the JWP draft, there should also be a presentation protected header containing the nonce used for the generation and verification of the proof used to present the JWP to a Verifier.\r\n\r\nAdditionally, I corrected the encoding of the protected headers during \"compact serialization.\" The header value present in the JSON representation had already undergone the UTF-8 and base64url encoding process. However, in the compact serialization, instead of taking it as it is, the header value was mistakenly enclosed in quotation marks \r\n\r\n> \"eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiY2xhaW1zIjpbImZhbWlseV9uYW1lIiwiZ2l2ZW5fbmFtZSIsImVtYWlsIiwiYWdlIl0sInR5cCI6IkpQVCIsImFsZyI6IkJCUy1YIn0\"\r\n\r\n and then base64url encoded again.\r\n\r\nAs a final step, I modified the \"fixtures_bbs-x.js\" file to handle the presentation protected header.\r\n",
      "createdAt": "2023-10-05T13:03:57Z",
      "updatedAt": "2023-10-22T01:20:29Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "d6ee024ba33d14cb173db6fc4176b7d00e4c5d8c",
      "headRepository": "Cybersecurity-LINKS/json-web-proofs",
      "headRefName": "main",
      "headRefOid": "d6ee024ba33d14cb173db6fc4176b7d00e4c5d8c",
      "closedAt": "2023-10-22T00:00:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello Alberto! I updated the BBS section to bring it current with the CFRG draft 3, along with adding infrastructure to generate a key and build examples.\r\n\r\nIf you would, might you review the current examples and see if they appear correct?",
          "createdAt": "2023-10-21T00:59:30Z",
          "updatedAt": "2023-10-21T00:59:30Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "body": "@AlbertoSvg , you can see the current editor's draft at https://json-web-proofs.github.io/json-web-proofs/draft-ietf-jose-json-proof-algorithms.html.  Please either let us know that this is OK now or update your PR as needed to address the remaining problems.\r\n\r\nNote that the submission deadline for IETF 118 is Monday, October 23rd so if you can look at this soon, that would be great.\r\n\r\nThanks for your attention to detail!",
          "createdAt": "2023-10-21T17:44:12Z",
          "updatedAt": "2023-10-21T17:44:12Z"
        },
        {
          "author": "AlbertoSvg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dwaite @selfissued, thank you for the feedback, I'll review the updates and check if everything is okay as soon as possible. Given the upcoming deadline for IETF 118, I understand the urgency and I will try my best.\r\n\r\nI would also like to mention that I am concurrently working on a Rust library implementation of these drafts. \r\nIf by chance any of you have an interest in knowing more about it, please feel free to reach out.\r\n\r\n\r\nEDIT: \r\nThis pull request has been closed since these changes were not anymore necessary. The updated changes can be found in the new pull request: [PR88](https://github.com/json-web-proofs/json-web-proofs/pull/88)",
          "createdAt": "2023-10-21T18:51:36Z",
          "updatedAt": "2023-10-22T01:20:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 85,
      "id": "PR_kwDOFsQObc5daygV",
      "title": "Bbs updates to draft 3",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/85",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update BBS text to draft 3 operations as well as update code to generate examples.\r\n\r\nNote that I am still experimenting with the best approach for line wrapping the generated examples, so there may be subsequent changes in the generation code.",
      "createdAt": "2023-10-20T20:25:11Z",
      "updatedAt": "2024-02-28T07:22:31Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "43eb204be581d59e6df8e387ba509f43280f83ed",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "bbs-updates-to-draft-3",
      "headRefOid": "3f4a604664c3f90e38beb25cc18008e3787eac2b",
      "closedAt": "2023-10-20T21:59:27Z",
      "mergedAt": "2023-10-20T21:59:27Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "22690c18cda913916ef8e1ebb994ad29ec16bad3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5kyLyd",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T20:42:07Z",
          "updatedAt": "2023-10-20T20:42:08Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n### Key Format\r\n```",
              "createdAt": "2023-10-20T20:42:07Z",
              "updatedAt": "2023-10-20T20:42:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyL_N",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T20:42:55Z",
          "updatedAt": "2023-10-20T20:42:55Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nThe key used for the `BBS-DRAFT-3` algorithm is an elliptic curve-based key pair, specifically against the G_2 subgroup of a pairing friendly curve. Additional details on key generation can be found in [@!I-D.irtf-cfrg-bbs-signatures, Section 3.3]\r\n```",
              "createdAt": "2023-10-20T20:42:55Z",
              "updatedAt": "2023-10-20T20:42:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyMPt",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T20:44:01Z",
          "updatedAt": "2023-10-20T20:44:01Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "```suggestion\r\n### Issuance Proof Verification\r\n```",
              "createdAt": "2023-10-20T20:44:01Z",
              "updatedAt": "2023-10-20T20:44:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyMy4",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T20:46:22Z",
          "updatedAt": "2023-10-20T20:46:22Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "It seems inconsistent that `PK` is capitalized and `ph` is not.  Is there a reason that we shouldn't capitalize `PH`?  Or are these identifiers from other specs, in which case we should use them as-is?",
              "createdAt": "2023-10-20T20:46:22Z",
              "updatedAt": "2023-10-20T20:46:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyNf2",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T20:48:47Z",
          "updatedAt": "2023-10-20T20:48:47Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "```suggestion\r\nFigure: Holder Presentation Header\r\n```",
              "createdAt": "2023-10-20T20:48:47Z",
              "updatedAt": "2023-10-20T20:48:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyNly",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T20:49:07Z",
          "updatedAt": "2023-10-20T20:49:07Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "```suggestion\r\n### Presentation Verification\r\n```",
              "createdAt": "2023-10-20T20:49:07Z",
              "updatedAt": "2023-10-20T20:49:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyNt8",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T20:49:38Z",
          "updatedAt": "2023-10-20T20:49:38Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "```suggestion\r\nVerification of a presentation is done by the holder using the `ProofVerify` operation from [@!I-D.irtf-cfrg-bbs-signatures, Section 3.4.4].\r\n```",
              "createdAt": "2023-10-20T20:49:38Z",
              "updatedAt": "2023-10-20T20:49:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyN1b",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T20:50:05Z",
          "updatedAt": "2023-10-20T20:50:05Z",
          "comments": [
            {
              "originalPosition": 290,
              "body": "Same comment about the inconsistent capitalization of PK and ph from above.",
              "createdAt": "2023-10-20T20:50:05Z",
              "updatedAt": "2023-10-20T20:50:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyO4z",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good.  Thanks for doing this!  Please accept my editorial suggestions before merging.\r\n\r\nAlso, please add an acknowledgement saying that the BBS examples were generated using https://github.com/mattrglobal/pairing_crypto .",
          "createdAt": "2023-10-20T20:54:16Z",
          "updatedAt": "2023-10-20T20:54:16Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5kyV9o",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T21:24:38Z",
          "updatedAt": "2023-10-20T21:24:38Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "That is the capitalization within the BBS Signatures spec",
              "createdAt": "2023-10-20T21:24:38Z",
              "updatedAt": "2023-10-20T21:24:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyWMf",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T21:25:43Z",
          "updatedAt": "2023-10-20T21:25:43Z",
          "comments": [
            {
              "originalPosition": 290,
              "body": "see above - aim was to capitalize these the same as the BBS spec",
              "createdAt": "2023-10-20T21:25:43Z",
              "updatedAt": "2023-10-20T21:25:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kyWc9",
          "commit": {
            "abbreviatedOid": "5b721cc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T21:27:03Z",
          "updatedAt": "2023-10-20T21:27:04Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "OK - then leave it that way.  Thanks.",
              "createdAt": "2023-10-20T21:27:04Z",
              "updatedAt": "2023-10-20T21:27:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOFsQObc5dba7F",
      "title": "Update BBS refs in JWP and JPT",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/86",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update references in the other two documents, as well as add entries to Changes section.",
      "createdAt": "2023-10-21T00:28:11Z",
      "updatedAt": "2024-02-28T07:22:27Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "c3780b356efc2bd8ee345cae8674d12ea4c76b3d",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "update-other-bbs-references",
      "headRefOid": "e79b958f376b1e7dc0ac5f1dc517cdf6fd05d5b5",
      "closedAt": "2023-10-21T00:45:31Z",
      "mergedAt": "2023-10-21T00:45:31Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "aeefb510b520ff32123dceae07aab2250b712240"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5kywHl",
          "commit": {
            "abbreviatedOid": "1c7f766"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-21T00:30:01Z",
          "updatedAt": "2023-10-21T00:30:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOFsQObc5dbgsu",
      "title": "Clean up references and history entries",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/87",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-21T01:09:15Z",
      "updatedAt": "2023-10-21T03:56:55Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "aeefb510b520ff32123dceae07aab2250b712240",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-clean-up-references",
      "headRefOid": "af54939c896aa859729c953c19d70fa46bd59cce",
      "closedAt": "2023-10-21T03:56:55Z",
      "mergedAt": "2023-10-21T03:56:55Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "e2e37dc241686992b87f3bcb36e6261dbd53bc6a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5kzLeZ",
          "commit": {
            "abbreviatedOid": "4c247c1"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-21T03:46:20Z",
          "updatedAt": "2023-10-21T03:49:02Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n  * Correct cross-references within group\r\n  * Describe `issuer_header` and `presentation_header`\r\n  * Update BBS references to CFRG drafts\r\n  * Rework reference to HMAC ( RFC2104 )\r\n  * Remove ZKSnark placeholder\r\n```",
              "createdAt": "2023-10-21T03:46:20Z",
              "updatedAt": "2023-10-21T03:49:02Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\n  * Correct cross-references within group.\r\n```",
              "createdAt": "2023-10-21T03:47:40Z",
              "updatedAt": "2023-10-21T03:49:02Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\n  * Correct cross-references within group.\r\n```",
              "createdAt": "2023-10-21T03:48:31Z",
              "updatedAt": "2023-10-21T03:49:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5kzNIc",
          "commit": {
            "abbreviatedOid": "af54939"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-21T03:50:11Z",
          "updatedAt": "2023-10-21T03:50:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDOFsQObc5ddL1Q",
      "title": "Fix Typo and Correct Object Attribute in BBS signature computation",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/88",
      "state": "MERGED",
      "author": "AlbertoSvg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\nI have reviewed the updates, and everything looks good to me, except for two minor points that this PR addresses:\r\n\r\n1. Fixing a typo in the file `draft-ietf-jose-json-proof-algorithms.md`\r\n2. Fixing the BBS signature computation:\r\n\r\nIn the `bbs.fixtures.mjs` file, the BBS _sign_ function was called with an object containing a 'payloads' property. However, the _sign_ function is designed to accept input objects of type \"BbsSignRequest\", which require a 'messages' property. Providing an object with a 'payloads' property instead resulted in the 'messages' property being set to 'undefined'.\r\n\r\nNo issues were immediately visible because, the BBS scheme allows empty message arrays for signing operations. \r\nInternally, the 'sign' operation accessed the 'messages' property, which was \"undefined\". So basically, It successfully computed the signature over an empty array of messages.\r\n\r\nIf you test the current code as it is and pass to the function an empty array of payloads you will notice that it produces the same signature value. Additionally, if you set `verifySignature: true` in the _deriveProof_ function, the signature verification would fail, as the messages are correctly passed to the function in this case.\r\n",
      "createdAt": "2023-10-22T01:16:21Z",
      "updatedAt": "2023-10-22T02:17:37Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "d6ee024ba33d14cb173db6fc4176b7d00e4c5d8c",
      "headRepository": "Cybersecurity-LINKS/json-web-proofs",
      "headRefName": "main",
      "headRefOid": "f17c15ba80420633a851dbd020ed2edf580a1548",
      "closedAt": "2023-10-22T02:17:16Z",
      "mergedAt": "2023-10-22T02:17:16Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "3c71d7af0096bd41c771ea008f578f58f675b738"
      },
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you Alberto! I look forward to seeing your rust implementation!",
          "createdAt": "2023-10-22T02:17:37Z",
          "updatedAt": "2023-10-22T02:17:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5k0BC8",
          "commit": {
            "abbreviatedOid": "f17c15b"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-22T02:08:55Z",
          "updatedAt": "2023-10-22T02:08:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5k0BEm",
          "commit": {
            "abbreviatedOid": "f17c15b"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-22T02:10:47Z",
          "updatedAt": "2023-10-22T02:10:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDOFsQObc5jBM11",
      "title": "Mike's New Years Eve 2023 Proofread",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/92",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Apply improvements identified during a full proofread.\r\n\r\nFixes #89 ",
      "createdAt": "2024-01-01T20:42:21Z",
      "updatedAt": "2024-01-05T18:11:15Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "da9c0412b7b386fad173b4c9be41e2302c8f4985",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-2023-proofread",
      "headRefOid": "3745e16303ba260a85a208f1104521e09f242eba",
      "closedAt": "2024-01-05T18:11:14Z",
      "mergedAt": "2024-01-05T18:11:14Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "1ef3306e5cb8ff90ae2c40a85cbfdfb354716dce"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5rWW0r",
          "commit": {
            "abbreviatedOid": "3745e16"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-02T20:53:39Z",
          "updatedAt": "2024-01-02T20:53:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5rrgYc",
          "commit": {
            "abbreviatedOid": "3745e16"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "looks great!",
          "createdAt": "2024-01-05T18:11:00Z",
          "updatedAt": "2024-01-05T18:11:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOFsQObc5jimyI",
      "title": "Address some 2023 review questions",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/93",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address some of the questions resulting from my end-of-year 2023 cover-to-cover review.",
      "createdAt": "2024-01-09T05:45:28Z",
      "updatedAt": "2024-02-08T14:53:51Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "1ef3306e5cb8ff90ae2c40a85cbfdfb354716dce",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-address-some-2023-review-questions",
      "headRefOid": "a1a79d55460c278a616fdab4535f9ee9c224ee1f",
      "closedAt": "2024-02-08T14:53:51Z",
      "mergedAt": "2024-02-08T14:53:51Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "63f019875a5dac2e8c98d598c45c37f01d81c36a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5sAkWF",
          "commit": {
            "abbreviatedOid": "bb4ac5b"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "A significant improvement!",
          "createdAt": "2024-01-09T21:59:54Z",
          "updatedAt": "2024-01-09T22:04:00Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nIn addition, the `disclosed_indexes` vector value is calculated from the payloads. For each value present in payloads (e.g. all values not `null` in JSON serialization or a zero-length string in compact serialization), the index of that payload is added to this vector.\r\n```",
              "createdAt": "2024-01-09T21:59:54Z",
              "updatedAt": "2024-01-09T22:04:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5vOqt4",
          "commit": {
            "abbreviatedOid": "a1a79d5"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-06T19:07:08Z",
          "updatedAt": "2024-02-06T19:07:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5vfJ4H",
          "commit": {
            "abbreviatedOid": "a1a79d5"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-08T14:53:42Z",
          "updatedAt": "2024-02-08T14:53:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOFsQObc5mKZAL",
      "title": "Add reference to IANA JWT Claims Registry",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/105",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #98 ",
      "createdAt": "2024-02-06T15:58:37Z",
      "updatedAt": "2024-02-06T19:13:55Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "1ef3306e5cb8ff90ae2c40a85cbfdfb354716dce",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-jwt-claims-registry",
      "headRefOid": "6f8ab164b145d7ef4edbe529c9776f7c97dc0463",
      "closedAt": "2024-02-06T19:13:55Z",
      "mergedAt": "2024-02-06T19:13:55Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "df9397ef7c72b869307e1343c0fe3f564f3d016c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5vOq6F",
          "commit": {
            "abbreviatedOid": "6f8ab16"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-06T19:07:29Z",
          "updatedAt": "2024-02-06T19:07:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5vOte6",
          "commit": {
            "abbreviatedOid": "6f8ab16"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-06T19:13:46Z",
          "updatedAt": "2024-02-06T19:13:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOFsQObc5mlSOD",
      "title": "Populate IANA Considerations Sections",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/106",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #76 ",
      "createdAt": "2024-02-11T18:52:30Z",
      "updatedAt": "2024-02-14T01:08:06Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "63f019875a5dac2e8c98d598c45c37f01d81c36a",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-iana-considerations",
      "headRefOid": "7a0d27d19eb19b5dc8aedb16ac86f2b55f353cab",
      "closedAt": "2024-02-14T01:08:06Z",
      "mergedAt": "2024-02-14T01:08:06Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "65f2568ce9b4a7ce99f693eb0ee2fe7669f84dae"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5v26MG",
          "commit": {
            "abbreviatedOid": "7aba3dd"
          },
          "author": "quartzjer",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Excellent!",
          "createdAt": "2024-02-13T00:53:27Z",
          "updatedAt": "2024-02-13T00:53:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5v9yY5",
          "commit": {
            "abbreviatedOid": "7aba3dd"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-13T16:41:44Z",
          "updatedAt": "2024-02-13T16:44:08Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "We can go ahead and remove `cty`; we instead would establish a 'layout' that describes each payload slot's meaning. ",
              "createdAt": "2024-02-13T16:41:44Z",
              "updatedAt": "2024-02-13T16:44:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5v9z7X",
          "commit": {
            "abbreviatedOid": "7aba3dd"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T16:44:41Z",
          "updatedAt": "2024-02-13T16:44:42Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "```suggestion\r\n```",
              "createdAt": "2024-02-13T16:44:42Z",
              "updatedAt": "2024-02-13T16:44:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 107,
      "id": "PR_kwDOFsQObc5nI8pB",
      "title": "Update draft-ietf-jose-json-proof-token.md to add more language about\u2026",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/107",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 semantic understanding of claims\r\n\r\nFixes #17",
      "createdAt": "2024-02-16T22:32:38Z",
      "updatedAt": "2024-02-28T07:22:10Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "65f2568ce9b4a7ce99f693eb0ee2fe7669f84dae",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "issue-17",
      "headRefOid": "90adc2db850987a0f8b8314379e1f83d119de159",
      "closedAt": "2024-02-27T23:18:07Z",
      "mergedAt": "2024-02-27T23:18:07Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "6701d24c8c2f761ccfb2cd728e7e5def32e7cf05"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5wee0j",
          "commit": {
            "abbreviatedOid": "a67cf86"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "What does this statement enable?\r\n> Holders SHOULD understand the semantics of all disclosed claims.\r\n\r\nPut another way, is there any downside to having holders disclose claims syntactically, without having any deep semantic understanding of their meaning?  If there's no downside, we should delete or modify this sentence.",
          "createdAt": "2024-02-17T22:25:26Z",
          "updatedAt": "2024-02-17T22:25:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5wwWXZ",
          "commit": {
            "abbreviatedOid": "a67cf86"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T22:41:29Z",
          "updatedAt": "2024-02-20T22:41:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nWhile JWPs provide the underling structure for easily supporting selective disclosure, JPTs must go a step further to ensure that holders can effectively provide choice and consent on exactly what is being disclosed.  Software using JWPs MUST know the mappings from payloads to claims. All disclosed payloads MUST be mapped to claims and made accessible to the application.  Holders SHOULD understand the semantics of all potentially disclosed claims to the extent needed to decide whether to disclose them. JPTs SHOULD NOT contain claims that are intended only for a specific verifier.\r\n```",
              "createdAt": "2024-02-20T22:41:29Z",
              "updatedAt": "2024-02-20T22:41:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 109,
      "id": "PR_kwDOFsQObc5oGH9E",
      "title": "BBS-DRAFT-5 and BBS-PROOF-DRAFT-5",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/109",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Leverage unreleased `mattrglobal/pairing_crypto` version for building examples, update references, and remove the previous workarounds for mmark tooling issues.",
      "createdAt": "2024-02-27T20:11:40Z",
      "updatedAt": "2024-02-28T07:21:22Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "6701d24c8c2f761ccfb2cd728e7e5def32e7cf05",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "add-bbs-draft-5",
      "headRefOid": "cf1720f05f4d11996a94e19bd92843f4864e4e2f",
      "closedAt": "2024-02-28T07:21:15Z",
      "mergedAt": "2024-02-28T07:21:15Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "30a0248bf4b7b86a07f3921c6268445c62fd22f3"
      },
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm still reading the delta between BBS draft 4 and 5 to make sure I don't have other updates.",
          "createdAt": "2024-02-27T20:12:13Z",
          "updatedAt": "2024-02-27T20:12:13Z"
        },
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixes #108 ",
          "createdAt": "2024-02-27T22:39:51Z",
          "updatedAt": "2024-02-27T22:39:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5xistA",
          "commit": {
            "abbreviatedOid": "7b3417d"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-27T22:16:21Z",
          "updatedAt": "2024-02-27T22:16:22Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "```suggestion\r\n  * Add new `BBS-DRAFT-3` and `BBS-PROOF-DRAFT-3` algorithms based on draft-irtf-cfrg-bbs-signatures-03.\r\n```",
              "createdAt": "2024-02-27T22:16:21Z",
              "updatedAt": "2024-02-27T22:50:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5xi2vf",
          "commit": {
            "abbreviatedOid": "7b3417d"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-27T22:49:06Z",
          "updatedAt": "2024-02-27T22:49:06Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "The XML tooling will fail if I don't reference it as draft 5",
              "createdAt": "2024-02-27T22:49:06Z",
              "updatedAt": "2024-02-27T22:49:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5xi_vj",
          "commit": {
            "abbreviatedOid": "f333a2c"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-27T23:20:28Z",
          "updatedAt": "2024-02-27T23:20:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 110,
      "id": "PR_kwDOFsQObc5oX2DM",
      "title": "Add 'address' and 'age_over_21' claims as examples.",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/110",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #33 \r\n\r\n* Add two additional claims to illustrate full use of JSON\r\n* Added a paragraph describing the contents of each claim in the given example.\r\n* Describe `claims` as an issuer protected header\r\n* Restructure structure to talk about claims and the `claims` issuer protected header first, then the options to reference external values.",
      "createdAt": "2024-03-01T06:43:54Z",
      "updatedAt": "2024-03-04T22:21:19Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "30a0248bf4b7b86a07f3921c6268445c62fd22f3",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jpt-add-diverse-claims",
      "headRefOid": "30e3a5ce80faf5b946dda79f53053b932df88d24",
      "closedAt": "2024-03-01T21:50:49Z",
      "mergedAt": "2024-03-01T21:50:49Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "a82ad01a80f77d1dadde9f25858cc90dfea5bd12"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5x9lSo",
          "commit": {
            "abbreviatedOid": "30e3a5c"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It would be good to say more about what `cid` is and how to use it, but I don't want to block merging this improvement on that.  Let's file a separate issue.",
          "createdAt": "2024-03-01T20:36:36Z",
          "updatedAt": "2024-03-01T20:36:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 111,
      "id": "PR_kwDOFsQObc5oX3W5",
      "title": "Correct IANA registry for BBS-DRAFT-3 to -5",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/111",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, merge -03 document version sections. Fixes #108 ",
      "createdAt": "2024-03-01T06:49:18Z",
      "updatedAt": "2024-03-04T22:21:16Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "30a0248bf4b7b86a07f3921c6268445c62fd22f3",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "fix-iana-bbs",
      "headRefOid": "0dc1d239266a653db59ccaa638ee59a751a79863",
      "closedAt": "2024-03-01T21:51:07Z",
      "mergedAt": "2024-03-01T21:51:07Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "b666a9ef32eafc6380d4046f980005ad5c6450cf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5x9lfG",
          "commit": {
            "abbreviatedOid": "0dc1d23"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-01T20:37:17Z",
          "updatedAt": "2024-03-01T20:37:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 112,
      "id": "PR_kwDOFsQObc5oX-L7",
      "title": "Allow algorithms to use ~ separator in proofs.",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/112",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Redefined proofs to be one or more octet strings\r\n* Update description of compact serialialization to concatenate these string via tilde\r\n* Update JSON encoding to put proof values into arrays\r\n\r\nFixes #59",
      "createdAt": "2024-03-01T07:12:00Z",
      "updatedAt": "2024-03-04T22:21:13Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "30a0248bf4b7b86a07f3921c6268445c62fd22f3",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "jwp-algorithms-use-tildes",
      "headRefOid": "640e6edc55dcf1339fa00e803e455f11ef35e69d",
      "closedAt": "2024-03-01T21:51:25Z",
      "mergedAt": "2024-03-01T21:51:25Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "f5183064ccfe5b1c97ecee8c5ad2795b2ead2a5c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5x9mKS",
          "commit": {
            "abbreviatedOid": "640e6ed"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-01T20:39:27Z",
          "updatedAt": "2024-03-01T20:39:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 113,
      "id": "PR_kwDOFsQObc5oYDZJ",
      "title": "Compact representation of a zero-length payload.",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/113",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Handle the special case of a zero-length payload in compact encoding, by using the invalid base64url encoded sequence \"_\".\r\n\r\nClarify that JSON encoding would use the more intuitive empty string rather than matching the compact representation.\r\n\r\nThere are currently no examples for this, as it is meant more to maintain consistency between the representations rather than to satisfy an identified use-case.\r\n\r\nFixes #101 ",
      "createdAt": "2024-03-01T07:21:25Z",
      "updatedAt": "2024-03-04T22:21:10Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "817e285d82ee17ec85f6c7a4d09f50b6004d3f9a",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "distinguish-blank-null-payloads",
      "headRefOid": "b81e55f3b161c505c484723e352964f2631d5463",
      "closedAt": "2024-03-01T22:02:46Z",
      "mergedAt": "2024-03-01T22:02:46Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "91bd0edc85a8b7eaa3255737e9ca41ed428fcc34"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5x9nGs",
          "commit": {
            "abbreviatedOid": "2b9d013"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-01T20:42:10Z",
          "updatedAt": "2024-03-01T20:42:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 114,
      "id": "PR_kwDOFsQObc5oYRzT",
      "title": "Create a terminology section.",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/114",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The initial definitions are for binding, linkability and unlinkability.\r\n\r\nFixes #41 ",
      "createdAt": "2024-03-01T08:06:33Z",
      "updatedAt": "2024-03-04T22:21:11Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "30a0248bf4b7b86a07f3921c6268445c62fd22f3",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "define-terminology-binding",
      "headRefOid": "44c491aeac5c28e811d74e531451ffd4aed87d45",
      "closedAt": "2024-03-01T21:51:54Z",
      "mergedAt": "2024-03-01T21:51:54Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "817e285d82ee17ec85f6c7a4d09f50b6004d3f9a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5x9pF2",
          "commit": {
            "abbreviatedOid": "44c491a"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-01T20:44:28Z",
          "updatedAt": "2024-03-01T20:44:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 116,
      "id": "PR_kwDOFsQObc5odqJt",
      "title": "Added history entries for -03 drafts",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/116",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-02T00:19:06Z",
      "updatedAt": "2024-03-02T01:47:23Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "91bd0edc85a8b7eaa3255737e9ca41ed428fcc34",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-03-history",
      "headRefOid": "1010cf430f2348063dbeffc8e8c94b48ded780b9",
      "closedAt": "2024-03-02T01:47:23Z",
      "mergedAt": "2024-03-02T01:47:23Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "5b6069fb91b62957e866ccda202006b5e98ef0a7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5x_fiz",
          "commit": {
            "abbreviatedOid": "1010cf4"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2024-03-02T01:36:58Z",
          "updatedAt": "2024-03-02T01:36:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 117,
      "id": "PR_kwDOFsQObc5od3Sf",
      "title": "Defined aud and nonce Header Parameters",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/117",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #102 ",
      "createdAt": "2024-03-02T01:26:10Z",
      "updatedAt": "2024-03-02T01:54:19Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "91bd0edc85a8b7eaa3255737e9ca41ed428fcc34",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-aud-nonce",
      "headRefOid": "76932b098bafc4c61d8d5eef11ba1101b7f5b300",
      "closedAt": "2024-03-02T01:54:19Z",
      "mergedAt": "2024-03-02T01:54:19Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "d942d156573d2ac4c4bba5dd97ef9980d97f5647"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc5x_jGX",
          "commit": {
            "abbreviatedOid": "76932b0"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-02T01:51:31Z",
          "updatedAt": "2024-03-02T01:51:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I've always thought the \"identify itself with a value\" terminology was really confusing, since the verifier (in this case) does not get to set `aud`. \"Confirm its identity is represented by at least one value\" would have been so much better - but I suppose we are stuck with it for consistency.",
              "createdAt": "2024-03-02T01:51:31Z",
              "updatedAt": "2024-03-02T01:51:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFsQObc5x_jKL",
          "commit": {
            "abbreviatedOid": "76932b0"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-02T01:51:55Z",
          "updatedAt": "2024-03-02T01:51:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFsQObc5x_jc6",
          "commit": {
            "abbreviatedOid": "76932b0"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-02T01:54:04Z",
          "updatedAt": "2024-03-02T01:54:04Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "It's because especially in SAML deployments, the audiences are often abstract things like urn:edu:nternet2:federation.",
              "createdAt": "2024-03-02T01:54:04Z",
              "updatedAt": "2024-03-02T01:54:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOFsQObc5wRXhr",
      "title": "Scripted creation of all examples",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/120",
      "state": "CLOSED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "During initial submission, the code to generate examples was disabled to solve formatting issues. Since then, the algorithms have drifted and the implementations of those algorithms has changed.\r\n\r\nThis commit attempts to create a set of scripts to generate all key material examples for all three specifications to pull from.",
      "createdAt": "2024-05-23T02:02:05Z",
      "updatedAt": "2024-07-19T05:21:21Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "d942d156573d2ac4c4bba5dd97ef9980d97f5647",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "buildable-examples",
      "headRefOid": "3eb3fcb8ef8020913b9e97310466ca87eb6a1f27",
      "closedAt": "2024-07-19T05:21:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing due to other merges",
          "createdAt": "2024-07-19T05:21:12Z",
          "updatedAt": "2024-07-19T05:21:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc57it99",
          "commit": {
            "abbreviatedOid": "58eb699"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-23T02:14:09Z",
          "updatedAt": "2024-05-23T02:14:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 121,
      "id": "PR_kwDOFsQObc50vp1Z",
      "title": "Update to BBS draft 6",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/121",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-08T20:55:18Z",
      "updatedAt": "2024-07-08T22:26:14Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "d942d156573d2ac4c4bba5dd97ef9980d97f5647",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "update-to-bbs-draft-6",
      "headRefOid": "2542fe8bad7f7bac70b7b4cd244c3acc1bba67fe",
      "closedAt": "2024-07-08T22:26:09Z",
      "mergedAt": "2024-07-08T22:26:09Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "096806b5f8d9648cb57c300257edb2ff0acdc9ce"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 122,
      "id": "PR_kwDOFsQObc511Xrr",
      "title": "MAC-H256 fixtures",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/122",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This completes the refactoring of the example generation and import into the spec. \r\n\r\nI unfortunately didn't have time to update generation of the MAC-H256 examples before the IETF120 submission cut-off.",
      "createdAt": "2024-07-18T22:12:07Z",
      "updatedAt": "2024-07-19T05:20:50Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "de9a70537bf657715a86e2d5e97e97fb9a79aa29",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "mac-h256-fixtures",
      "headRefOid": "ed3f7f8aca364d510275c7f021a7a1855367bb72",
      "closedAt": "2024-07-19T05:20:45Z",
      "mergedAt": "2024-07-19T05:20:45Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "b1f06d3374025a277ed593eb7a1f45bbd270a833"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc6CW2Rq",
          "commit": {
            "abbreviatedOid": "23211fc"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Please update the history entries accordingly.",
          "createdAt": "2024-07-18T22:49:43Z",
          "updatedAt": "2024-07-18T22:49:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDOFsQObc513YbP",
      "title": "Refactor algorithms to use multi-part proofs",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/123",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is the implementation of the previous spec change describing proofs as being a sequence of octet strings, rather than a single octet string.\r\n\r\nThis change is meant to simplify parsing logic and to reduce the need to unpack dynamically sized buffers, especially in implementations using languages without protections from out-of-bound conditions.\r\n\r\n1. For BBS, I corrected examples to use a single-value array for the proof value.\r\n2. For Single Use, it was mostly a straight translation\r\n3. For MAC, I attempted to do a bit more of a cleanup.:\r\n     - A new section was created describing a Combined MAC Representation, which synthesized by various operations to create or verify the issuer signature\r\n     - Sections received a bit more work to unify around this concept\r\n     - The section on verification was heavily reworked, as it described a process well beyond MAC validation.",
      "createdAt": "2024-07-19T07:38:14Z",
      "updatedAt": "2024-07-19T16:51:12Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "b1f06d3374025a277ed593eb7a1f45bbd270a833",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "multi-part-proofs",
      "headRefOid": "0a266f3bacf8e3774abe655daabd9e78d883111d",
      "closedAt": "2024-07-19T16:51:08Z",
      "mergedAt": "2024-07-19T16:51:08Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "bd0ea8a6bc64af139a2028021ec2b72d3fdd0d6b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc6CbeUr",
          "commit": {
            "abbreviatedOid": "0a266f3"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for doing this. ",
          "createdAt": "2024-07-19T13:25:04Z",
          "updatedAt": "2024-07-19T13:25:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDOFsQObc52BO0z",
      "title": "Register +jwp structured syntax suffix",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/124",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #119 ",
      "createdAt": "2024-07-21T16:34:40Z",
      "updatedAt": "2024-07-21T17:11:24Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "bd0ea8a6bc64af139a2028021ec2b72d3fdd0d6b",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-jwp-suffix",
      "headRefOid": "c5cb17a8a333d814eaf6d6138b9929f6813a3c01",
      "closedAt": "2024-07-21T17:11:24Z",
      "mergedAt": "2024-07-21T17:11:24Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "e2d2d04474b28dbd66c9d699f4eb1ada97769576"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc6CjmpO",
          "commit": {
            "abbreviatedOid": "c5cb17a"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-21T17:11:13Z",
          "updatedAt": "2024-07-21T17:11:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "PR_kwDOFsQObc52BYbq",
      "title": "Correct -05 history entries",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/125",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-21T18:59:33Z",
      "updatedAt": "2024-07-21T19:19:24Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "957c89500e6c4c6cf52c909a9441162b05ca3702",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-05-history",
      "headRefOid": "3ac0824cff894ce86c743535b3848074b55af160",
      "closedAt": "2024-07-21T19:19:24Z",
      "mergedAt": "2024-07-21T19:19:24Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "8f6d31230ee13bbc537deb6be8386bda5ca6f011"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 126,
      "id": "PR_kwDOFsQObc52BZZ5",
      "title": "Delete vacuous Registries section",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/126",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-21T19:15:21Z",
      "updatedAt": "2024-07-21T19:19:37Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "957c89500e6c4c6cf52c909a9441162b05ca3702",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-delete-registries",
      "headRefOid": "637748ff097f7b8f0dafc549b8b73a8308e436bd",
      "closedAt": "2024-07-21T19:19:36Z",
      "mergedAt": "2024-07-21T19:19:36Z",
      "mergedBy": "selfissued",
      "mergeCommit": {
        "oid": "a992873a77beb03be2a341ba7ac485c3694c3f70"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc6CjqQv",
          "commit": {
            "abbreviatedOid": "637748f"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-21T19:16:07Z",
          "updatedAt": "2024-07-21T19:16:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "PR_kwDOFsQObc52BaGV",
      "title": "Move to have base64url-encoding only done for",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/127",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Change algorithms to not use base64url encoded data in say internal synthesized values.\r\n\r\nAlso change examples in the algorithm appendix to clarify the figures are using base64url encoding, vs the internal algorithm data.",
      "createdAt": "2024-07-21T19:26:17Z",
      "updatedAt": "2024-07-22T01:48:53Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "a992873a77beb03be2a341ba7ac485c3694c3f70",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "binary-safety-cleanup",
      "headRefOid": "ba35335bdcac42b60dbdb457b7c6e8daae0a9ca5",
      "closedAt": "2024-07-22T01:48:51Z",
      "mergedAt": "2024-07-22T01:48:51Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "2e5e93861bea3f15807a527eab31fb420139ade6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc6CjqoA",
          "commit": {
            "abbreviatedOid": "ba35335"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-21T19:29:42Z",
          "updatedAt": "2024-07-21T19:29:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "PR_kwDOFsQObc52BiPS",
      "title": "Define cid Header Parameter",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/128",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #115 ",
      "createdAt": "2024-07-21T21:42:30Z",
      "updatedAt": "2024-07-22T00:05:08Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "a992873a77beb03be2a341ba7ac485c3694c3f70",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-cid",
      "headRefOid": "4e3337fc1b7c18f824671f5de3bbea256ad6c40e",
      "closedAt": "2024-07-22T00:05:08Z",
      "mergedAt": "2024-07-22T00:05:08Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "bceb7c7d50b2d5b055d8248ce3f7e52f2df9b388"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc6Cj0RI",
          "commit": {
            "abbreviatedOid": "4e3337f"
          },
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-22T00:05:02Z",
          "updatedAt": "2024-07-22T00:05:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 129,
      "id": "PR_kwDOFsQObc52Bzt7",
      "title": "Use raw algorithms",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/129",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Use raw algorithms (as defined in JWA) rather than composing via JWS and synthesized headers.\r\n\r\nIn addition to simplifying the description (no longer need to explain the manipulations to add a synthesized header or to grab just the base64url-decoded octets of the signature), this should make it much easier to map the algorithms to a CBOR based format.\r\n\r\n",
      "createdAt": "2024-07-22T00:59:09Z",
      "updatedAt": "2024-07-22T02:50:50Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "2e5e93861bea3f15807a527eab31fb420139ade6",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "use-raw-algorithms",
      "headRefOid": "96dc6bbb9a89ef9760beeb2c303477ed0354d366",
      "closedAt": "2024-07-22T02:50:44Z",
      "mergedAt": "2024-07-22T02:50:44Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "3fef730010e57c640ecdf23a02ead0cc3eca52b0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFsQObc6Cj-7K",
          "commit": {
            "abbreviatedOid": "ffa69da"
          },
          "author": "selfissued",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-22T01:45:04Z",
          "updatedAt": "2024-07-22T01:45:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "PR_kwDOFsQObc52CIT4",
      "title": "Use tocdepth = 4",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/130",
      "state": "MERGED",
      "author": "selfissued",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Show four Table of Contents levels so that all IANA Registration headings are indexed.",
      "createdAt": "2024-07-22T02:57:12Z",
      "updatedAt": "2024-07-22T03:25:23Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "3fef730010e57c640ecdf23a02ead0cc3eca52b0",
      "headRepository": "selfissued/json-web-proofs",
      "headRefName": "mbj-tocdepth-4",
      "headRefOid": "dfdc69f62bd643c376067cbd42dbb28e296ad01c",
      "closedAt": "2024-07-22T03:25:23Z",
      "mergedAt": "2024-07-22T03:25:23Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "3a1ae01cbf0372d4ef91bed749f8eb4f44e7824a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 131,
      "id": "PR_kwDOFsQObc52J50q",
      "title": "Update linkage to new GitHub repository home.",
      "url": "https://github.com/ietf-wg-jose/json-web-proof/pull/131",
      "state": "MERGED",
      "author": "dwaite",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also noticed the Editor's note requesting feedback was missing from JWP, and added it.",
      "createdAt": "2024-07-23T01:16:52Z",
      "updatedAt": "2024-07-23T23:19:03Z",
      "baseRepository": "ietf-wg-jose/json-web-proof",
      "baseRefName": "main",
      "baseRefOid": "90e2817ff1ca4c58a148ea8712a055b79906a77f",
      "headRepository": "ietf-wg-jose/json-web-proof",
      "headRefName": "update-github-refs",
      "headRefOid": "264ad9d66fa1acba68a381f805ea6b201dfbf775",
      "closedAt": "2024-07-23T23:18:57Z",
      "mergedAt": "2024-07-23T23:18:57Z",
      "mergedBy": "dwaite",
      "mergeCommit": {
        "oid": "45c73dd5568d3c5c08722a8dbe3fb1d1369148a5"
      },
      "comments": [
        {
          "author": "dwaite",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging sans review",
          "createdAt": "2024-07-23T23:18:54Z",
          "updatedAt": "2024-07-23T23:18:54Z"
        }
      ],
      "reviews": []
    }
  ]
}