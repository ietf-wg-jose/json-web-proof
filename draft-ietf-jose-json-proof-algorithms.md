%%%
title = "JSON Proof Algorithms"
abbrev = "json-proof-algorithms"
ipr = "trust200902"
workgroup="jose"
keyword = ["jose", "zkp", "jwp", "jws", "jpa"]
docname = "draft-ietf-jose-json-proof-algorithms"
consensus = true

[seriesInfo]
name = "Internet-Draft"
value = "draft-ietf-jose-json-proof-algorithms-latest"
stream = "IETF"
status = "standard"

[pi]
toc = "yes"

[[author]]
initials = "J."
surname = "Miller"
fullname = "Jeremie Miller"
organization = "Ping Identity"
  [author.address]
   email = "jmiller@pingidentity.com"

[[author]]
initials = "M."
surname = "Jones"
fullname = "Michael B. Jones"
organization = "Self-Issued Consulting"
  [author.address]
  email = "michael_b_jones@hotmail.com"
  uri = "https://self-issued.info/"

[[author]]
initials = "D."
surname = "Waite"
fullname = "David Waite"
organization = "Ping Identity"
  [author.address]
  email = "dwaite+jwp@pingidentity.com"

%%%

.# Abstract

The JSON Proof Algorithms (JPA) specification registers cryptographic algorithms and identifiers to be used with the JSON Web Proof and JSON Web Key (JWK) specifications. It defines IANA registries for these identifiers.

{mainmatter}

# Introduction

The JSON Web Proof (JWP) [@!I-D.ietf-jose-json-web-proof] draft establishes a new secure container format that supports selective disclosure and unlinkability using Zero-Knowledge Proofs (ZKPs) or other cryptographic algorithms.

> Editor's Note: This draft is still early and incomplete. There will be significant changes to the algorithms as currently defined here.  Please do not use any of these definitions or examples for anything except personal experimentation and learning.  Contributions and feedback are welcomed at https://github.com/json-web-proofs/json-web-proofs.

# Conventions and Definitions

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [@RFC2119] [@RFC8174] when, and only when, they appear in all capitals, as shown here.

The roles of "issuer", "holder", and "verifier" are used as defined by the VC Data Model [@VC-DATA-MODEL-2.0].  The term "presentation" is also used as defined by this source, but the term "credential" is avoided in this specification to minimize confusion with other definitions.

# Terminology

The terms "JSON Web Signature (JWS)", "Base64url Encoding", "Header Parameter", "JOSE Header", "JWS Payload", "JWS Signature", and "JWS Protected Header" are defined by [@RFC7515].

The terms "JSON Web Proof (JWP)", "JWP Payload", "JWP Proof", and "JWP Protected Header" are defined by [@!I-D.ietf-jose-json-web-proof].

These terms are defined by this specification:

Stable Key:
:  An asymmetric key-pair used by an issuer that is also shared via an out-of-band mechanism to a verifier to validate the signature.

Ephemeral Key:
:  An asymmetric key-pair that is generated for one-time use by an issuer and never stored or used again outside of the creation of a single JWP.

Presentation Key:
:  An asymmetric key-pair that is generated by a holder and used to ensure that a presentation is not able to be replayed by any other party.


# Background

JWP defines a container binding together a protected header, one or more payloads, and a cryptographic proof.  It does not define any details about the interactions between an application and the cryptographic libraries that implement proof-supporting algorithms.

Due to the nature of ZKPs, this specification also documents the subtle but important differences in proof algorithms versus those defined by the JSON Web Algorithms [@RFC7518].  These differences help support more advanced capabilities such as blinded signatures and predicate proofs.

# Algorithm Basics

The four principal interactions that every proof algorithm MUST support are `[issue](#issue)`, `[confirm](#confirm)`, `[present](#present)`, and `[verify](#verify)`.

## Issue

The JWP is first created as the output of a JPA's `issue` operation.

Every algorithm MUST support a JSON issuer protected header along with one or more octet string payloads.  The algorithm MAY support using additional items provided by the holder for issuance such as blinded payloads, keys for replay prevention, etc.

All algorithms MUST provide integrity protection for the issuer header and all payloads and MUST specify all digest and/or hash2curve methods used.

## Confirm

Performed by the holder to validate that the issued JWP is correctly formed and protected.

Each algorithm MAY support using additional input items options, such as those sent to the issuer for issuance. After confirmation, an algorithm MAY return a modified JWP for serialized storage without the local state (such as with blinded payloads now unblinded).

The algorithm MUST fully verify the issued proof value against the issuer protected header and all payloads.  If given a presented JWP instead of an issued one, the confirm process MUST return an error.

## Present

Used to apply any selective disclosure choices and perform any unlinkability transformations, as well as to show binding.

An algorithm MAY support additional input options from the requesting party, such as for predicate proofs and verifiable computation requests.

Every algorithm MUST support the ability to hide any or all payloads.  It MUST always include the issuer protected header unmodified in the presentation.

The algorithm MUST replace the issued proof value and generate a new presented proof value.  It also MUST include a new presentation protected header that provides replay protection.

## Verify

Performed by the verifier to verify the protected headers along with any disclosed payloads and/or assertions about them from the proving party, while also verifying they are the same payloads and ordering as witnessed by the issuer.

The algorithm MUST verify the integrity of all disclosed payloads and MUST also verify the integrity of both the issuer and presentation protected headers.

If the presented proof contains any assertions about the hidden payloads, the algorithm MUST also verify all of those assertions.
It MAY support additional options, such as those sent to the holder to generate the presentation.

If given an issued JWP for verification, the algorithm MUST return an error.

# Algorithm Specifications

This section defines how to use specific algorithms for JWPs.

## Single Use

> Editor's Note: This algorithm may be renamed and slightly refactored.

The Single Use (SU) algorithm is based on composing multiple traditional JWS values into a single JWP proof value.  It enables a very simple form of selective disclosure without requiring any advanced cryptographic techniques.

It does not support unlinkability if the same JWP is presented multiple times, therefore when privacy is required the holder will need to interact with the issuer again to receive new single-use JWPs (dynamically or in batches).

### JWS Algorithm

The Single Use algorithm is based on using multiple JWS values, all of which are generated with the same JSON Web Algorithm (JWA) for signing.  This JWA identifier is included as part of the Single Use identifier for JWP.

The chosen JWA MUST be an asymmetric signing algorithm so that each signature can be verified without sharing any private values between the parties.  This ensures that the verifier cannot brute force any non-disclosed payloads based only on their disclosed individual signatures.

### Holder Setup

In order to support the protection of a presentation by a holder to a verifier, the holder MUST use a Presentation Key during the issuance and the presentation of every Single Use JWP.  This Presentation Key MUST be generated and used for only one JWP.

The issuer MUST verify that the holder has possession of this key.  The holder-issuer communication to exchange this information is out of scope of this specification but can be easily accomplished by the holder using this key to generate a JWS that signs a value the issuer can verify as unique.

### Issuer Setup

To create a Single Use JWP, the issuer first generates a unique Ephemeral Key using the selected JWS algorithm.  This key-pair will be used to sign each of the payloads of a single JWP and then discarded.

### Using JWS

JSON Web Signatures are used to create all of the signature values used by the SU algorithm.  This allows an implementation to use an existing JWS library directly for all necessary cryptographic operations without requiring any additional primitives.

Each individual JWS uses a fixed protected header containing only the minimum required `alg` value.  Since this JWS protected header itself is the same for every JWS, it SHOULD be a static value in the form of `{"alg":"***"}` where `***` is the JWA asymmetric signing key algorithm identifier being used.  This value is recreated by a verifier using the correct JWA algorithm value included in the SU algorithm identifier.

If an implementation uses an alternative JWS protected header than this fixed value, a base64url encoded serialized form of the alternate fixed header MUST be included using the `jws_header` claim in the issuer protected header.

### Issuer Protected Header

The JWK of the issuer's Ephemeral Key MUST be included in the issuer protected header with the property name of `proof_jwk` and contain only the REQUIRED values to represent the public key.

The holder's Presentation Key JWK MUST be included in issuer protected header using the `presentation_jwk` claim.

The final issuer protected header is then used directly as the body of a JWS and signed using the issuer's Stable Key.  The resulting JWS signature value unencoded octet string is the first value in the JWP proof.

In various examples in this specification, the octet string serialized issuer header is referenced as `issuer_header`.

### Payloads

Each JWP payload is processed in order and signed as a JWS body using the issuer's Ephemeral Key.  The resulting JWS signature value unencoded octet string is appended to the JWP proof.

The proof value as an octet string will have a total length that is the sum of the fixed length of the issuer protected header signature plus the fixed length of each of the payload Ephemeral Key signatures.  For example, the signature for the ES256 algorithm is 64 octets and for a JWP with five payloads the total proof value length would be `64 * (1 + 5) = 384` octets).

### Presentation Protected Header

To generate a new presentation, the holder first creates a presentation protected header that is specific to the verifier being presented to.  This header MUST contain a claim that both the holder and verifier trust as being unique and non-replayable.
Use of the `nonce` header parameter is RECOMMENDED for this purpose.

This specification registers the `nonce` header parameter for the presentation protected header that contains a string value either generated by the verifier or derived from values provided by the verifier.  When present, the verifier MUST ensure the nonce value matches during verification.

The presentation protected header MAY contain other header parameters that are either provided by the verifier or by the holder.  These presentation claims SHOULD NOT contain values that are common across multiple presentations and SHOULD be unique to a single presentation and verifier.

In various examples in this specification, the octet string serialized presentation header is referenced as `presentation_header`.

### Presentation

> Editor's Note: The current definition here is incomplete, the holder's signature needs to also incorporate the presented proof.

The holder derives a new proof value when presenting it to a verifier.  The presented proof value will always contain the issuer's Stable Key signature for the issuer protected header as the first element.

The second element of the presented proof value is always the holder's Presentation Key signature of the presentation protected header, constructed identically to the issuer protected header by using the serialized JSON value octet string as the JWS body.  Signing only the presentation header with the Presentation Key is sufficient to protect the entire presentation since that key is private to the holder and only the contents of the presentation header are used for replay prevention.

The two header signatures are then followed by only the issuer's Ephemeral Key signatures for each payload that is disclosed.  The order of the payload signatures is preserved and MUST be in the same order as the included disclosed payloads in the presented JWP.  Non-disclosed payloads will NOT have a signature value included.  For example, if the second and fifth payloads are hidden then the holder's derived proof value would be of the length `64 * (1 + 1 + the 1st, 2nd, and 4th payload signatures) = 320 octets`.

Since the individual signatures in the proof value are unique and remain unchanged across multiple presentations, a Single Use JWP SHOULD only be presented a single time to each verifier in order for the holder to remain unlinkable across multiple presentations.

### Verification

The verifier MUST verify the issuer protected header against the first matching JWS signature part in the proof value using the issuer's Stable Key.  It MUST also verify the presentation protected header against the second JWS signature part in the proof value using the holder's Presentation Key as provided in the `presentation_jwk` claim in the issuer protected header.

With the headers verified, the issuer's Ephemeral Key as given in the issuer protected header `proof_jwk` claim can then be used to verify each of the disclosed payload signatures.

### JPA Registration {#SU-registration}

The proposed JWP `alg` value is of the format "SU-" appended with the relevant JWS `alg` value for the chosen public and ephemeral key-pair algorithm, for example "SU-ES256".

## BBS

The BBS Signature Scheme [@!I-D.irtf-cfrg-bbs-signatures#05] is under active development within the CRFG.

This algorithm supports both selective disclosure and unlinkability, enabling the holder to generate multiple presentations from one issued JWP without a verifier being able to correlate those presentations together based on the proof.

### JPA Algorithms {#BBS-registration}

The `BBS` `alg` parameter value in the issuance protected header corresponds to a ciphersuite identifier of `BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_`.

The `BBS-PROOF` `alg` parameter value in the presentation protected header corresponds to the same ciphersuite, but used in presentation form.

### Key Format

The key used for the `BBS` algorithm is an elliptic curve-based key pair, specifically against the G_2 subgroup of a pairing friendly curve. Additional details on key generation can be found in [@!I-D.irtf-cfrg-bbs-signatures#05, Section 3.4]

The JWK form of this key is an `OKP` type with a curve of `BLS12381G2`, with `x` being the BASE64URL-encoded form of the output of `point_to_octets_E2`. The use of this curve is described in [@!I-D.ietf-cose-bls-key-representations].

There is no additional holder key necessary for presentation proofs.

### Issuance

Issuance is performed using the `Sign` operation from [@!I-D.irtf-cfrg-bbs-signatures#05, section 3.5.1]. This operation utilizes the issuer's BLS12-381 G2 key pair as `SK` and `PK`, along with desired protected header and payloads as the octets `header` and the octets array `messages`.

The octets resulting from this operation form the issuance proof, to be used along with the protected header and payloads to serialize the JWP.

### Issuance Proof Verification

Holder verification of the signature on issuance form is performed using the `Verify` operation from [@!I-D.irtf-cfrg-bbs-signatures#05, section 3.5.2].

This operation utilizes the issuer's public key as `PK`, the proof as `signature`, the protected header octets as `header` and the array of payload octets as `messages`.

### Presentation

Derivation of a presentation is done by the holder using the `ProofGen` operation from [@!I-D.irtf-cfrg-bbs-signatures#05, section 3.5.3].

This operation utilizes the issuer's public key as `PK`, the issuer protected header as `header`, the issuance proof as `signature`, the issuance payloads as `messages`, and the holder's presentation protected header as `ph`.

The operation also takes a vector of indexes into `messages`, describing which payloads the holder wishes to disclose. All payloads are required for proof generation, but only these indicated payloads will be required to be disclosed for later proof verification.

The output of this operation is the presentation proof.

Presentation serialization leverages the two protected headers and presentation proof, along with the disclosed payloads. Non-disclosed payloads are represented with the absent value of `null` in JSON serialization and a zero-length string in compact serialization.

### Presentation Verification

Verification of a presentation is done by the verifier using the `ProofVerify` operation from [@!I-D.irtf-cfrg-bbs-signatures#05, Section 3.5.4].

This operation utilizes the issuer's public key as `PK`, the issuer protected header as `header`, the issuance proof as `signature`, the holder's presentation protected header as `ph`, and the payloads as `disclosed_messages`.

In addition, the `disclosed_indexes` scalar array is calculated from the payloads provided. Values disclosed in the presented payloads have a zero-based index in this array, while the indices of absent payloads are omitted.

## Message Authentication Code

The Message Authentication Code (MAC) JPA uses a MAC to both generate ephemeral keys and compute authentication codes to protect the issuer header and each payload individually.

Like the JWS-based JPA, it also does not support unlinkability if the same JWP is presented multiple times and requires an individually issued JWP for each presentation in order to fully protect privacy.  When compared to the JWS approach, using a MAC requires less computation but can result in potentially larger presentation proof values.

The design is intentionally minimal and only involves using a single standardized MAC method instead of a mix of MAC/hash methods or a custom hash-based construct.  It is able to use any published cryptographic MAC method such as HMAC [@?RFC2104] or [KMAC](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf).  It uses traditional public-key based signatures to verify the authenticity of the issuer and holder.

### Holder Setup

Prior to the issuer creating a new JWP, it must have presentation binding information provided by the holder.  This enables the holder to perform replay prevention while presenting the JWP.

The presentation key used by the holder must be transferred to the issuer and verified, likely through a challenge and self-signing mechanism.  If the holder requires unlinkability, it must also generate a new key that is verified and bound to each new JWP.

How these holder presentation keys are transferred and verified is out of scope of this specification. Protocols such as OpenID Connect can be used to accomplish this.  What is required by this definition is that the holder's presentation key MUST be included in the issuer's protected header using the `pjwk` claim with a JWK as the value.

### Issuer Setup

To use the MAC algorithm, the issuer must have a stable public key pair to perform signing.  To start the issuance process, a single 32-byte random Shared Secret must first be generated.  This value will be shared privately to the holder as part of the issuer's JWP proof value.

The Shared Secret is used by both the issuer and holder as the MAC method's key to generate a new set of unique ephemeral keys.  These keys are then used as the input to generate a MAC that protects each payload.

### Issuer Protected Header {#issuer-protected-header}

The holder's presentation key JWK MUST be included in the issuer protected header using the `pjwk` claim.  The issuer MUST validate that the holder has possession of this key through a trusted mechanism such as verifying the signature of a unique nonce value from the holder.

For consistency, the issuer header is also protected by a MAC by using the fixed value "issuer_header" as the input key.  The issuer header JSON is serialized using UTF-8 and encoded with base64url into an octet array.  The final issuer header MAC is generated from the octet array and the fixed key, and the resulting value becomes the first input into the larger octet array that will be signed by the issuer.

### Payloads

A unique key is generated for each payload using the MAC with the Shared Secret as the key and the values "payload_X" where "X" is replaced by the zero-based array index of the payload, for example "payload_0", "payload_1", etc.

Each payload is serialized using UTF-8 and encoded with base64url into an octet array.  The generated key for that payload based on its index is used to generate the MAC for the payload's encoded octet array.  The resulting value is appended to the larger octet array that will be signed by the issuer.

### Issuer Proof

The issuer proof consists of two items appended together: the issuer's signature of the appended array of MACs and the Shared Secret used to generate the set of payload keys.

To generate the signature, the array containing the final MAC of the issuer protected header followed by all of the payload MACs appended in order is used as the input to a new JWS.

```
jws_payload = [issuer_header_mac, payload_mac_1, ... payload_mac_n]
```

The issuer signs the JWS using its stable public key and a fixed header containing the `alg` associated with MAC algorithm in use.

`jws_header = '{"alg":"ES256"}'`

The resulting signature is decoded and used as the first item in the issuer proof value.  The octet array of the Shared Secret is appended, resulting in the final issuer proof value.

`issuer_proof = [jws_signature, shared_secret]`

### Presentation Protected Header

See the JWS [Presentation Protected Header](#presentation-protected-header) section.

### Presentation

> Editor's Note: The current definition here is incomplete, the holder's signature needs to also incorporate the presented proof.

The presentation proof is constructed as a large octet array containing multiple appended items similar to the issuer proof value.  The first item is the JWS decoded signature value generated when the holder uses the presentation key to sign the presentation header.  The second item is the issuer signature from the issuer's proof value.

These two signatures are then followed by a MAC value for each payload.  The MAC values used will depend on whether that payload has been disclosed or is hidden.  Disclosed payloads will include the MAC key input, and hidden payloads will include only their final MAC value.

```
presentation_proof = [presentation_signature, issuer_signature,
                      disclosed_key_0, hidden_mac_1, hidden_mac_2,
                      ... disclosed_key_n]
```

The size of this value will depend on the underlying cryptographic algorithms.  For example, `MAC-H256` uses the `ES256` JWS with a decoded signature of 64 octets, and for a JWP with five payloads using `HMAC-SHA256` the total presentation proof value length would be `64 + 64 + (5 * 32) = 288` octets.

### Verifier Setup

To verify that the presentation was protected from replay attacks, the verifier must be able to validate the presentation protected header.  This involves the following steps:

1. JSON parse the presentation header
2. Validate the contained `nonce` claim
3. JSON parse the issuer header
4. Validate the contained `pjwk` claim
5. Create a JWS using the correct fixed header with `alg` value and the presentation header as the body
6. Remove the `presentation_signature` from the beginning of the `presentation_proof` octet array
7. Validate the JWS using the JWK from the `pjwk` claim and the `presentation_signature` value

Next, the verifier must validate all of the disclosed payloads using the following steps:

1. JSON parse the issuer header
2. Resolve the `kid` using a trusted mechanism to obtain the correct issuer JWK
3. Remove the `issuer_signature` from the beginning of the remaining `presentation_proof` octet array (after the `presentation_signature` was removed)
4. Perform the MAC on the presented `issuer_header` value using the "issuer_header" value as the input key
5. Store the resulting value as the first entry in a new `jws_payload` octet array
6. Iterate on each presented payload (disclosed or hidden)
   1. Extract the next hash value from the remaining `presentation_proof` octet array
   2. If the payload was disclosed: perform a MAC using the given hash value as the input key and append the result to the `jws_payload` octet array
   3. If the payload was hidden: append the given hash value to the `jws_payload` octet array
7. Create a JWS using a header containing the `alg` parameter along with the generated `jws_payload` value as the payload
8. Validate the JWS using the resolved issuer JWK and the extracted `issuer_signature` value

### JPA Registration {#MAC-registration}

Proposed JWP `alg` value is of the format "MAC-" appended with a unique identifier for the set of MAC and signing algorithms used.  Below are the initial registrations:

* `MAC-H256` uses `HMAC SHA-256` as the MAC and `ECDSA using P-256 and SHA-256` for the signatures
* `MAC-H384` uses `HMAC SHA-384` as the MAC and `ECDSA using P-384 and SHA-384` for the signatures
* `MAC-H512` uses `HMAC SHA-512` as the MAC and `ECDSA using P-521 and SHA-512` for the signatures
* `MAC-K25519` uses `KMAC SHAKE128` as the MAC and `EdDSA using Curve25519` for the signatures
* `MAC-K448` uses `KMAC SHAKE256` as the MAC and `EdDSA using Curve448` for the signatures
* `MAC-H256K` uses `HMAC SHA-256` as the MAC and `ECDSA using secp256k1 and SHA-256` for the signatures

# Security Considerations

> Editor's Note: This will follow once the algorithms defined here have become more stable.

* Data minimization of the proof value
* Unlinkability of the protected header contents

# IANA Considerations

The following registration procedure is used for all the
registries established by this specification.

Values are registered on a Specification Required [@RFC5226] basis
after a three-week review period on the jose-reg-review@ietf.org
mailing list, on the advice of one or more Designated Experts.
However, to allow for the allocation of values prior to publication,
the Designated Experts may approve registration once they are
satisfied that such a specification will be published.

Registration requests sent to the mailing list for review should use
an appropriate subject (e.g., "Request to register JWP algorithm: example").

Within the review period, the Designated Experts will either approve or deny
the registration request, communicating this decision to the review list and IANA.
Denials should include an explanation and, if applicable,
suggestions as to how to make the request successful.
Registration requests that are undetermined for
a period longer than 21 days can be brought to the IESG's attention
(using the iesg@ietf.org mailing list) for resolution.

Criteria that should be applied by the Designated Experts include
determining whether the proposed registration duplicates existing functionality,
whether it is likely to be of general applicability
or useful only for a single application,
and whether the registration description is clear.

IANA must only accept registry updates from the Designated Experts and should direct
all requests for registration to the review mailing list.

It is suggested that multiple Designated Experts be appointed who are able to
represent the perspectives of different applications using this specification,
in order to enable broadly informed review of registration decisions.
In cases where a registration decision could be perceived as
creating a conflict of interest for a particular Expert,
that Expert should defer to the judgment of the other Experts.


## JSON Web Proof Algorithms Registry {#AlgsReg}

This specification establishes the
IANA "JSON Web Proof Algorithms" registry
for values of the JWP `alg` (algorithm) parameter in JWP Header Parameters.
The registry records the algorithm name, the algorithm description,
the algorithm usage locations,
the implementation requirements, the change controller,
and a reference to the specification that defines it.
The same algorithm name can be registered multiple times,
provided that the sets of usage locations are disjoint.

It is suggested that the length of the key be included in the algorithm
name when multiple variations of algorithms are being
registered that use keys of different lengths and the key lengths for
each need to be fixed (for instance, because they will be created by
key derivation functions).
This allows readers of the JSON text to more easily make security decisions.

The Designated Experts should perform reasonable due diligence
that algorithms being registered either are currently considered
cryptographically credible or are being registered as Deprecated
or Prohibited.

The implementation requirements of an algorithm may be changed
over time as the
cryptographic landscape evolves, for instance,
to change the status of an algorithm to Deprecated or
to change the status of an algorithm from Optional
to Recommended+ or Required.
Changes of implementation requirements are only permitted
on a Specification Required basis after review by the Designated Experts,
with the new specification
defining the revised implementation requirements level.

### Registration Template {#AlgsTemplate}

* Algorithm Name: The name requested (e.g., "SU-ES256"). This name is a case-sensitive ASCII string. Names may not match other registered names in a case-insensitive manner unless the Designated Experts state that there is a compelling reason to allow an exception.
* Algorithm Description: Brief description of the algorithm (e.g., "Single-Use JWP using ES256").
* Algorithm Usage Location(s): The algorithm usage locations, which should be one or more of the values `Issued` or `Presented`.  Other values may be used with the approval of a Designated Expert.
* JWP Implementation Requirements: The algorithm implementation requirements for JWP, which must be one the words Required, Recommended, Optional, Deprecated, or Prohibited. Optionally, the word can be followed by a "+" or "-". The use of "+" indicates that the requirement strength is likely to be increased in a future version of the specification.  The use of "-" indicates that the requirement strength is likely to be decreased in a future version of the specification. Any identifiers registered for non-authenticated encryption algorithms or other algorithms that are otherwise unsuitable for direct use as JWP algorithms must be registered as "Prohibited".
* Change Controller: For Standards Track RFCs, list the "IETF". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.
* Specification Document(s): Reference to the document or documents that specify the parameter, preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required.
* Algorithm Analysis Documents(s): References to a publication or publications in well-known cryptographic conferences, by national standards bodies, or by other authoritative sources analyzing the cryptographic soundness of the algorithm to be registered. The Designated Experts may require convincing evidence of the cryptographic soundness of a new algorithm to be provided with the registration request unless the algorithm is being registered as Deprecated or Prohibited. Having gone through working group and IETF review, the initial registrations made by this document are exempt from the need to provide this information.

### Initial Registry Contents {#AlgsContents}

* Algorithm Name: `SU-ES256`
* Algorithm Description: Single-Use JWP using ES256
* Algorithm Usage Location(s): Issued, Presented
* JWP Implementation Requirements: Recommended
* Change Controller: IETF
* Specification Document(s): (#SU-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `SU-ES384`
* Algorithm Description: Single-Use JWP using ES384
* Algorithm Usage Location(s): Issued, Presented
* JWP Implementation Requirements: Optional
* Change Controller: IETF
* Specification Document(s): (#SU-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `SU-ES512`
* Algorithm Description: Single-Use JWP using ES512
* Algorithm Usage Location(s): Issued, Presented
* JWP Implementation Requirements: Optional
* Change Controller: IETF
* Specification Document(s): (#SU-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `BBS`
* Algorithm Description: Corresponds to a ciphersuite identifier of `BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_H2G_HM2S_`
* Algorithm Usage Location(s): Issued
* JWP Implementation Requirements: Required
* Change Controller: IETF
* Specification Document(s): (#BBS-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `BBS-PROOF`
* Algorithm Description: Corresponds to a ciphersuite identifier of `BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_H2G_HM2S_`
* Algorithm Usage Location(s): Presented
* JWP Implementation Requirements: Required
* Change Controller: IETF
* Specification Document(s): (#BBS-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `MAC-H256`
* Algorithm Description: `MAC-H256` uses `HMAC SHA-256` as the MAC and `ECDSA using P-256 and SHA-256` for the signatures
* Algorithm Usage Location(s): Issued, Presented
* JWP Implementation Requirements: Optional
* Change Controller: IETF
* Specification Document(s): (#MAC-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `MAC-H384`
* Algorithm Description: `MAC-H384` uses `HMAC SHA-384` as the MAC and `ECDSA using P-384 and SHA-384` for the signatures
* Algorithm Usage Location(s): Issued, Presented
* JWP Implementation Requirements: Optional
* Change Controller: IETF
* Specification Document(s): (#MAC-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `MAC-H512`
* Algorithm Description: `MAC-H512` uses `HMAC SHA-512` as the MAC and `ECDSA using P-521 and SHA-512` for the signatures
* Algorithm Usage Location(s): Issued, Presented
* JWP Implementation Requirements: Optional
* Change Controller: IETF
* Specification Document(s): (#MAC-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `MAC-K25519`
* Algorithm Description: `MAC-K25519` uses `KMAC SHAKE128` as the MAC and `EdDSA using Curve25519` for the signatures
* Algorithm Usage Location(s): Issued, Presented
* JWP Implementation Requirements: Optional
* Change Controller: IETF
* Specification Document(s): (#MAC-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `MAC-K448`
* Algorithm Description: `MAC-K448` uses `KMAC SHAKE256` as the MAC and `EdDSA using Curve448` for the signatures
* Algorithm Usage Location(s): Issued, Presented
* JWP Implementation Requirements: Optional
* Change Controller: IETF
* Specification Document(s): (#MAC-registration) of this specification
* Algorithm Analysis Documents(s): n/a

* Algorithm Name: `MAC-H256K`
* Algorithm Description: `MAC-H256K` uses `HMAC SHA-256` as the MAC and `ECDSA using secp256k1 and SHA-256` for the signatures
* Algorithm Usage Location(s): Issued, Presented
* JWP Implementation Requirements: Optional
* Change Controller: IETF
* Specification Document(s): (#MAC-registration) of this specification
* Algorithm Analysis Documents(s): n/a

## Header Parameter Names Registration {#HdrReg}

This section registers the following Header Parameter names
defined by this specification in the IANA
"JSON Web Proof Header Parameters" registry
established by [@!I-D.ietf-jose-json-web-proof].

### Registry Contents {#HdrContents}

* Header Parameter Name: `proof_jwk`
* Header Parameter Description: Issuer's Ephemeral Key
* Header Parameter Usage Location(s): Issued
* Change Controller: IETF
* Specification Document(s): (#issuer-protected-header) of this specification

* Header Parameter Name: `presentation_jwk`
* Header Parameter Description: Holder's Presentation Key
* Header Parameter Usage Location(s): Issued
* Change Controller: IETF
* Specification Document(s): (#issuer-protected-header) of this specification


{backmatter}

<reference anchor="VC-DATA-MODEL-2.0" target="https://www.w3.org/TR/vc-data-model-2.0">
  <front>
    <title>Verifiable Credentials Data Model 2.0</title>
    <author fullname="Manu Sporny">
      <organization>Digital Bazaar</organization>
    </author>
    <author fullname="Ted Thibodeau Jr">
      <organization>OpenLink Software</organization>
    </author>
    <author fullname="Ivan Herman">
      <organization>W3C</organization>
    </author>
    <author fullname="Michael B. Jones">
      <organization>Invited Expert</organization>
    </author>
    <author fullname="Gabe Cohen">
      <organization>Block</organization>
    </author>
   <date day="27" month="December" year="2023"/>
  </front>
</reference>


# Example JWPs

The following examples use algorithms defined in JSON Proof Algorithms and also contain the keys used, so that implementations can validate these samples.

## Example Single-Use JWP

This example uses the Single-Use Algorithm as defined in JSON Proof Algorithms to create a JSON Proof Token.  It demonstrates how to apply selective disclosure using an array of traditional JWS-based signatures.  Unlinkability is only achieved by using each JWP one time, as multiple uses are inherently linkable via the traditional ECDSA signature embedded in the proof.

To begin, we need two asymmetric keys for Single Use: one that represents the JPT Issuer's stable key and the other is an ephemeral key generated by the Issuer just for this JWP.

This is the Issuer's stable private key used in this example in the JWK format:

<{{./fixtures/build/issuer-private-key-es256.jwk.wrapped}}
Figure: Issuer Private Key (es256)

This is the ephemeral private key used in this example in the JWK format:

<{{./fixtures/build/ephemeral-private-key-es256.jwk.wrapped}}
Figure: Issuer Ephemeral Private Key (es256)

This is the Holder's presentation private key used in this example in the JWK format:

<{{./fixtures/build/holder-private-key-es256.jwk.wrapped}}
Figure: Holder Presentation Private Key

The JWP Protected Header declares that the data structure is a JPT and the JWP Proof Input is secured using the Single-Use ECDSA algorithm with the P-256 curve and SHA-256 digest.  It also includes the ephemeral public key, the Holder's presentation public key and list of claims used for this JPT.

<{{./fixtures/build/su-es256-issuer-protected-header.json.wrapped}}
Figure: Issuer Protected header (es256)

The JWP Protected Header is serialized (without the above whitespace added for readability) into UTF-8, then BASE64URL-encoded. This gives:

<{{./fixtures/build/su-es256-issuer-protected-header.b64.wrapped}}
Figure: Encoded Issuer Protected Header (es256)

The Single Use algorithm utilizes multiple individual JWS Signatures.  Each signature value is generated by creating a JWS with a single Protected Header with the associated `alg` value. In this example, the fixed header used for each JWS is the serialized JSON Object `{"alg":"ES256"}`.  The JWS payload for each varies and the resulting signature value is used in its unencoded form (the octet string, not the base64url-encoded form).

The final Proof value from the Issuer is the concatenated array of the header signature followed by all of the payload signatures, then base64url encoded.

The resulting JSON serialized JPT using the above examples is:

<{{./fixtures/build/su-es256-issuer.json.jwp.wrapped}}
Figure: Issued JWP in JSON Serialization (es256)

The compact serialization of the same JPT is:

<{{./fixtures/build/su-es256-issuer.compact.jwp.wrapped}}
Figure: Issued JWP in Compact Serialization (es256)

To present this JPT, we first use the following presentation header with a nonce (provided by the Verifier):

<{{./fixtures/build/su-es256-presentation-protected-header.json.wrapped}}
Figure: Presentation Header

When serialized without formatting and BASE64URL-encoded, this results in the string:

<{{./fixtures/build/su-es256-holder-protected-header.b64.wrapped}}
Figure: Presentation Header (BASE64URL-encoded)

When signed with the holder's presentation key, the resulting signature are:

<{{./fixtures/build/su-es256-holder-pop.b64.wrapped}}>
Figure: Holder Proof-of-Possession (BASE64URL-encoded)

Then by applying selective disclosure of only the given name and age claims (family name and email hidden), we get the following presented JPT:

<{{./fixtures/build/su-es256-presentation.json.jwp.wrapped}}>
Figure: Final Presentation in JSON Serialization

And also in compact serialization:

<{{./fixtures/build/su-es256-presentation.compact.jwp.wrapped}}>
Figure: Final Presentation in Compact Serialization

## Example BBS JWP

The following example uses the `BBS` algorithm.


This is the Issuer's stable private key in the JWK format:

<{{./fixtures/build/private-key.jwk.wrapped}}
Figure: BBS private key in JWK format

There is no additional holder key necessary for presentation proofs.

For the following protected header and array of payloads:

<{{./fixtures/template/jpt-issuer-protected-header.json}}
Figure: Example issuer protected header

<{{./fixtures/template/jpt-issuer-payloads.json}}
Figure: Example issuer payloads (as members of a JSON array)

These components are signed using the private issuer key previously given, which is then representable in the following serializations:

<{{./fixtures/build/bbs-issuer.json.jwp.wrapped}}
Figure: Issued JWP (JSON serialization)

<{{./fixtures/build/bbs-issuer.compact.jwp.wrapped}}
Figure: Issued JWP (compact serialization)

For a presentation with the following presentation header:

<{{./fixtures/template/bbs-holder-presentation-header.json}}
Figure: Holder Presentation Header

The holder decides to share all information other than the email address, and generates a proof. That proof is represented in the following serializations:

<{{./fixtures/build/bbs-holder.json.jwp.wrapped}}
Figure: Presentation JWP (JSON serialization)

<{{./fixtures/build/bbs-holder.compact.jwp.wrapped}}
Figure: Presentation JWP (compact serialization)

## Example MAC JWP

The following example uses the `MAC-H256` algorithm.

This is the Issuer's stable private key in the JWK format:

<{{./fixtures/build/issuer-private-key-es256.jwk.wrapped}}
Figure: Issuer private key

This is the Issuer's ephemerally generated shared secret:

<{{./fixtures/build/issuer-nonce.json}}
Figure: Shared Secret

This is the Holder's presentation private key in the JWK format:

<{{./fixtures/build/holder-private-key-es256.jwk.wrapped}}
Figure: Holder private key

For the following protected header and array of payloads:

<{{./fixtures/build/mac-h256-issuer-protected-header.json}}
Figure: Example issuer protected header

<{{./fixtures/template/jpt-issuer-payloads.json}}
Figure: Example issuer payloads (as members of a JSON array)

The first MAC is generated using the key `issuer_header` and the base64url-encoded issuer protected header, resulting in the following base64url-encoded octet array:

<{{./fixtures/build/mac-h256-issuer-protected-header-mac.txt}}
Figure: Issuer MAC of protected header

The issuer generates an array of derived keys with one for each payload by using the shared secret as the key, and the index of the payload (as `payload_{n}` in UTF-8 encoded octets) as the input in a HMAC operation. This results in the following set of derived keys (as base64url-encoded members in a JSON array):

<{{./fixtures/build/mac-h256-issuer-derived-payload-keys.json}}
Figure: Derived payload keys

A MAC is generated for each payload using the corresponding derived payload key. This results in the following set of MAC values (as base64url-encoded members in a JSON array):

<{{./fixtures/build/mac-h256-payload-macs.json}}
Figure: Payload MAC values

The proof is the concatenation of the issuer protected header MAC, each payload MAC value, and the shared secret. The result is the following base64url-encoded value:

<{{./fixtures/build/mac-h256-issued-proof.txt.wrapped}}
Figure: Issued Proof

The final issued JWP in JSON serialization is:

<{{./fixtures/build/mac-h256-issuer.json.jwp.wrapped}}
Figure: Issued JWP (in JSON serialization)

The same JWP in compact serialization:

<{{./fixtures/build/mac-h256-issuer.compact.jwp.wrapped}}
Figure: Issued JWP (in compact serialization)

Next, we show the presentation of the JWP with selective disclosure.

For presentation with the following presentation protected header:

<{{./fixtures/build/mac-h256-presentation-protected-header.json.wrapped}}
Figure: Presentation Protected Header

The holder will take the issuer proof (including shared secret) and derive the same individual payload MAC values (above).

In this case, the holder has decided not to disclose the last three claims provided by the issuer (corresponding to `email`, `address`, and `age_over_21`)

For the disclosed payloads, the holder will provide the corresponding derived key. For the non-disclosed payloads, the holder will provide the corresponding MAC value. This corresponds to the following JSON array of base64url-encoded values:

<{{./fixtures/build/mac-h256-presentation-disclosures.json.wrapped}}
Figure: Per-payload disclosure information.

The final presented proof value is generated by concatenating first the presentation header signature octet string, followed by the issuer signature octet string, then followed by either the MAC value or derived key for a payload (above). This results in the following base64url-encoded proof value:

<{{./fixtures/build/mac-h256-presentation-proof.txt.wrapped}}
Figure: Presentation proof

The final presented JWP in JSON serialization is:

<{{./fixtures/build/mac-h256-presentation.json.jwp.wrapped}}
Figure: Presented JWP (in JSON serialization)

The same JWP in compact serialization:

<{{./fixtures/build/mac-h256-presentation.compact.jwp.wrapped}}
Figure: Presented JWP (in compact serialization)

# Acknowledgements

This work was incubated in the DIF [Applied Cryptography Working Group](https://identity.foundation/working-groups/crypto.html).

We would like to thank
Alberto Solavagione
for his valuable contributions to this specification.

The BBS examples were generated using the library at https://github.com/mattrglobal/pairing_crypto .

# Document History

  [[ To be removed from the final specification ]]

  * Update of appendix describing MAC-H256 to now also be generated by the build system from a common set of code and templates

  -04

  * Refactoring figures and examples to be built from a common set across all three documents
  * Move single-use example appendix from JWP to JPA
  * Change algorithm from `BBS-DRAFT-5` to `BBS`, and from `BBS-PROOF-DRAFT-5` to `BBS-PROOF`
  * Update BBS ciphersuite ID to `BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_`
  * Update to draft 5 BLS key representations

  -03

  * Improvements resulting from a full proofreading.
  * Populated IANA Considerations section.
  * Updated to use BBS draft -05.
  * Updated examples.

  -02

  * Add new `BBS-DRAFT-3` and `BBS-PROOF-DRAFT-3` algorithms based on draft-irtf-cfrg-bbs-signatures-03.
  * Remove prior `BBS-X` algorithm based on a particular implementation of earlier drafts.

  -01

  * Correct cross-references within group
  * Describe `issuer_header` and `presentation_header`
  * Update BBS references to CFRG drafts
  * Rework reference to HMAC ( RFC2104 )
  * Remove ZKSnark placeholder

  -00

  * Created initial working group draft based on draft-jmiller-jose-json-proof-algorithms-01
